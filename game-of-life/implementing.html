<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>üöß Impl√©menter la vie - Rust et WebAssembly</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> üöß Introduction</a></li><li><ol class="section"><li class="expanded "><a href="../translation-terms.html"><strong aria-hidden="true">1.1.</strong> Traduction des termes</a></li></ol></li><li class="expanded "><a href="../why-rust-and-webassembly.html"><strong aria-hidden="true">2.</strong> üöß Pourquoi Rust et le WebAssembly¬†?</a></li><li class="expanded "><a href="../background-and-concepts.html"><strong aria-hidden="true">3.</strong> üöß Le contexte et les concepts</a></li><li><ol class="section"><li class="expanded "><a href="../what-is-webassembly.html"><strong aria-hidden="true">3.1.</strong> üöß Qu'est-ce que le WebAssembly¬†?</a></li><li class="spacer"></li></ol></li><li class="expanded "><a href="../game-of-life/introduction.html"><strong aria-hidden="true">4.</strong> üöß Tutoriel</a></li><li><ol class="section"><li class="expanded "><a href="../game-of-life/setup.html"><strong aria-hidden="true">4.1.</strong> üöß R√©glages</a></li><li class="expanded "><a href="../game-of-life/hello-world.html"><strong aria-hidden="true">4.2.</strong> üöß Hello, World¬†!</a></li><li class="expanded "><a href="../game-of-life/rules.html"><strong aria-hidden="true">4.3.</strong> üöß Les r√®gles</a></li><li class="expanded "><a href="../game-of-life/implementing.html" class="active"><strong aria-hidden="true">4.4.</strong> üöß Impl√©menter la vie</a></li><li class="expanded "><a href="../game-of-life/testing.html"><strong aria-hidden="true">4.5.</strong> üöß Tester la vie</a></li><li class="expanded "><a href="../game-of-life/debugging.html"><strong aria-hidden="true">4.6.</strong> üöß D√©bogage</a></li><li class="expanded "><a href="../game-of-life/interactivity.html"><strong aria-hidden="true">4.7.</strong> üöß Ajouter de l'interactivit√©</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust et WebAssembly</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1><a class="header" href="#-attention-peinture-fra√Æche-" id="-attention-peinture-fra√Æche-">üöß Attention, peinture fra√Æche !</a></h1>
<p>Cette page a √©t√© traduite par une seule personne et n'a pas √©t√© relue et
v√©rifi√©e par quelqu'un d'autre ! Les informations peuvent par exemple √™tre
erron√©es, √™tre formul√©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Implementing Conway's Game of Life
-->
<h1><a class="header" href="#impl√©menter-le-jeu-de-la-vie-de-conway" id="impl√©menter-le-jeu-de-la-vie-de-conway">Impl√©menter le jeu de la vie de Conway</a></h1>
<!--
## Design
-->
<h2><a class="header" href="#conception" id="conception">Conception</a></h2>
<!--
Before we dive in, we have some design choices to consider.
-->
<p>Avant de nous plonger dans le sujet, nous devons prendre en consid√©ration
quelques choix de conception.</p>
<!--
### Infinite Universe
-->
<h3><a class="header" href="#un-univers-infini" id="un-univers-infini">Un univers infini</a></h3>
<!--
The Game of Life is played in an infinite universe, but we do not have infinite
memory and compute power. Working around this rather annoying limitation usually
comes in one of three flavors:
-->
<p>Le jeu de la vie se d√©roule dans un univers infini, mais nous n'avons pas une
m√©moire et une puissance de calcul infinie. Pour contourner cette limitation
plut√¥t ennuyeuse, il a g√©n√©ralement trois possibilit√©s¬†:</p>
<!--
1. Keep track of which subset of the universe has interesting things happening,
   and expand this region as needed. In the worst case, this expansion is
   unbounded and the implementation will get slower and slower and eventually
   run out of memory.
-->
<ol>
<li>Identifier dans quel sous-ensemble de l'univers il se passe des choses
int√©ressantes, et agrandir cette zone si n√©cessaire. Dans le pire des cas,
cette expansion se fera sans limites et donc la simulation deviendra de plus
en plus lent et arrivera √† cours de m√©moire.</li>
</ol>
<!--
2. Create a fixed-size universe, where cells on the edges have fewer neighbors
   than cells in the middle. The downside with this approach is that infinite
   patterns, like gliders, that reach the end of the universe are snuffed out.
-->
<ol start="2">
<li>Cr√©er un univers √† taille fixe, dans lequel les cellules sur ses bords auront
moins de voisines que les cellules au centre. Le d√©savantage de cette
approche est que les sch√©mas infinis, comme les planeurs, qui atteignent
probablement la fin de l'univers, seront √©limin√©s.</li>
</ol>
<!--
3. Create a fixed-size, periodic universe, where cells on the edges have
   neighbors that wrap around to the other side of the universe. Because
   neighbors wrap around the edges of the universe, gliders can keep running
   forever.
-->
<ol start="3">
<li>Cr√©er un univers √† taille fixe, mais en boucle, o√π les cellules sur les bords
seront directement voisines de celles qui sont de l'autre c√¥t√© de l'univers.
Comme les voisines de recoupent d'un bout √† l'autre de l'univers, les
planeurs pourront continuer √† vivre √† l'infini.</li>
</ol>
<!--
We will implement the third option.
-->
<p>Nous allons impl√©menter la troisi√®me option.</p>
<!--
### Interfacing Rust and JavaScript
-->
<h3><a class="header" href="#interfacer-rust-et-le-javascript" id="interfacer-rust-et-le-javascript">Interfacer Rust et le JavaScript</a></h3>
<!--
> ‚ö° This is one of the most important concepts to understand and take away from
> this tutorial!
-->
<blockquote>
<p>‚ö° C'est l'un des concepts les plus importants √† comprendre et √† retenir de ce
tutoriel¬†!</p>
</blockquote>
<!--
JavaScript's garbage-collected heap ‚Äî where `Object`s, `Array`s, and DOM nodes
are allocated ‚Äî is distinct from WebAssembly's linear memory space, where our
Rust values live. WebAssembly currently has no direct access to the
garbage-collected heap (as of April 2018, this is expected to change with the
["Interface Types" proposal][interface-types]). JavaScript, on the other hand, can
read and write to the WebAssembly linear memory space, but only as an
[`ArrayBuffer`][array-buf] of scalar values (`u8`, `i32`, `f64`,
etc...). WebAssembly functions also take and return scalar values. These are the
building blocks from which all WebAssembly and JavaScript communication is
constituted.
-->
<p>Le <em>tas</em> du JavaScript qui est g√©r√© par le ramasse-miettes ‚Äî dans lequel sont
stock√©s les objets <code>Object</code>, les tableaux <code>Array</code>, et les noeuds du DOM ‚Äî se
distingue de l'espace m√©moire lin√©aire du WebAssembly, dans lequel vivent nos
valeurs Rust. WebAssembly n'a actuellement pas d'acc√®s direct au tas g√©r√© par le
ramasse-miettes (du moins en avril 2018, cela peut changer √† l'avenir avec la
<a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md">proposition des &quot;Interface Types&quot;</a>). JavaScript, de l'autre
c√¥t√©, peut lire et √©crire sur l'espace m√©moire lin√©aire de WebAssembly, mais
seulement via un <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> de valeurs scalaires (comme le <code>u8</code>,
<code>i32</code>, <code>f64</code>, etc ...). Les fonctions WebAssembly prennent elles aussi des
valeurs scalaires et en retourne. Ce sont les √©l√©ments de base sur lesquels
repose la communication entre WebAssembly et JavaScript.</p>
<!--
[interface-types]: https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md
[array-buf]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer
-->
<!--
`wasm_bindgen` defines a common understanding of how to work with compound
structures across this boundary. It involves boxing Rust structures, and
wrapping the pointer in a JavaScript class for usability, or indexing into a
table of JavaScript objects from Rust. `wasm_bindgen` is very convenient, but it
does not remove the need to consider our data representation, and what values
and structures are passed across this boundary. Instead, think of it as a tool
for implementing the interface design you choose.
-->
<p><code>wasm_bindgen</code> d√©finit une vision partag√©e pour travailler avec des structures
compos√©es pour passer outre ces limites. Cette crate passe une structure Rust
dans une <code>std::boxed::Box</code> et enveloppe ce pointeur dans une classe JavaScript
pour faciliter son utilisation, ou utilise des indices dans une table d'objets
dans Rust qui repr√©sentent des objets JavaScript. <code>wasm_bindgen</code> est tr√®s utile,
mais nous devons toujours garder en t√™te comment les donn√©es sont mod√©lis√©es, et
quelles sont les valeurs et les structures qui passent entre ces deux domaines.
Consid√©rez-la plut√¥t comme un outil permettant de choisir votre moyen pour
s'interfacer.</p>
<!--
When designing an interface between WebAssembly and JavaScript, we want to
optimize for the following properties:
-->
<p>Lorsqu'on con√ßoit une interface entre WebAssembly et JavaScript, nous voulons
optimiser les propri√©t√©s suivantes¬†:</p>
<!--
1. **Minimizing copying into and out of the WebAssembly linear memory.**
   Unnecessary copies impose unnecessary overhead.
-->
<ol>
<li><strong>R√©duire au maximum les copies de donn√©es sur et √† partir de la m√©moire
lin√©aire de WebAssembly.</strong>
Les copies inutiles provoquent des surcharges inutiles.</li>
</ol>
<!--
2. **Minimizing serializing and deserializing.** Similar to copies, serializing
   and deserializing also imposes overhead, and often imposes copying as
   well. If we can pass opaque handles to a data structure ‚Äî instead of
   serializing it on one side, copying it into some known location in the
   WebAssembly linear memory, and deserializing on the other side ‚Äî we can often
   reduce a lot of overhead. `wasm_bindgen` helps us define and work with opaque
   handles to JavaScript `Object`s or boxed Rust structures.
-->
<ol start="2">
<li><strong>Minimiser les s√©rialisations et les d√©serialisations.</strong> Pour la m√™me raison
que pour les copies, les s√©rialisations et la d√©serialisations provoquent des
surcharges, et impose parfois aussi des copies, en plus. Si nous pouvons
utiliser des manipulateurs opaques pour une structure de donn√©es, plut√¥t que
d'avoir √† la s√©rialiser d'un c√¥t√©, de la copier dans un endroit connu dans la
m√©moire lin√©aire de WebAssembly, et la d√©serialiser de l'autre c√¥t√©, alors
tr√®s souvent on √©conomise beaucoup de ressources. <code>wasm_bindgen</code> nous aide √†
d√©finir et travailler avec des manipulateurs opaques d'objets JavaScript ou
de structures Rust int√©gr√©es dans des <code>Box</code>.</li>
</ol>
<!--
As a general rule of thumb, a good JavaScript‚ÜîWebAssembly interface design is
often one where large, long-lived data structures are implemented as Rust types
that live in the WebAssembly linear memory, and are exposed to JavaScript as
opaque handles. JavaScript calls exported WebAssembly functions that take these
opaque handles, transform their data, perform heavy computations, query the
data, and ultimately return a small, copy-able result. By only returning the
small result of the computation, we avoid copying and/or serializing everything
back and forth between the JavaScript garbage-collected heap and the WebAssembly
linear memory.
-->
<p>En r√®gle g√©n√©rale, une bonne conception d'interface JavaScript‚ÜîWebAssembly
n√©cessite souvent que les grosses structures de donn√©es √† dur√©e de vie longue
soient impl√©ment√©es comme √©tant des types Rust qui vivent dans la m√©moire
lin√©aire de WebAssembly, et soient utilis√©es en JavaScript via des manipulateurs
opaques. Le JavaScript appelle les fonctions WebAssembly export√©es qui prennent
en argument ces manipulateurs opaques, transforment leurs donn√©es, proc√®dent √†
des calculs lourds, consultent les donn√©es, et retournent finalement un petit
r√©sultat copiable. En retournant uniquement un petit r√©sultat de l'op√©ration,
nous √©vitons de copier et/ou de tout s√©rialiser tout ce qui transite entre le
tas g√©r√© par le ramasse-miettes de JavaScript et la m√©moire lin√©aire de
WebAssembly.</p>
<!--
### Interfacing Rust and JavaScript in our Game of Life
-->
<h3><a class="header" href="#interfacer-rust-et-javascript-dans-notre-jeu-de-la-vie" id="interfacer-rust-et-javascript-dans-notre-jeu-de-la-vie">Interfacer Rust et JavaScript dans notre jeu de la vie</a></h3>
<!--
Let's start by enumerating some hazards to avoid. We don't want to copy the
whole universe into and out of the WebAssembly linear memory on every tick. We
do not want to allocate objects for every cell in the universe, nor do we want
to impose a cross-boundary call to read and write each cell.
-->
<p>Commen√ßons par √©voquer les pi√®ges √† √©viter. Nous ne devons pas copier tout
l'univers √† l'int√©rieur et √† partir de la m√©moire lin√©aire de WebAssembly √†
chaque tick. Nous ne devons pas allouer des objets pour chaque cellule dans
l'univers, ni faire des appels transversaux entre les deux domaines pour lire et
√©crire chaque cellule.</p>
<!--
Where does this leave us? We can represent the universe as a flat array that
lives in the WebAssembly linear memory, and has a byte for each cell. `0` is a
dead cell and `1` is a live cell.
-->
<p>Qu'est-ce que tout cela implique¬†? Que nous pouvons repr√©senter l'univers comme
un tableau √† une dimension qui vit dans la m√©moire lin√©aire de WebAssembly, et
qui a un octet pour chaque cellule. <code>0</code> mod√©lisera une cellule morte, et <code>1</code>
sera une cellule vivante.</p>
<!--
Here is what a 4 by 4 universe looks like in memory:
-->
<p>Voici √† quoi ressemble un univers de 4 par 4 dans la m√©moire¬†:</p>
<!--
![Screenshot of a 4 by 4 universe](../images/game-of-life/universe.png)
-->
<p><img src="images/game-of-life/universe.png" alt="Capture d'√©cran d'un univers 4 par 4" /></p>
<!--
To find the array index of the cell at a given row and column in the universe,
we can use this formula:
-->
<p>Pour trouver l'indice d'une cellule dans le tableau √† partir d'une ligne et
d'une colonne, nous pouvons utiliser cette formule¬†:</p>
<!--
```text
index(row, column, universe) = row * width(universe) + column
```
-->
<pre><code class="language-text">indice(ligne, colonne, univers) = ligne * largeur(univers) + colonne
</code></pre>
<!--
We have several ways of exposing the universe's cells to JavaScript. To begin,
we will implement [`std::fmt::Display`][`Display`] for `Universe`, which we can
use to generate a Rust `String` of the cells rendered as text characters. This
Rust String is then copied from the WebAssembly linear memory into a JavaScript
String in the JavaScript's garbage-collected heap, and is then displayed by
setting HTML `textContent`. Later in the chapter, we'll evolve this
implementation to avoid copying the universe's cells between heaps and to render
to `<canvas>`.
-->
<p>Nous pouvons exposer les cellules de l'univers au JavaScript de diff√©rentes
mani√®res. Pour commencer, nous allons impl√©menter
<a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>std::fmt::Display</code></a> sur <code>Univers</code>, qui nous permettra de g√©n√©rer
une <code>String</code> en Rust des cellules qui repr√©sentera les cellules avec des
caract√®res. Cette cha√Æne de caract√®res Rust est ensuite copi√©e √† partir de la
m√©moire lin√©aire de WebAssembly dans une cha√Æne de caract√®res en JavaScript,
stock√©e dans le tas g√©r√© par le ramasse-miettes de JavaScript, et est ensuite
affich√©e dans l'√©l√©ment HTML <code>contenuTextuel</code>. Plus tard dans ce chapitre, nous
allons faire √©voluer cette impl√©mentation pour √©viter de copier les cellules de
l'univers entre les tas et les int√©grer dans un <code>&lt;canvas&gt;</code>.</p>
<!--
*Another viable design alternative would be for Rust to return a list of every
cell that changed states after each tick, instead of exposing the whole universe
to JavaScript. This way, JavaScript wouldn't need to iterate over the whole
universe when rendering, only the relevant subset. The trade off is that this
delta-based design is slightly more difficult to implement.*
-->
<p><em>Une autre conception alternative acceptable serait que Rust retourne une liste
de toutes les cellules qui changent d'√©tat apr√®s chaque tick, au lieu de donner
l'int√©gralit√© de l'univers au JavaScript. Ainsi, JavaScript n'aurait pas besoin
d'it√©rer sur tout l'univers lorsqu'il s'occupe du rendu, mais uniquement sur le
sous-ensemble concern√©. Le d√©savantage est que cette conception bas√©e sur les
diff√©rences et un peu plus difficile √† impl√©menter.</em></p>
<!--
## Rust Implementation
-->
<h2><a class="header" href="#impl√©mentation-de-rust" id="impl√©mentation-de-rust">Impl√©mentation de Rust</a></h2>
<!--
In the last chapter, we cloned an initial project template. We will modify that
project template now.
-->
<p>Dans le dernier chapitre, nous avons clon√© un mod√®le initial de projet. Nous
allons maintenant modifier ce projet.</p>
<!--
Let's begin by removing the `alert` import and `greet` function from
`wasm-game-of-life/src/lib.rs`, and replacing them with a type definition for
cells:
-->
<p>Commen√ßons par enlever l'import de <code>alert</code> et la fonction <code>saluer</code> dans
<code>wasm-jeu-de-la-vie/src/lib.rs</code>, et remplacons-les par une d√©finition d'un type
pour les cellules¬†:</p>
<!--
```rust
#[wasm_bindgen]
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1,
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cellule {
    Morte = 0,
    Vivante = 1,
}
<span class="boring">}
</span></code></pre></pre>
<!--
It is important that we have `#[repr(u8)]`, so that each cell is represented as
a single byte. It is also important that the `Dead` variant is `0` and that the
`Alive` variant is `1`, so that we can easily count a cell's live neighbors with
addition.
-->
<p>Il est important d'avoir <code>#[repr(u8)]</code> pour que chaque cellule soit repr√©sent√©e
par un seul octet. Il est aussi important que la variante <code>Morte</code> soit <code>0</code> et
que la variante <code>Vivante</code> vaut <code>1</code>, afin que nous puissions facilement compter
les voisines vivantes d'une cellule en les additionnant.</p>
<!--
Next, let's define the universe. The universe has a width and a height, and a
vector of cells of length `width * height`.
-->
<p>Ensuite, d√©finissons l'univers. L'univers a une largeur et une hauteur, et a un
vecteur de cellules qui a une taille de <code>largeur * hauteur</code>.</p>
<!--
```rust
#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec<Cell>,
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub struct Univers {
    largeur: u32,
    hauteur: u32,
    cellules: Vec&lt;Cellule&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<!--
To access the cell at a given row and column, we translate the row and column
into an index into the cells vector, as described earlier:
-->
<p>Pour acc√©der √† la cellule √† une ligne et colonne donn√©e, nous calculons
l'emplacement dans le vecteur de cellules avec la ligne et la colonne comme nous
l'avons d√©crit pr√©c√©demment¬†:</p>
<!--
```rust
impl Universe {
    fn get_index(&self, row: u32, column: u32) -> usize {
        (row * self.width + column) as usize
    }

    // ...
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Univers {
    fn calculer_indice(&amp;self, ligne: u32, colonne: u32) -&gt; usize {
        (ligne * self.largeur + colonne) as usize
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<!--
In order to calculate the next state of a cell, we need to get a count of how
many of its neighbors are alive. Let's write a `live_neighbor_count` method to
do just that!
-->
<p>Pour calculer le prochain √©tat d'une cellule, nous devons compter combien de
cellules sont vivantes dans son voisinage. Ecrivons donc une m√©thode
<code>compter_voisines_vivantes</code> pour cela¬†!</p>
<!--
```rust
impl Universe {
    // ...

    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {
        let mut count = 0;
        for delta_row in [self.height - 1, 0, 1].iter().cloned() {
            for delta_col in [self.width - 1, 0, 1].iter().cloned() {
                if delta_row == 0 && delta_col == 0 {
                    continue;
                }

                let neighbor_row = (row + delta_row) % self.height;
                let neighbor_col = (column + delta_col) % self.width;
                let idx = self.get_index(neighbor_row, neighbor_col);
                count += self.cells[idx] as u8;
            }
        }
        count
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Universe {
    // ...

    fn compter_voisines_vivantes(&amp;self, ligne: u32, colonne: u32) -&gt; u8 {
        let mut compteur = 0;
        for delta_ligne in [self.hauteur - 1, 0, 1].iter().cloned() {
            for delta_colonne in [self.largeur - 1, 0, 1].iter().cloned() {
                if delta_ligne == 0 &amp;&amp; delta_colonne == 0 {
                    continue;
                }

                let ligne_voisine = (ligne + delta_ligne) % self.hauteur;
                let colonne_voisine = (colonne + delta_colonne) % self.largeur;
                let indice = self.calculer_indice(ligne_voisine, colonne_voisine);
                compteur += self.cellules[indice] as u8;
            }
        }
        compteur
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `live_neighbor_count` method uses deltas and modulo to avoid special casing
the edges of the universe with `if`s. When applying a delta of `-1`, we *add*
`self.height - 1` and let the modulo do its thing, rather than attempting to
subtract `1`. `row` and `column` can be `0`, and if we attempted to subtract `1`
from them, there would be an unsigned integer underflow.
-->
<p>La m√©thode <code>compter_voisines_vivantes</code> utilise les deltas et les modulos pour
√©viter de traiter les cas particuliers des bords de l'univers avec le <code>if</code>.
Lorsqu'on applique un delta de <code>-1</code>, nous <em>ajoutons</em> <code>self.hauteur - 1</code> et nous
laissons le modulo faire son travail, plut√¥t que d'essayer d'enlever <code>1</code>.
<code>ligne</code> ou <code>colonne</code> peut valoir <code>0</code>, et si nous essayons de leur soustraire
<code>1</code>, nous serons alors en dehors des valeurs accept√©es par les entiers
non-sign√©s.</p>
<!--
Now we have everything we need to compute the next generation from the current
one! Each of the Game's rules follows a straightforward translation into a
condition on a `match` expression. Additionally, because we want JavaScript to
control when ticks happen, we will put this method inside a `#[wasm_bindgen]`
block, so that it gets exposed to JavaScript.
-->
<p>Maintenant, nous avons tout ce dont nous avons besoin pour calculer la prochaine
g√©n√©ration¬†! Chaque r√®gle du jeu suit des transformations simples suivant des
conditions qui peuvent tenir dans une expression <code>match</code>. De plus, comme nous
souhaitons que le JavaScript contr√¥le lorsque les ticks se produisent, nous
allons int√©grer cette m√©thode dans un bloc <code>#[wasm_bindgen]</code>, pour qu'il soit
expos√© au JavaScript.</p>
<!--
```rust
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    pub fn tick(&mut self) {
        let mut next = self.cells.clone();

        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x < 2 => Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x > 3 => Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) => Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) => otherwise,
                };

                next[idx] = next_cell;
            }
        }

        self.cells = next;
    }

    // ...
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// M√©thodes publiques, export√©es en JavaScript.
#[wasm_bindgen]
impl Univers {
    pub fn tick(&amp;mut self) {
        let mut generation_suivante = self.cellules.clone();

        for ligne in 0..self.hauteur {
            for colonne in 0..self.largeur {
                let indice = self.calculer_indice(ligne, colonne);
                let cellule = self.cellules[indice];
                let voisines_vivantes = self.compter_voisines_vivantes(ligne, colonne);

                let prochain_etat = match (cellule, voisines_vivantes) {
                    // R√®gle 1¬†: toute cellule vivante avec moins de deux
                    // voisines vivantes meurt, comme si cela √©tait un effet de
                    //  sous-population.
                    (Cellule::Vivante, x) if x &lt; 2 =&gt; Cellule::Morte,
                    // R√®gle 2¬†: toute cellule vivante avec deux ou trois
                    // voisines vivantes survit jusqu'√† la prochaine g√©n√©ration.
                    (Cellule::Vivante, 2) | (Cellule::Vivante, 3) =&gt; Cellule::Vivante,
                    // R√®gle 3¬†: toute cellule vivante avec plus de trois
                    // voisines vivantes meurt, comme si cela √©tait un effet de
                    // surpopulation.
                    (Cellule::Vivante, x) if x &gt; 3 =&gt; Cellule::Morte,
                    // R√®gle 4¬†: toute cellule morte avec exactement trois
                    // voisines vivantes devient une cellule vivante, comme si
                    // cela √©tait un effet de reproduction.
                    (Cellule::Morte, 3) =&gt; Cellule::Vivante,
                    // Les cellules qui ne r√©pondent √† aucune de ces conditions
                    // restent dans le m√™me √©tat.
                    (statut, _) =&gt; statut,
                };

                generation_suivante[idx] = prochain_etat;
            }
        }

        self.cellules = generation_suivante;
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<!--
So far, the state of the universe is represented as a vector of cells. To make
this human readable, let's implement a basic text renderer. The idea is to write
the universe line by line as text, and for each cell that is alive, print the
Unicode character `‚óº` ("black medium square"). For dead cells, we'll print `‚óª`
(a "white medium square").
-->
<p>Pour l'instant, l'√©tat de l'univers est mod√©lis√© par un vecteur de cellules.
Pour rendre cela lisible pour un humain, impl√©mentons un rendu textuel basique.
L'id√©e est d'√©crire l'univers ligne par ligne textuellement, ainsi nous allons
√©crire le caract√®re Unicode <code>‚óº</code> (le &quot;carr√© moyen noir&quot;) pour chaque cellule
vivante. Et pour les cellules mortes, nous allons √©crire <code>‚óª</code> (le &quot;carr√© moyen
blanc&quot;).</p>
<!--
By implementing the [`Display`] trait from Rust's standard library, we can add a
way to format a structure in a user-facing manner. This will also automatically
give us a [`to_string`] method.
-->
<p>En impl√©mentant le trait <a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>Display</code></a> de la biblioth√®que standard de Rust, nous
pouvons ajouter un moyen de formater la structure de mani√®re √† ce qu'elle soit
adapt√©e pour l'utilisateur. Cela va aussi nous fournir automatiquement une
m√©thode <a href="https://doc.rust-lang.org/1.25.0/std/string/trait.ToString.html"><code>to_string</code></a>.</p>
<!--
[`Display`]: https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html
[`to_string`]: https://doc.rust-lang.org/1.25.0/std/string/trait.ToString.html
-->
<!--
```rust
use std::fmt;

impl fmt::Display for Universe {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for line in self.cells.as_slice().chunks(self.width as usize) {
            for &cell in line {
                let symbol = if cell == Cell::Dead { '‚óª' } else { '‚óº' };
                write!(f, "{}", symbol)?;
            }
            write!(f, "\n")?;
        }

        Ok(())
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt;

impl fmt::Display for Univers {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        for ligne in self.cellules.as_slice().chunks(self.largeur as usize) {
            for &amp;cellules in ligne {
                let symbole = if cellule == Cellule::Morte { '‚óª' } else { '‚óº' };
                write!(f, &quot;{}&quot;, symbole)?;
            }
            write!(f, &quot;\n&quot;)?;
        }

        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Finally, we define a constructor that initializes the universe with an
interesting pattern of live and dead cells, as well as a `render` method:
-->
<p>Enfin, nous d√©finissons un constructeur qui initialise l'univers avec un sch√©ma
int√©ressant avec des cellules vivantes et mortes, ainsi qu'une m√©thode <code>rendu</code>¬†:</p>
<!--
```rust
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn new() -> Universe {
        let width = 64;
        let height = 64;

        let cells = (0..width * height)
            .map(|i| {
                if i % 2 == 0 || i % 7 == 0 {
                    Cell::Alive
                } else {
                    Cell::Dead
                }
            })
            .collect();

        Universe {
            width,
            height,
            cells,
        }
    }

    pub fn render(&self) -> String {
        self.to_string()
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// M√©thodes publiques, export√©es en JavaScript.
#[wasm_bindgen]
impl Univers {
    // ...

    pub fn new() -&gt; Univers {
        let largeur = 64;
        let hauteur = 64;

        let cellules = (0..largeur * hauteur)
            .map(|i| {
                if i % 2 == 0 || i % 7 == 0 {
                    Cellule::Vivante
                } else {
                    Cellule::Morte
                }
            })
            .collect();

        Univers {
            largeur,
            hauteur,
            cellules,
        }
    }

    pub fn rendu(&amp;self) -&gt; String {
        self.to_string()
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
With that, the Rust half of our Game of Life implementation is complete!
-->
<p>Avec tout cela, la partie Rust de notre jeu de la vie est compl√®te¬†!</p>
<!--
Recompile it to WebAssembly by running `wasm-pack build` within the
`wasm-game-of-life` directory.
-->
<p>Recompilez-la en WebAssembly en lan√ßant <code>wasm-pack build</code> dans le dossier
<code>wasm-jeu-de-la-vie</code>.</p>
<!--
## Rendering with JavaScript
-->
<h2><a class="header" href="#le-rendu-avec-javascript" id="le-rendu-avec-javascript">Le rendu avec JavaScript</a></h2>
<!--
First, let's add a `<pre>` element to `wasm-game-of-life/www/index.html` to
render the universe into, just above the `<script>` tag:
-->
<p>Pour commencer, ajoutons une balise <code>&lt;pre&gt;</code> √†
<code>wasm-jeu-de-la-vie/www/index.html</code>, dans lequel afficher l'univers, juste avant
la balise <code>&lt;script&gt;</code>¬†:</p>
<!--
```html
<body>
  <pre id="game-of-life-canvas"></pre>
  <script src="./bootstrap.js"></script>
</body>
```
-->
<pre><code class="language-html">&lt;body&gt;
  &lt;pre id=&quot;canvas-jeu-de-la-vie&quot;&gt;&lt;/pre&gt;
  &lt;script src=&quot;./bootstrap.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<!--
Additionally, we want the `<pre>` centered in the middle of the Web page. We can
use CSS flex boxes to accomplish this task. Add the following `<style>` tag
inside `wasm-game-of-life/www/index.html`'s `<head>`:
-->
<p>De plus, nous voulons que le <code>&lt;pre&gt;</code> soit centr√© au milieu de la page Web. Nous
pouvons utiliser les boites flex pour faire cela. Ajoutez la balise <code>&lt;style&gt;</code>
suivante dans le <code>&lt;head&gt;</code> de <code>wasm-jeu-de-la-vie/www/index.html</code>¬†:</p>
<!--
```html
<style>
  body {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
</style>
```
-->
<pre><code class="language-html">&lt;style&gt;
  body {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
&lt;/style&gt;
</code></pre>
<!--
At the top of `wasm-game-of-life/www/index.js`, let's fix our import to bring in
the `Universe` rather than the old `greet` function:
-->
<p>En haut de <code>wasm-jeu-de-la-vie/www/index.js</code>, corrigeons notre import pour
importer le <code>Univers</code> plut√¥t que la vieille fonction <code>saluer</code>¬†:</p>
<!--
```js
import { Universe } from "wasm-game-of-life";
```
-->
<pre><code class="language-js">import { Univers } from &quot;wasm-jeu-de-la-vie&quot;;
</code></pre>
<!--
Also, let's get that `<pre>` element we just added and instantiate a new
universe:
-->
<p>Ensuite, obtenez la balise <code>&lt;pre&gt;</code> que nous venons juste d'ajouter et instancier
un nouvel univers¬†:</p>
<!--
```js
const pre = document.getElementById("game-of-life-canvas");
const universe = Universe.new();
```
-->
<pre><code class="language-js">const pre = document.getElementById(&quot;canvas-jeu-de-la-vie&quot;);
const univers = Univers.new();
</code></pre>
<!--
The JavaScript runs in [a `requestAnimationFrame`
loop][requestAnimationFrame]. On each iteration, it draws the current universe
to the `<pre>`, and then calls `Universe::tick`.
-->
<p>Le JavaScript ex√©cute dans <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">une boucle
<code>requestAnimationFrame</code></a>. A chaque it√©ration, il √©crit
l'univers courant dans le <code>&lt;pre&gt;</code>, et fait ensuite appel √† <code>Univers::tick</code>.</p>
<!--
[requestAnimationFrame]: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
-->
<!--
```js
const renderLoop = () => {
  pre.textContent = universe.render();
  universe.tick();

  requestAnimationFrame(renderLoop);
};
```
-->
<pre><code class="language-js">const boucleDeRendu = () =&gt; {
  pre.textContent = univers.rendu();
  univers.tick();

  requestAnimationFrame(boucleDeRendu);
};
</code></pre>
<!--
To start the rendering process, all we have to do is make the initial call for
the first iteration of the rendering loop:
-->
<p>Pour initier le processus de rendu, tout ce que nous avons √† faire est de faire
le premier appel √† la premi√®re it√©ration de la boucle de rendu¬†:</p>
<!--
```js
requestAnimationFrame(renderLoop);
```
-->
<pre><code class="language-js">requestAnimationFrame(boucleDeRendu);
</code></pre>
<!--
Make sure your development server is still running (run `npm run start` inside
`wasm-game-of-life/www`) and this is what
[http://localhost:8080/](http://localhost:8080/) should look like:
-->
<p>Assurez-vous que votre serveur de d√©veloppement continue de s'ex√©cuter (lancez
<code>npm run start</code> dans <code>wasm-jeu-de-la-vie/www</code>) et voici ce √† quoi
<a href="http://localhost:8080/">http://localhost:8080/</a> devrait ressembler¬†:</p>
<!--
[![Screenshot of the Game of Life implementation with text rendering](../images/game-of-life/initial-game-of-life-pre.png)](../images/game-of-life/initial-game-of-life-pre.png)
-->
<p><a href="./images/game-of-life/initial-game-of-life-pre.png"><img src="./images/game-of-life/initial-game-of-life-pre.png" alt="Capture d'√©cran de l'impl√©mentation du jeu de la vie avec le rendu textuel" /></a></p>
<!--
## Rendering to Canvas Directly from Memory
-->
<h2><a class="header" href="#afficher-dans-un-canvas-directement-√†-partir-de-la-m√©moire" id="afficher-dans-un-canvas-directement-√†-partir-de-la-m√©moire">Afficher dans un canvas directement √† partir de la m√©moire</a></h2>
<!--
Generating (and allocating) a `String` in Rust and then having `wasm-bindgen`
convert it to a valid JavaScript string makes unnecessary copies of the
universe's cells. As the JavaScript code already knows the width and
height of the universe, and can read WebAssembly's linear memory that make up
the cells directly, we'll modify the `render` method to return a pointer to the
start of the cells array.
-->
<p>G√©n√©rer (et allouer) un <code>String</code> en Rust et le convertir en String JavaScript
valide par <code>wasm-bindgen</code> g√©n√®re des copies inutiles des cellules de l'univers.
Comme le code JavaScript connait d√©j√† la largeur et la hauteur de l'univers,
et peux lire la m√©moire lin√©aire de WebAssembly qui contient les cellules, nous
allons modifier la m√©thode <code>rendu</code> pour retourner un pointeur vers le d√©but du
tableau des cellules.</p>
<!--
Also, instead of rendering Unicode text, we'll switch to using the [Canvas
API]. We will use this design in the rest of the tutorial.
-->
<p>De plus, au lieu d'afficher du texte Unicode, nous allons utiliser <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">l'API de
canvas</a>. Nous utiliserons alors cette conception dans la suite du
tutoriel.</p>
<!--
[Canvas API]: https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API
-->
<!--
Inside `wasm-game-of-life/www/index.html`, let's replace the `<pre>` we added
earlier with a `<canvas>` we will render into (it too should be within the
`<body>`, before the `<script>` that loads our JavaScript):
-->
<p>Dans <code>wasm-jeu-de-la-vie/www/index.html</code>, rempla√ßons le <code>&lt;pre&gt;</code> que nous avons
ajout√© pr√©c√©demment par un <code>&lt;canvas&gt;</code> dans lequel nous allons faire notre rendu
(il devrait toujours se trouver dans la <code>&lt;body&gt;</code>, avant le <code>&lt;script&gt;</code> qui charge
notre JavaScript)¬†:</p>
<!--
```html
<body>
  <canvas id="game-of-life-canvas"></canvas>
  <script src='./bootstrap.js'></script>
</body>
```
-->
<pre><code class="language-html">&lt;body&gt;
  &lt;canvas id=&quot;canvas-jeu-de-la-vie&quot;&gt;&lt;/canvas&gt;
  &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<!--
To get the necessary information from the Rust implementation, we'll need to add
some more getter functions for a universe's width, height, and pointer to its
cells array. All of these are exposed to JavaScript as well. Make these
additions to `wasm-game-of-life/src/lib.rs`:
-->
<p>Pour obtenir les informations de l'impl√©mentation Rust n√©cessaires, nous avons
besoin d'ajouter plus d'accesseurs pour obtenir la largeur, la hauteur de
l'univers, et le pointeur √† son tableau de cellules. Ils seront eux aussi
expos√©s au JavaScript. Faites ces ajouts √† <code>wasm-jeu-de-la-vie/src/lib.rs</code>¬†:</p>
<!--
```rust
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn width(&self) -> u32 {
        self.width
    }

    pub fn height(&self) -> u32 {
        self.height
    }

    pub fn cells(&self) -> *const Cell {
        self.cells.as_ptr()
    }
}
```
-->
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// M√©thodes publiques, export√©es en JavaScript.
#[wasm_bindgen]
impl Univers {
    // ...

    pub fn largeur(&amp;self) -&gt; u32 {
        self.largeur
    }

    pub fn hauteur(&amp;self) -&gt; u32 {
        self.hauteur
    }

    pub fn cellules(&amp;self) -&gt; *const Cellule {
        self.cellules.as_ptr()
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Next, in `wasm-game-of-life/www/index.js`, let's also import `Cell` from
`wasm-game-of-life`, and define some constants that we will use when rendering
to the canvas:
-->
<p>Ensuite, dans <code>wasm-jeu-de-la-vie/www/index.js</code>, ajoutons aussi l'import de
<code>Cellule</code> de <code>wasm-jeu-de-la-vie</code>, et d√©finissons quelques constantes que nous
utiliserons lorsque nous ferons le rendu dans le canvas¬†:</p>
<!--
```js
import { Universe, Cell } from "wasm-game-of-life";

const CELL_SIZE = 5; // px
const GRID_COLOR = "#CCCCCC";
const DEAD_COLOR = "#FFFFFF";
const ALIVE_COLOR = "#000000";
```
-->
<pre><code class="language-js">import { Univers, Cellule } from &quot;wasm-jeu-de-la-vie&quot;;

const TAILLE_CELLULE = 5; // px
const COULEUR_GRILLE = &quot;#CCCCCC&quot;;
const COULEUR_MORTE = &quot;#FFFFFF&quot;;
const COULEUR_VIVANTE = &quot;#000000&quot;;
</code></pre>
<!--
Now, let's rewrite the rest of this JavaScript code to no longer write to the
`<pre>`'s `textContent` but instead draw to the `<canvas>`:
-->
<p>Maintenant, r√©-√©crivons le reste du code JavaScript pour ne plus avoir √† √©crire
avec <code>textContent</code> dans le <code>&lt;pre&gt;</code> mais dessiner dans <code>&lt;canvas&gt;</code> √† la place¬†:</p>
<!--
```js
// Construct the universe, and get its width and height.
const universe = Universe.new();
const width = universe.width();
const height = universe.height();

// Give the canvas room for all of our cells and a 1px border
// around each of them.
const canvas = document.getElementById("game-of-life-canvas");
canvas.height = (CELL_SIZE + 1) * height + 1;
canvas.width = (CELL_SIZE + 1) * width + 1;

const ctx = canvas.getContext('2d');

const renderLoop = () => {
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
```
-->
<pre><code class="language-js">// Construit l'univers, et obtient sa largeur et son hauteur
const univers = Univers.new();
const largeur = univers.largeur();
const hauteur = univers.hauteur();

// Applique une taille au canvas pour accueillir toutes nos cellules et une
// bordure de 1px autour d'elles.

const canvas = document.getElementById(&quot;canvas-jeu-de-la-vie&quot;);
canvas.height = (TAILLE_CELLULE + 1) * largeur + 1;
canvas.width = (TAILLE_CELLULE + 1) * hauteur + 1;

const ctx = canvas.getContext('2d');

const boucleDeRendu = () =&gt; {
  univers.tick();

  dessinerGrille();
  dessinerCellules();

  requestAnimationFrame(boucleDeRendu);
};
</code></pre>
<!--
To draw the grid between cells, we draw a set of equally-spaced horizontal
lines, and a set of equally-spaced vertical lines. These lines criss-cross to
form the grid.
-->
<p>Pour dessiner la grille entre les cellules, nous dessinons un jeu de lignes
espac√©es r√©guli√®rement horizontalement, et un jeu de lignes espac√©es
r√©guli√®rement verticalement. Ces lignes s'entrecroisent pour former la grille.</p>
<!--
```js
const drawGrid = () => {
  ctx.beginPath();
  ctx.strokeStyle = GRID_COLOR;

  // Vertical lines.
  for (let i = 0; i <= width; i++) {
    ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);
    ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);
  }

  // Horizontal lines.
  for (let j = 0; j <= height; j++) {
    ctx.moveTo(0,                           j * (CELL_SIZE + 1) + 1);
    ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);
  }

  ctx.stroke();
};
```
-->
<pre><code class="language-js">const dessinerGrille = () =&gt; {
  ctx.beginPath();
  ctx.strokeStyle = COULEUR_GRILLE;

  // Lignes verticales.
  for (let i = 0; i &lt;= largeur; i++) {
    ctx.moveTo(i * (TAILLE_CELLULE + 1) + 1, 0);
    ctx.lineTo(i * (TAILLE_CELLULE + 1) + 1, (TAILLE_CELLULE + 1) * hauteur + 1);
  }

  // Lignes horizontales.
  for (let j = 0; j &lt;= hauteur; j++) {
    ctx.moveTo(0,                                  j * (TAILLE_CELLULE + 1) + 1);
    ctx.lineTo((TAILLE_CELLULE + 1) * largeur + 1, j * (TAILLE_CELLULE + 1) + 1);
  }

  ctx.stroke();
};
</code></pre>
<!--
We can directly access WebAssembly's linear memory via `memory`, which is
defined in the raw wasm module `wasm_game_of_life_bg`. To draw the cells, we
get a pointer to the universe's cells, construct a `Uint8Array` overlaying the
cells buffer, iterate over each cell, and draw a white or black rectangle
depending on whether the cell is dead or alive, respectively. By working with
pointers and overlays, we avoid copying the cells across the boundary on every
tick.
-->
<p>Nous pouvons acc√©der directement √† la m√©moire lin√©aire de WebAssembly via
<code>memory</code>, qui est d√©fini dans le module brut <code>wasm_jeu_de_la_vie_bg</code>. Pour
dessiner les cellules, nous obtenons le pointeur vers les cellules de l'univers,
construisons un <code>Uint8Array</code> qui sert de surcouche tampon pour les cellules,
it√®re sur chaque cellule, et dessine un rectangle blanc ou noir, respectivement
si la cellule est morte ou vivante. En travaillant avec des pointeurs et des
surcouches, nous √©vitons de copier les cellules entre les deux domaines √† chaque
tick.</p>
<!--
```js
// Import the WebAssembly memory at the top of the file.
import { memory } from "wasm-game-of-life/wasm_game_of_life_bg";

// ...

const getIndex = (row, column) => {
  return row * width + column;
};

const drawCells = () => {
  const cellsPtr = universe.cells();
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height);

  ctx.beginPath();

  for (let row = 0; row < height; row++) {
    for (let col = 0; col < width; col++) {
      const idx = getIndex(row, col);

      ctx.fillStyle = cells[idx] === Cell.Dead
        ? DEAD_COLOR
        : ALIVE_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
```
-->
<pre><code class="language-js">// Importe la m√©moire de WebAssembly au d√©but du fichier.
import { memory } from &quot;wasm-jeu-de-la-vie/wasm_jeu_de_la_vie_bg&quot;;

// ...

const calculerIndice = (ligne, colonne) =&gt; {
  return ligne * largeur + colonne;
};

const dessinerCellules = () =&gt; {
  const pointeurCellules = univers.cellules();
  const cellules = new Uint8Array(memory.buffer, pointeurCellules, largeur * hauteur);

  ctx.beginPath();

  for (let ligne = 0; ligne &lt; hauteur; ligne++) {
    for (let colonne = 0; colonne &lt; largeur; colonne++) {
      const indice = calculerIndice(ligne, colonne);

      ctx.fillStyle = cellules[indice] === Cellule.Morte
        ? COULEUR_MORTE
        : COULEUR_VIVANTE;

      ctx.fillRect(
        colonne * (TAILLE_CELLULE + 1) + 1,
        ligne * (TAILLE_CELLULE + 1) + 1,
        TAILLE_CELLULE,
        TAILLE_CELLULE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
<!--
To start the rendering process, we'll use the same code as above to start the
first iteration of the rendering loop:
-->
<p>Pour d√©marrer le processus de rendu, nous allons utiliser le m√™me code que
ci-dessus pour d√©marrer la premi√®re it√©ration de la boucle de rendu¬†:</p>
<!--
```js
drawGrid();
drawCells();
requestAnimationFrame(renderLoop);
```
-->
<pre><code class="language-js">dessinerGrille();
dessinerCellules();
requestAnimationFrame(boucleDeRendu);
</code></pre>
<!--
Note that we call `drawGrid()` and `drawCells()` here _before_ we call
`requestAnimationFrame()`. The reason we do this is so that the _initial_ state
of the universe is drawn before we make modifications. If we instead simply
called `requestAnimationFrame(renderLoop)`, we'd end up with a situation where
the first frame that was drawn would actually be _after_ the first call to
`universe.tick()`, which is the second "tick" of the life of these cells.
-->
<p>Notez que nous faisons appel √† <code>dessinerGrille()</code> et √† <code>dessinerCellules()</code> ici
<em>avant</em> de faire appel √† <code>requestAnimationFrame()</code>. La raison √† cela est que
l'√©tat <em>initial</em> de l'univers est dessin√© avant que nous proc√©dions √† nos
modifications. Si nous avions simplement appel√©
<code>requestAnimationFrame(boucleDeRendu)</code> √† la place, nous nous serions retrouv√©
dans une situation dans laquelle la premi√®re s√©quence serait dessin√©e <em>apr√®s</em>
le premier appel √† <code>univers.tick()</code>, qui est le second &quot;tick&quot; dans la vie de ces
cellules.</p>
<!--
## It Works!
-->
<h2><a class="header" href="#cela-fonctionne-" id="cela-fonctionne-">Cela fonctionne¬†!</a></h2>
<!--
Rebuild the WebAssembly and bindings glue by running this command from within
the root `wasm-game-of-life` directory:
-->
<p>Recompilez le WebAssembly et la glue de liaison en lan√ßant cette commande dans
le dossier racine <code>wasm-jeu-de-la-vie</code>¬†:</p>
<!--
```
wasm-pack build
```
-->
<pre><code>wasm-pack build
</code></pre>
<!--
Make sure your development server is still running. If it isn't, start it again
from within the `wasm-game-of-life/www` directory:
-->
<p>Assurez-vous que votre serveur de d√©veloppement fonctionne toujours. Si ce n'est
plus le cas, relancez-le dans le dossier <code>wasm-jeu-de-la-vie/www</code>¬†:</p>
<!--
```
npm run start
```
-->
<pre><code>npm run start
</code></pre>
<!--
If you refresh [http://localhost:8080/](http://localhost:8080/), you should be
greeted with an exciting display of life!
-->
<p>Si vous rafra√Æchissez <a href="http://localhost:8080/">http://localhost:8080/</a>, vous
devriez √™tre accueilli par une simulation de la vie captivante¬†!</p>
<!--
[![Screenshot of the Game of Life implementation](../images/game-of-life/initial-game-of-life.png)](../images/game-of-life/initial-game-of-life.png)
-->
<p><a href="images/game-of-life/initial-game-of-life.png"><img src="images/game-of-life/initial-game-of-life.png" alt="Capture d'√©cran de l'impl√©mentation du jeu de la vie" /></a></p>
<!--
As an aside, there is also a really neat algorithm for implementing the Game of
Life called [hashlife](https://en.wikipedia.org/wiki/Hashlife). It uses
aggressive memoizing and can actually get *exponentially faster* to compute
future generations the longer it runs! Given that, you might be wondering why we
didn't implement hashlife in this tutorial. It is out of scope for this text,
where we are focusing on Rust and WebAssembly integration, but we highly
encourage you to go learn about hashlife on your own!
-->
<p>Ceci dit, il existe aussi un algorithme tr√®s int√©ressant pour impl√©menter le jeu
de la vie qui s'appelle <a href="https://fr.wikipedia.org/wiki/Hashlife">hashlive</a>. Il
utilise une m√©thode de gestion de la m√©moire pouss√©e et peut devenir
<em>exponentiellement plus rapide</em> pour calculer les prochaines g√©n√©rations au fur
et √† mesure qu'il s'ex√©cute¬†! Sachant cela, vous vous demandez peut-√™tre
pourquoi nous n'avons pas impl√©ment√© hashlife dans ce tutoriel. Ce n'est pas le
but de ce document, car nous nous concentrons sur l'int√©gration de Rust en
WebAssembly, mais nous vous encourageons vivement d'en apprendre plus sur
hashlife par vous-m√™me¬†!</p>
<!--
## Exercises
-->
<h2><a class="header" href="#exercices" id="exercices">Exercices</a></h2>
<!--
* Initialize the universe with a single space ship.
-->
<ul>
<li>Initialiser l'univers avec un simple vaisseau spatial.</li>
</ul>
<!--
* Instead of hard-coding the initial universe, generate a random one, where each
  cell has a fifty-fifty chance of being alive or dead.
-->
<ul>
<li>
<p>Au lieu de coder en dur l'univers initial, g√©n√©rez-en un al√©atoire, dans
lequel chaque cellule a cinquante pour cent de chance d'√™tre vivante ou morte.</p>
<!--
*Hint: use [the `js-sys` crate](https://crates.io/crates/js-sys) to import
[the `Math.random` JavaScript
function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random).*
-->
<p><em>Astuce¬†: utilisez <a href="https://crates.io/crates/js-sys">la crate <code>js-sys</code></a> pour
importer <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random">la fonction JavaScript
<code>Math.random</code></a>.</em></p>
<!--
<details>
  <summary>Answer</summary>
  *First, add `js-sys` as a dependency in `wasm-game-of-life/Cargo.toml`:*

  ```toml
  # ...
  [dependencies]
  js-sys = "0.3"
  # ...
  ```

  *Then, use the `js_sys::Math::random` function to flip a coin:*

  ```rust
  extern crate js_sys;

  // ...

  if js_sys::Math::random() < 0.5 {
      // Alive...
  } else {
      // Dead...
  }
  ```
</details>
-->
<details>
  <summary>R√©ponse</summary>
<p><em>Premi√®rement, ajoutez <code>js-sys</code> comme d√©pendance dans
<code>wasm-jeu-de-la-vie/Cargo.toml</code>¬†:</em></p>
<pre><code class="language-toml"># ...
[dependencies]
js-sys = &quot;0.3&quot;
# ...
</code></pre>
<p><em>Ensuite, utilisez la fonction <code>js_sys::Math::random</code> pour g√©n√©rer un nombre
al√©atoire¬†:</em></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>extern crate js_sys; // (facultatif √† partir de Rust 2018)

// ...

if js_sys::Math::random() &lt; 0.5 {
    // Vivante ...
} else {
    // Morte ...
}
<span class="boring">}
</span></code></pre></pre>
</details>
</li>
</ul>
<!--
* Representing each cell with a byte makes iterating over cells easy, but it
  comes at the cost of wasting memory. Each byte is eight bits, but we only
  require a single bit to represent whether each cell is alive or dead. Refactor
  the data representation so that each cell uses only a single bit of space.
-->
<ul>
<li>
<p>Repr√©senter chaque cellule avec un octet facilite l'it√©ration sur les
cellules, mais cela gaspille de la m√©moire. Chaque octet a huit bits, mais
nous n'avons besoin d'un seul bit pour repr√©senter si chaque cellule est
vivante ou morte. Remaniez la repr√©sentation des donn√©es pour que chaque
cellule utilise uniquement un seul bit en m√©moire.</p>
<!--
<details>
  <summary>Answer</summary>

  In Rust, you can use [the `fixedbitset` crate and its `FixedBitSet`
  type](https://crates.io/crates/fixedbitset) to represent cells instead of
  `Vec<Cell>`:

  ```rust
  // Make sure you also added the dependency to Cargo.toml!
  extern crate fixedbitset;
  use fixedbitset::FixedBitSet;

  // ...

  #[wasm_bindgen]
  pub struct Universe {
      width: u32,
      height: u32,
      cells: FixedBitSet,
  }
  ```

  The Universe constructor can be adjusted the following way:

  ```rust
  pub fn new() -> Universe {
      let width = 64;
      let height = 64;

      let size = (width * height) as usize;
      let mut cells = FixedBitSet::with_capacity(size);

      for i in 0..size {
          cells.set(i, i % 2 == 0 || i % 7 == 0);
      }

      Universe {
          width,
          height,
          cells,
      }
  }
  ```

  To update a cell in the next tick of the universe, we use the `set` method
  of `FixedBitSet`:

  ```rust
  next.set(idx, match (cell, live_neighbors) {
      (true, x) if x < 2 => false,
      (true, 2) | (true, 3) => true,
      (true, x) if x > 3 => false,
      (false, 3) => true,
      (otherwise, _) => otherwise
  });
  ```

  To pass a pointer to the start of the bits to JavaScript, you can convert
  the `FixedBitSet` to a slice and then convert the slice to a pointer:

  ```rust
  #[wasm_bindgen]
  impl Universe {
      // ...

      pub fn cells(&self) -> *const u32 {
          self.cells.as_slice().as_ptr()
      }
  }
  ```

  In JavaScript, constructing a `Uint8Array` from Wasm memory is the same as
  before, except that the length of the array is not `width * height` anymore,
  but `width * height / 8` since we have a cell per bit rather than per byte:

  ```js
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);
  ```

  Given an index and `Uint8Array`, you can determine whether the
  *n<sup>th</sup>* bit is set with the following function:

  ```js
  const bitIsSet = (n, arr) => {
    const byte = Math.floor(n / 8);
    const mask = 1 << (n % 8);
    return (arr[byte] & mask) === mask;
  };
  ```

  Given all that, the new version of `drawCells` looks like this:

  ```js
  const drawCells = () => {
    const cellsPtr = universe.cells();

    // This is updated!
    const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);

    ctx.beginPath();

    for (let row = 0; row < height; row++) {
      for (let col = 0; col < width; col++) {
        const idx = getIndex(row, col);

        // This is updated!
        ctx.fillStyle = bitIsSet(idx, cells)
          ? ALIVE_COLOR
          : DEAD_COLOR;

        ctx.fillRect(
          col * (CELL_SIZE + 1) + 1,
          row * (CELL_SIZE + 1) + 1,
          CELL_SIZE,
          CELL_SIZE
        );
      }
    }

    ctx.stroke();
  };
  ```

</details>
-->
<details>
  <summary>R√©ponse</summary>
<p>En Rust, vous pouvez utiliser <a href="https://crates.io/crates/fixedbitset">la crate <code>fixedbitset</code> et son type
<code>FixedBitSet</code></a> pour repr√©senter les
cellules au lieu d'utiliser <code>Vec&lt;Cell&gt;</code>¬†:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Assurez-vous d'avoir aussi ajout√© la d√©pendance dans Cargo.toml¬†!
extern crate fixedbitset; // (facultatif en Rust 2018)
use fixedbitset::FixedBitSet;

// ...

#[wasm_bindgen]
pub struct Univers {
    largeur: u32,
    hauteur: u32,
    cellules: FixedBitSet,
}
<span class="boring">}
</span></code></pre></pre>
<p>Le constructeur de l'Univers peut √™tre corrig√© comme ceci¬†:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Univers {
    let largeur = 64;
    let hauteur = 64;

    let taille = (largeur * hauteur) as usize;
    let mut cellules = FixedBitSet::with_capacity(taille);

    for i in 0..taille {
        cellules.set(i, i % 2 == 0 || i % 7 == 0);
    }

    Univers {
        largeur,
        hauteur,
        cellules,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Pour modifier une cellule √† la prochaine tick de l'univers, nous utilisons la
m√©thode <code>set</code> de <code>FixedBitSet</code>¬†:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>generation_suivante.set(indice, match (cellule, voisines_vivantes) {
    (true, x) if x &lt; 2 =&gt; false,
    (true, 2) | (true, 3) =&gt; true,
    (true, x) if x &gt; 3 =&gt; false,
    (false, 3) =&gt; true,
    (statut, _) =&gt; statut
});
<span class="boring">}
</span></code></pre></pre>
<p>Pour passer un pointeur vers le d√©part des bits en JavaScript, vous pouvez
convertir le <code>FixedBitSet</code> en une slice et ensuite convertir la slice en
pointeur¬†:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
impl Univers {
    // ...

    pub fn cellules(&amp;self) -&gt; *const u32 {
        self.cellules.as_slice().as_ptr()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>En JavaScript, la construction d'un <code>Uint8Array</code> √† partir de la m√©moire de
WebAssembly est la m√™me que pr√©c√©demment, except√© que la longueur du tableau
n'est plus <code>largeur * hauteur</code>, mais <code>largeur * hauteur / 8</code> puisque nous
avons un bit par cellule au lieu d'un octet¬†:</p>
<pre><code class="language-js">const cellules = new Uint8Array(memory.buffer, pointeurCellules, largeur * hauteur / 8);
</code></pre>
<p>Pour un indice et un <code>Uint8Array</code> donn√©, vous pouvez obtenir le
<em>n<sup>i√®me</sup></em> bit avec la fonction suivante¬†:</p>
<pre><code class="language-js">const bitVautTrue = (n, tableau) =&gt; {
  const octet = Math.floor(n / 8);
  const masque = 1 &lt;&lt; (n % 8);
  return (tableau[octet] &amp; masque) === masque;
};
</code></pre>
<p>En ayant tout cela, la nouvelle version de <code>dessinerCellules</code> ressemble √†
ceci¬†:</p>
<pre><code class="language-js">const dessinerCellules = () =&gt; {
  const pointeurCellules = univers.cellules();

  // On a modifi√© cela¬†!
  const cellules = new Uint8Array(memory.buffer, pointeurCellules, largeur * hauteur / 8);

  ctx.beginPath();

  for (let ligne = 0; ligne &lt; hauteur; ligne++) {
    for (let colonne = 0; colonne &lt; largeur; colonne++) {
      const indice = calculerIndice(ligne, colonne);

      // On a modifi√© cela¬†!
      ctx.fillStyle = bitVautTrue(indice, cellules)
        ? COULEUR_VIVANTE
        : COULEUR_MORTE;

      ctx.fillRect(
        colonne * (TAILLE_CELLULE + 1) + 1,
        ligne * (TAILLE_CELLULE + 1) + 1,
        TAILLE_CELLULE,
        TAILLE_CELLULE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
</details>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../game-of-life/rules.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../game-of-life/testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../game-of-life/rules.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../game-of-life/testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../github-button.js"></script>
        

        

    </body>
</html>
