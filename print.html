<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust et WebAssembly</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> ğŸš§ Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="translation-terms.html"><strong aria-hidden="true">1.1.</strong> Traduction des termes</a></li></ol></li><li class="chapter-item expanded "><a href="why-rust-and-webassembly.html"><strong aria-hidden="true">2.</strong> ğŸš§ Pourquoi Rust et le WebAssemblyÂ ?</a></li><li class="chapter-item expanded "><a href="background-and-concepts.html"><strong aria-hidden="true">3.</strong> ğŸš§ Le contexte et les concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what-is-webassembly.html"><strong aria-hidden="true">3.1.</strong> ğŸš§ Qu'est-ce que le WebAssemblyÂ ?</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="game-of-life/introduction.html"><strong aria-hidden="true">4.</strong> ğŸš§ Tutoriel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="game-of-life/setup.html"><strong aria-hidden="true">4.1.</strong> ğŸš§ RÃ©glages</a></li><li class="chapter-item expanded "><a href="game-of-life/hello-world.html"><strong aria-hidden="true">4.2.</strong> ğŸš§ Hello, WorldÂ !</a></li><li class="chapter-item expanded "><a href="game-of-life/rules.html"><strong aria-hidden="true">4.3.</strong> ğŸš§ Les rÃ¨gles</a></li><li class="chapter-item expanded "><a href="game-of-life/implementing.html"><strong aria-hidden="true">4.4.</strong> ğŸš§ ImplÃ©menter la vie</a></li><li class="chapter-item expanded "><a href="game-of-life/testing.html"><strong aria-hidden="true">4.5.</strong> ğŸš§ Tester la vie</a></li><li class="chapter-item expanded "><a href="game-of-life/debugging.html"><strong aria-hidden="true">4.6.</strong> ğŸš§ DÃ©bogage</a></li><li class="chapter-item expanded "><a href="game-of-life/interactivity.html"><strong aria-hidden="true">4.7.</strong> ğŸš§ Ajouter de l'interactivitÃ©</a></li><li class="chapter-item expanded "><a href="game-of-life/time-profiling.html"><strong aria-hidden="true">4.8.</strong> ğŸš§ Le profilage temporel</a></li><li class="chapter-item expanded "><a href="game-of-life/code-size.html"><strong aria-hidden="true">4.9.</strong> ğŸ’¬ Shrinking .wasm Size</a></li><li class="chapter-item expanded "><a href="game-of-life/publishing-to-npm.html"><strong aria-hidden="true">4.10.</strong> ğŸ’¬ Publishing to npm</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">5.</strong> ğŸ’¬ Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/crates.html"><strong aria-hidden="true">5.1.</strong> ğŸ’¬ Crates You Should Know</a></li><li class="chapter-item expanded "><a href="reference/tools.html"><strong aria-hidden="true">5.2.</strong> ğŸ’¬ Tools You Should Know</a></li><li class="chapter-item expanded "><a href="reference/project-templates.html"><strong aria-hidden="true">5.3.</strong> ğŸ’¬ Project Templates</a></li><li class="chapter-item expanded "><a href="reference/debugging.html"><strong aria-hidden="true">5.4.</strong> ğŸš§ DÃ©bogage</a></li><li class="chapter-item expanded "><a href="reference/time-profiling.html"><strong aria-hidden="true">5.5.</strong> ğŸš§ Le profilage temporel</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust et WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che-" id="-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Rust ğŸ¦€ and WebAssembly ğŸ•¸
-->
<h1><a class="header" href="#rust--et-webassembly-" id="rust--et-webassembly-">Rust ğŸ¦€ et WebAssembly ğŸ•¸</a></h1>
<!--
This small book describes how to use [Rust][] and [WebAssembly][] together.
-->
<p>Ce petit livre dÃ©crit comment utiliser ensemble <a href="https://www.rust-lang.org">Rust</a> et <a href="https://webassembly.org/">WebAssembly</a>.</p>
<p>Vous Ãªtes actuellement sur la version du livre traduite en FranÃ§ais de
<a href="https://rustwasm.github.io/docs/book/">la version en Anglais</a>.</p>
<!--
## Who is this book for?
-->
<h2><a class="header" href="#a-qui-est-destinÃ©-ce-livre-" id="a-qui-est-destinÃ©-ce-livre-">A qui est destinÃ© ce livreÂ ?</a></h2>
<!--
This book is for anyone interested in compiling Rust to WebAssembly for fast,
reliable code on the Web. You should know some Rust, and be familiar with
JavaScript, HTML, and CSS. You don't need to be an expert in any of them.
-->
<p>Ce livre est Ã©crit pour celles et ceux qui s'intÃ©ressent Ã  compiler du code en
Rust pour WebAssembly afin d'utiliser du code rapide et fiable sur le Web. Vous
devez dÃ©jÃ  connaÃ®tre le de Rust, et Ãªtre famillierÂ·e avec le Javascript, HTML
et CSS. Mais vous n'avez pas non plus besoin d'Ãªtre unÂ·e expertÂ·e avec chacun.</p>
<!--
Don't know Rust yet? [Start with *The Rust Programming Language* first.][trpl]
-->
<p>Vous ne connaissez pas encore le RustÂ ? <a href="https://jimskapt.github.io/rust-book-fr/">Commencez d'abord par parcourir le
livre <em>Le langage de programmation Rust</em></a> ou alors <a href="https://doc.rust-lang.org/book/">sa version
Anglaise</a>.</p>
<!--
Don't know JavaScript, HTML, or CSS? [Learn about them on MDN.][mdn]
-->
<p>Vous ne connaissez pas le Javascript, le HTMl, ou le CSSÂ ?
<a href="https://developer.mozilla.org/en-US/docs/Learn">En savoir plus sur eux sur le MDN</a>.</p>
<!--
## How to read this book
-->
<h2><a class="header" href="#comment-lire-ce-livre" id="comment-lire-ce-livre">Comment lire ce livre</a></h2>
<!--
You should read [the motivation for using Rust and WebAssembly
together][why-rust-wasm], as well as familiarize yourself with the [background
and concepts][background] first.
-->
<p>Vous devriez commencer par lire <a href="./why-rust-and-webassembly.html">les raisons d'utiliser Rust et WebAssembly
ensemble</a>, et vous familliariser avec le <a href="./background-and-concepts.html">contexte et les
concepts</a>.</p>
<!--
The [tutorial][] is written to be read from start to finish. You should follow
along: writing, compiling, and running the tutorial's code yourself. If you
haven't used Rust and WebAssembly together before, do the tutorial!
-->
<p>Le tutoriel est Ã©crit pour Ãªtre lu du dÃ©but Ã  la fin. Vous devez donc suivre sa
progressionÂ : Ã©crire, compiler et exÃ©cuter le code du tutorial vous aussi. Si
vous n'avez jamais utilisÃ© Rust et WebAssembly ensemble, suivez ce tutorielÂ !</p>
<!--
The [reference sections][reference] may be perused in any order.
-->
<p>Les <a href="./reference/index.html">sections rÃ©fÃ©rences</a> peuvent toutefois Ãªtre consultÃ©es dans
n'importe quel ordre.</p>
<!--
> **ğŸ’¡ Tip:** You can search through this book by clicking on the ğŸ” icon at the
> top of the page, or by pressing the `s` key.
-->
<blockquote>
<p><strong>ğŸ’¡ AstuceÂ :</strong> Vous pouvez rechercher dans ce livre en cliquant sur
l'icÃ´neÂ ğŸ” en haut de la page, ou en appuyant sur la touche <code>s</code> Ã  tout moment.</p>
</blockquote>
<!--
## Contributing to this book
-->
<h2><a class="header" href="#contribution-Ã -ce-livre" id="contribution-Ã -ce-livre">Contribution Ã  ce livre</a></h2>
<!--
This book is open source! Find a typo? Did we overlook something? [**Send us a
pull request!**][repo]
-->
<p>Ce livre est open sourceÂ ! Si vous trouvez une faute, <a href="https://github.com/Jimskapt/rust-wasm-book-fr"><strong>vous pouvez nous
envoyer une pull request</strong></a>. Si nous avons oubliÃ© quelque chose,
<a href="https://github.com/rustwasm/book"><strong>envoyez une pull request sur la version Anglaise</strong></a>Â !</p>
<!--
[Rust]: https://www.rust-lang.org
[WebAssembly]: https://webassembly.org/
[trpl]: https://doc.rust-lang.org/book/
[mdn]: https://developer.mozilla.org/en-US/docs/Learn
[why-rust-wasm]: ./why-rust-and-webassembly.html
[background]: ./background-and-concepts.html
[tutorial]: ./game-of-life/introduction.html
[reference]: ./reference/index.html
[repo]: https://github.com/rustwasm/book
-->
<h1><a class="header" href="#traduction-des-termes" id="traduction-des-termes">Traduction des termes</a></h1>
<p>Voici les principaux termes techniques qui ont Ã©tÃ© traduits de l'anglais vers le
franÃ§ais.</p>
<table><thead><tr><th>Anglais</th><th>FranÃ§ais</th><th>Remarques</th></tr></thead><tbody>
<tr><td>benchmark</td><td>test de performance</td><td>-</td></tr>
<tr><td>call tree</td><td>arbre d'appel</td><td>-</td></tr>
<tr><td>flame graph</td><td>flame graph</td><td>-</td></tr>
<tr><td>Frames Per Second</td><td>images par seconde</td><td>-</td></tr>
<tr><td>garbage collector</td><td>ramasse-miettes</td><td>-</td></tr>
<tr><td>indirection</td><td>indirection</td><td>-</td></tr>
<tr><td>inlined function</td><td>fonction intÃ©grÃ©e</td><td>-</td></tr>
<tr><td>log</td><td>journal</td><td>-</td></tr>
<tr><td>monomorphization</td><td>monomorphisation</td><td>-</td></tr>
<tr><td>profiler</td><td>profileur</td><td>-</td></tr>
<tr><td>profiling</td><td>profilage</td><td>-</td></tr>
</tbody></table>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--1" id="-attention-peinture-fraÃ®che--1">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Why Rust and WebAssembly?
-->
<h1><a class="header" href="#pourquoi-rust-et-le-webassembly-" id="pourquoi-rust-et-le-webassembly-">Pourquoi Rust et le WebAssemblyÂ ?</a></h1>
<!--
## Low-Level Control with High-Level Ergonomics
-->
<h2><a class="header" href="#ils-offrent-un-contrÃ´le-de-bas-niveau-mais-avec-une-ergonomie-de-haut-niveau" id="ils-offrent-un-contrÃ´le-de-bas-niveau-mais-avec-une-ergonomie-de-haut-niveau">Ils offrent un contrÃ´le de bas-niveau, mais avec une ergonomie de haut-niveau</a></h2>
<!--
JavaScript Web applications struggle to attain and retain reliable performance.
JavaScript's dynamic type system and garbage collection pauses don't help.
Seemingly small code changes can result in drastic performance regressions if
you accidentally wander off the JIT's happy path.
-->
<p>Les applications web en Javascript ont du mal Ã  atteindre et conserver des
performances satisfaisantes. Le systÃ¨me de type dynamique du Javascript et les
interruptions pour le ramasse-miette n'aident pas non plus. Des petits
changements en apparance mineurs peuvent impliquer de grosses rÃ©gressions de
performances si vous Ã©cartez de la trajectoire prÃ©dit par le systÃ¨me
Just-In-Time.</p>
<!--
Rust gives programmers low-level control and reliable performance. It is free
from the non-deterministic garbage collection pauses that plague JavaScript.
Programmers have control over indirection, monomorphization, and memory layout.
-->
<p>Rust offre aux dÃ©veloppeurs un contrÃ´le du bas-niveau et des performances
efficaces. Il n'est pas soumis aux interruptions du ramasse-miettes qui accable
le Javascript. Les dÃ©veloppeurs ont le contrÃ´le sur l'indirection, la
monomorphisation, et l'utilisation de la mÃ©moire.</p>
<!--
## Small `.wasm` Sizes
-->
<h2><a class="header" href="#ils-produisent-des-wasm-lÃ©gers" id="ils-produisent-des-wasm-lÃ©gers">Ils produisent des <code>.wasm</code> lÃ©gers</a></h2>
<!--
Code size is incredibly important since the `.wasm` must be downloaded over the
network. Rust lacks a runtime, enabling small `.wasm` sizes because there is no
extra bloat included like a garbage collector. You only pay (in code size) for
the functions you actually use.
-->
<p>La taille du code est trÃ¨s importante car le <code>.wasm</code> doit Ãªtre tÃ©lÃ©chargÃ© Ã 
partir du rÃ©seau. Rust n'a pas d'environnement d'exÃ©cution, ce qui permet
d'obtenir des <code>.wasm</code> lÃ©gers car il n'a pas de charge supplÃ©mentaire comme par
exemple un ramasse-miettes. Vous ne payez (en terme de taille de code) que pour
les fonctions que vous utilisez vraiment.</p>
<!--
## Do *Not* Rewrite Everything
-->
<h2><a class="header" href="#il-nest-pas-nÃ©cessaire-de-tout-rÃ©-Ã©crire" id="il-nest-pas-nÃ©cessaire-de-tout-rÃ©-Ã©crire">Il n'est <em>pas</em> nÃ©cessaire de tout rÃ©-Ã©crire</a></h2>
<!--
Existing code bases don't need to be thrown away. You can start by porting your
most performance-sensitive JavaScript functions to Rust to gain immediate
benefits. And you can even stop there if you want to.
-->
<p>La base de code existante n'a pas besoin d'Ãªtre jetÃ©e. Vous pouvez commencer par
porter en Rust vos fonctions Javascript les plus critiques pour les performances
pour obtenir immÃ©diatement des gains de performances. Et vous pouvez vous y
arrÃªter lÃ  si vous le souhaitez.</p>
<!--
## Plays Well With Others
-->
<h2><a class="header" href="#ils-saccommodent-bien-avec-les-autres" id="ils-saccommodent-bien-avec-les-autres">Ils s'accommodent bien avec les autres</a></h2>
<!--
Rust and WebAssembly integrates with existing JavaScript tooling. It supports
ECMAScript modules and you can continue using the tooling you already love, like
npm, Webpack, and Greenkeeper.
-->
<p>Rust et WebAssembly s'intÃ¨grent dans les outils existants en Javascript. Ils
supportent les modules ECMAScript et vous pouvez continuer Ã  utiliser vos outils
prÃ©fÃ©rÃ©s, comme par exemple npm ou Webpack.</p>
<!--
## The Amenities You Expect
-->
<h2><a class="header" href="#ils-offrent-des-commoditÃ©s-dont-vous-avez-besoin" id="ils-offrent-des-commoditÃ©s-dont-vous-avez-besoin">Ils offrent des commoditÃ©s dont vous avez besoin</a></h2>
<!--
Rust has the modern amenities that developers have come to expect, such as:
-->
<p>Rust offre des services que les dÃ©veloppeurs attendent implicitement, commeÂ :</p>
<!--
* strong package management with `cargo`,
-->
<ul>
<li>une gestion de packets efficiente avec <code>cargo</code>,</li>
</ul>
<!--
* expressive (and zero-cost) abstractions,
-->
<ul>
<li>des abstractions explicites (et sans coÃ»t),</li>
</ul>
<!--
* and a welcoming community! ğŸ˜Š
-->
<ul>
<li>et une communautÃ© chaleureuseÂ !Â ğŸ˜Š</li>
</ul>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--2" id="-attention-peinture-fraÃ®che--2">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Background and Concepts
-->
<h1><a class="header" href="#le-contexte-et-les-concepts" id="le-contexte-et-les-concepts">Le contexte et les concepts</a></h1>
<!--
This section provides the context necessary for diving into Rust and WebAssembly
development.
-->
<p>Cette section explique le contexte nÃ©cessaire pour comprendre le dÃ©veloppement
en Rust et WebAssembly.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--3" id="-attention-peinture-fraÃ®che--3">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# What is WebAssembly?
-->
<h1><a class="header" href="#quest-ce-que-le-webassembly-" id="quest-ce-que-le-webassembly-">Qu'est-ce que le WebAssemblyÂ ?</a></h1>
<!--
WebAssembly (wasm) is a simple machine model and executable format with an
[extensive specification]. It is designed to be portable, compact, and execute
at or near native speeds.
-->
<p>Le WebAssembly (wasm) est un modÃ¨le de systÃ¨me simple et un format d'exÃ©cutable
qui est dÃ©crit par des <a href="https://webassembly.github.io/spec/">spÃ©cifications dÃ©taillÃ©es</a>. Il
est conÃ§u pour Ãªtre portable, compacte, et s'exÃ©cuter presque aussi vite que si
c'Ã©tait un programme natif.</p>
<!--
As a programming language, WebAssembly is comprised of two formats that
represent the same structures, albeit in different ways:
-->
<p>En tant que langage de programmation, WebAssembly est constituÃ© de deux formats
qui reprÃ©sentent les mÃªmes structures, bien qu'Ã©tant dans des formats
diffÃ©rentsÂ :</p>
<!--
1. The `.wat` text format (called `wat` for "**W**eb**A**ssembly **T**ext") uses
   [S-expressions], and bears some resemblance to the Lisp family of languages
   like Scheme and Clojure.
-->
<ol>
<li>Le format textuel <code>.wat</code> (qui sont les initiales de &quot;<strong>W</strong>eb<strong>A</strong>ssembly
<strong>T</strong>ext&quot;) qui utilise les <a href="https://en.wikipedia.org/wiki/S-expression">expressions symboliques</a>, et
ressemble aux langages de la famille Lisp comme Scheme et Clojure.</li>
</ol>
<!--
2. The `.wasm` binary format is lower-level and intended for consumption
   directly by wasm virtual machines. It is conceptually similar to ELF and
   Mach-O.
-->
<ol start="2">
<li>Le format binaire <code>.wasm</code> qui est plus bas-niveau et est destinÃ© Ã  Ãªtre
utilisÃ© par des machines virtuelles pour le wasm. Il est techniquement
similaire Ã  l'ELF et au Mach-O.</li>
</ol>
<!--
For reference, here is a factorial function in `wat`:
-->
<p>Pour illustrer ceci, voici une fonction factorielle au format <code>wat</code>Â :</p>
<pre><code>(module
  (func $fac (param f64) (result f64)
    get_local 0
    f64.const 1
    f64.lt
    if (result f64)
      f64.const 1
    else
      get_local 0
      get_local 0
      f64.const 1
      f64.sub
      call $fac
      f64.mul
    end)
  (export &quot;fac&quot; (func $fac)))
</code></pre>
<!--
If you're curious about what a `wasm` file looks like you can use the [wat2wasm
demo] with the above code.
-->
<p>Si vous vous demandez Ã  quoi ressemble un fichier <code>wasm</code>, vous pouvez utiliser
la <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">dÃ©monstation wat2wasm</a> avec le code ci-dessus.</p>
<!--
## Linear Memory
-->
<h2><a class="header" href="#la-mÃ©moire-linÃ©aire" id="la-mÃ©moire-linÃ©aire">La mÃ©moire linÃ©aire</a></h2>
<!--
WebAssembly has a very simple [memory model]. A wasm module has access to a
single "linear memory", which is essentially a flat array of bytes. This
[memory can be grown] by a multiple of the page size (64K). It cannot be shrunk.
-->
<p>WebAssembly suit un <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-mem">modÃ¨le de mÃ©moire</a> trÃ¨s simple. Un module
wasm n'a accÃ¨s qu'Ã  une seule &quot;mÃ©moire linÃ©aire&quot;, qui est principalement un
tableau uniforme d'octets. Cette <a href="https://webassembly.github.io/spec/core/syntax/instructions.html#syntax-instr-memory">mÃ©moire peut Ãªtre
agrandie</a> d'une taille correspondant Ã  un multiple d'une
taille de page (64K). Elle ne peut pas Ãªtre rÃ©duite.</p>
<!--
## Is WebAssembly Just for the Web?
-->
<h2><a class="header" href="#est-ce-que-le-webassembly-est-conÃ§u-uniquement-pour-le-web-" id="est-ce-que-le-webassembly-est-conÃ§u-uniquement-pour-le-web-">Est-ce que le WebAssembly est conÃ§u uniquement pour le webÂ ?</a></h2>
<!--
Although it has currently gathered attention in the JavaScript and Web
communities in general, wasm makes no assumptions about its host
environment. Thus, it makes sense to speculate that wasm will become a "portable
executable" format that is used in a variety of contexts in the future. As of
*today*, however, wasm is mostly related to JavaScript (JS), which comes in many
flavors (including both on the Web and [Node.js]).
-->
<p>Bien qu'il ait actuellement attirÃ© l'attention des communautÃ©s JavaScript et du
web en gÃ©nÃ©ral, wasm ne sait rien sur son environnement d'accueil. Ainsi, il est
raisonnable de penser que wasm puisse devenir un format &quot;d'exÃ©cutable portable&quot;
qui puisse Ãªtre utilisÃ© Ã  l'avenir dans des contextes variÃ©s. Cependant,
<em>Ã  l'heure de l'Ã©criture de ces lignes</em>, wasm est majoritairement associÃ© au
JavaScript (JS), qui se dÃ©cline sous plusieurs formats (y compris ceux sur le
Web et dans <a href="https://nodejs.org">Node.js</a>).</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--4" id="-attention-peinture-fraÃ®che--4">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Tutorial: Conway's Game of Life
-->
<h1><a class="header" href="#tutoriel--le-jeu-de-la-vie" id="tutoriel--le-jeu-de-la-vie">TutorielÂ : le jeu de la vie</a></h1>
<!--
This is a tutorial that implements [Conway's Game of Life][gol] in Rust and
WebAssembly.
-->
<p>Ceci est un tutoriel qui va implÃ©menter <a href="https://fr.wikipedia.org/wiki/Jeu_de_la_vie">le Jeu de la vie, de Conway</a> en
Rust et WebAssembly.</p>
<!--
[gol]: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life
-->
<!--
## Who is this tutorial for?
-->
<h2><a class="header" href="#a-qui-sadresse-ce-tutoriel-" id="a-qui-sadresse-ce-tutoriel-">A qui s'adresse ce tutorielÂ ?</a></h2>
<!--
This tutorial is for anyone who already has basic Rust and JavaScript
experience, and wants to learn how to use Rust, WebAssembly, and JavaScript
together.
-->
<p>Ce tutoriel a Ã©tÃ© crÃ©Ã© pour ceux qui ont dÃ©jÃ  une expÃ©rience de base avec Rust
et le JavaScript, et qui souhaitent en savoir plus sur l'utilisation conjointe
de Rust, WebAssembly, et JavaScript.</p>
<!--
You should be comfortable reading and writing basic Rust, JavaScript, and
HTML. You definitely do not need to be an expert.
-->
<p>Vous devez donc Ãªtre Ã  l'aise pour lire et Ã©crire du code Rust, JavaScript, et
HTML. Toutefois, vous n'avez vraiment pas besoin d'en Ãªtre un expert.</p>
<!--
## What will I learn?
-->
<h2><a class="header" href="#quallons-nous-apprendre-" id="quallons-nous-apprendre-">Qu'allons-nous apprendreÂ ?</a></h2>
<!--
* How to set up a Rust toolchain for compiling to WebAssembly.
-->
<ul>
<li>Comment rÃ©gler une toolchain de Rust pour compiler en WebAssembly.</li>
</ul>
<!--
* A workflow for developing polyglot programs made from Rust, WebAssembly,
  JavaScript, HTML, and CSS.
-->
<ul>
<li>Suivre une procÃ©dure pour dÃ©velopper des programmes polyglottes constituÃ©s de
Rust, WebAssembly, HTML et CSS.</li>
</ul>
<!--
* How to design APIs to take maximum advantage of both Rust and WebAssembly's
  strengths and also JavaScript's strengths.
-->
<ul>
<li>Comment concevoir des API pour profiter des avantages Ã  la fois de Rust et de
de WebAssembly et aussi des avantages de JavaScript.</li>
</ul>
<!--
* How to debug WebAssembly modules compiled from Rust.
-->
<ul>
<li>Comment dÃ©boguer les modules en WebAssembly, compilÃ©s avec Rust.</li>
</ul>
<!--
* How to time profile Rust and WebAssembly programs to make them faster.
-->
<ul>
<li>Comment crÃ©er un profil chronologique de programmes en Rust et WebAssembly
pour amÃ©liorer leurs performances.</li>
</ul>
<!--
* How to size profile Rust and WebAssembly programs to make `.wasm` binaries
  smaller and faster to download over the network.
-->
<ul>
<li>Comment Ã©tablir un profil de poids des programmes en Rust et WebAssembly pour
rÃ©duire la taille des binaires <code>.wasm</code> et ainsi accÃ©lÃ©rer leur tÃ©lÃ©chargement
via le rÃ©seau.</li>
</ul>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--5" id="-attention-peinture-fraÃ®che--5">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Setup
-->
<h1><a class="header" href="#rÃ©glages" id="rÃ©glages">RÃ©glages</a></h1>
<!--
This section describes how to set up the toolchain for compiling Rust programs
to WebAssembly and integrate them into JavaScript.
-->
<p>Cette section dÃ©crit comment rÃ©gler la toolchain pour compiler les programmes
Rust en WebAssembly et les intÃ©grer dans JavaScript.</p>
<!--
## The Rust Toolchain
-->
<h2><a class="header" href="#la-toolchain-rust" id="la-toolchain-rust">La toolchain Rust</a></h2>
<!--
You will need the standard Rust toolchain, including `rustup`, `rustc`, and
`cargo`.
-->
<p>Vous allez avoir besoin de la toolchain Rust standard, y compris <code>rustup</code>,
<code>rustc</code>, et <code>cargo</code>.</p>
<!--
[Follow these instructions to install the Rust toolchain.][rust-install]
-->
<p><a href="https://www.rust-lang.org/tools/install">Cliquez ici pour suivre les instructions pour installer la toolchain
Rust.</a></p>
<!--
The Rust and WebAssembly experience is riding the Rust release trains to stable!
That means we don't require any experimental feature flags. However, we do
require Rust 1.30 or newer.
-->
<p>L'expÃ©rience entre Rust et WebAssembly suit les trains de publications de Rust
stableÂ ! Cela signifie que nous n'avons pas besoin de drapeaux de
fonctionnalitÃ©es expÃ©rimentales. Cependant, nous avons besoin de Rust 1.30 ou
plus rÃ©cent.</p>
<!--
## `wasm-pack`
-->
<h2><a class="header" href="#wasm-pack" id="wasm-pack"><code>wasm-pack</code></a></h2>
<!--
`wasm-pack` is your one-stop shop for building, testing, and publishing
Rust-generated WebAssembly.
-->
<p><code>wasm-pack</code> sera votre interlocuteur unique pour compiler, tester, et publier du
WebAssembly gÃ©nÃ©rÃ© par Rust.</p>
<!--
[Get `wasm-pack` here!][wasm-pack-install]
-->
<p><a href="https://rustwasm.github.io/wasm-pack/installer/">Obtenez <code>wasm-pack</code> iciÂ !</a></p>
<!--
## `cargo-generate`
-->
<h2><a class="header" href="#cargo-generate" id="cargo-generate"><code>cargo-generate</code></a></h2>
<!--
[`cargo-generate` helps you get up and running quickly with a new Rust project
by leveraging a pre-existing git repository as a template.][cargo-generate]
-->
<p><a href="https://github.com/ashleygwilliams/cargo-generate"><code>cargo-generate</code> va vous aider Ã  vous mettre sur pied rapidement avec un
nouveau projet Rust en utilisant comme modÃ¨le un dÃ©pÃ´t git dÃ©jÃ 
existant.</a></p>
<!--
Install `cargo-generate` with this command:
-->
<p>Vous pouvez installer <code>cargo-generate</code> avec cette commandeÂ :</p>
<pre><code>cargo install cargo-generate
</code></pre>
<!--
## `npm`
-->
<h2><a class="header" href="#npm" id="npm"><code>npm</code></a></h2>
<!--
`npm` is a package manager for JavaScript. We will use it to install and run a
JavaScript bundler and development server. At the end of the tutorial, we will
publish our compiled `.wasm` to the `npm` registry.
-->
<p><code>npm</code> est un gestionnaire de paquets pour JavaScript. Nous allons l'utiliser
pour installer et exÃ©cuter un bundler JavaScript et un serveur de dÃ©veloppement.
A la fin de ce tutoriel, nous allons publier notre <code>.wasm</code> dans le registre
<code>npm</code>.</p>
<!--
[Follow these instructions to install `npm`.][npm-install]
-->
<p><a href="https://www.npmjs.com/get-npm">Cliquez ici pour suivre les instructions pour installer <code>npm</code>.</a></p>
<!--
If you already have `npm` installed, make sure it is up to date with this
command:
-->
<p>Si vous avez dÃ©jÃ  <code>npm</code> d'installÃ©, assurez-vous qu'il est Ã  jour avec cette
commandeÂ :</p>
<pre><code>npm install npm@latest -g
</code></pre>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--6" id="-attention-peinture-fraÃ®che--6">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Hello, World!
-->
<h1><a class="header" href="#hello-world-" id="hello-world-">Hello, WorldÂ !</a></h1>
<!--
This section will show you how to build and run your first Rust and WebAssembly
program: a Web page that alerts "Hello, World!"
-->
<p>Cette section va vous expliquer comment compiler et exÃ©cuter votre premier
programme en Rust et WebAssemblyÂ : une page web qui affiche une boite de
dialogue &quot;Hello, WorldÂ !&quot;.</p>
<!--
Make sure you have followed the [setup instructions](setup.html) before beginning.
-->
<p>Assurez-vous que vous avez suivi les <a href="game-of-life/setup.html">rÃ©glages</a> avant de commencer.</p>
<!--
## Clone the Project Template
-->
<h2><a class="header" href="#cloner-le-modÃ¨le-de-projet" id="cloner-le-modÃ¨le-de-projet">Cloner le modÃ¨le de projet</a></h2>
<!--
The project template comes pre-configured with sane defaults, so you can quickly
build, integrate, and package your code for the Web.
-->
<p>Le modÃ¨le de projet est livrÃ© avec des rÃ©glages prÃ©configurÃ©s par dÃ©faut avec
des valeurs stables, afin que vous puissiez compiler, intÃ©grer et crÃ©er un
paquet pour le Web.</p>
<!--
Clone the project template with this command:
-->
<p>Vous pouvez cloner le modÃ¨le du projet avec cette commandeÂ :</p>
<!--
```text
cargo generate --git https://github.com/rustwasm/wasm-pack-template
```
-->
<pre><code class="language-text">cargo generate --git https://github.com/Jimskapt/wasm-pack-template-fr
</code></pre>
<p><em>(la version anglaise originale du modÃ¨le est aussi disponible Ã  l'adresse
<a href="https://github.com/rustwasm/wasm-pack-template">https://github.com/rustwasm/wasm-pack-template</a>)</em></p>
<!--
This should prompt you for the new project's name. We will use
**"wasm-game-of-life"**.
-->
<p>Elle devrait vous demander le nom du nouveau projet. Nous allons y renseigner
<strong>&quot;wasm-jeu-de-la-vie&quot;</strong>.</p>
<!--
```text
wasm-game-of-life
```
-->
<pre><code class="language-text">wasm-jeu-de-la-vie
</code></pre>
<!--
## What's Inside
-->
<h2><a class="header" href="#quest-ce-qui-est-livrÃ©-" id="quest-ce-qui-est-livrÃ©-">Qu'est-ce qui est livrÃ©Â ?</a></h2>
<!--
Enter the new `wasm-game-of-life` project
-->
<p>Entrez dans le dossier <code>wasm-jeu-de-la-vie</code> du nouveau projet ...</p>
<!--
```
cd wasm-game-of-life
```
-->
<pre><code>cd wasm-jeu-de-la-vie
</code></pre>
<!--
and let's take a look at its contents:
-->
<p>... et regardez son contenuÂ :</p>
<!--
```text
wasm-game-of-life/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ LICENSE_APACHE
â”œâ”€â”€ LICENSE_MIT
â”œâ”€â”€ README.md
â””â”€â”€ src
    â”œâ”€â”€ lib.rs
    â””â”€â”€ utils.rs
```
-->
<pre><code class="language-text">wasm-jeu-de-la-vie/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ LICENSE_APACHE
â”œâ”€â”€ LICENSE_MIT
â”œâ”€â”€ README.md
â””â”€â”€ src
    â”œâ”€â”€ lib.rs
    â””â”€â”€ utils.rs
</code></pre>
<!--
Let's take a look at a couple of these files in detail.
-->
<p>Maintenant, analysons en dÃ©tail le contenu de certains de ces fichiers.</p>
<!--
### `wasm-game-of-life/Cargo.toml`
-->
<h3><a class="header" href="#wasm-jeu-de-la-viecargotoml" id="wasm-jeu-de-la-viecargotoml"><code>wasm-jeu-de-la-vie/Cargo.toml</code></a></h3>
<!--
The `Cargo.toml` file specifies dependencies and metadata for `cargo`, Rust's
package manager and build tool. This one comes pre-configured with a
`wasm-bindgen` dependency, a few optional dependencies we will dig into later,
and the `crate-type` properly initialized for generating `.wasm` libraries.
-->
<p>Le fichier <code>Cargo.toml</code> renseigne les dÃ©pendances et les mÃ©tadonnÃ©es pour
<code>cargo</code>, le gestionnaire de paquets et outil de compilation de Rust. Ce fichier
est prÃ©configurÃ© avec une dÃ©pendance Ã  <code>wasm-bindgen</code>, quelques dÃ©pendances
optionnelles que nous verrons plus tard, ainsi que la propriÃ©tÃ© <code>crate-type</code>
bien rÃ©glÃ© pour gÃ©nÃ©rer des bibliothÃ¨ques en <code>.wasm</code>.</p>
<!--
### `wasm-game-of-life/src/lib.rs`
-->
<h3><a class="header" href="#wasm-jeu-de-la-viesrclibrs" id="wasm-jeu-de-la-viesrclibrs"><code>wasm-jeu-de-la-vie/src/lib.rs</code></a></h3>
<!--
The `src/lib.rs` file is the root of the Rust crate that we are compiling to
WebAssembly. It uses `wasm-bindgen` to interface with JavaScript. It imports the
`window.alert` JavaScript function, and exports the `greet` Rust function, which
alerts a greeting message.
-->
<p>Le fichier <code>src/lib.rs</code> est la racine de la crate Rust que nous compilerons en
WebAssembly. Il utilise <code>wasm-bindgen</code> pour s'interfacer avec JavaScript. Il
importe la fonction JavaScript <code>window.alert</code>, et exporte la fonction Rust
<code>saluer</code>, qui affiche un message de salutation.</p>
<!--
```rust
mod utils;

use wasm_bindgen::prelude::*;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
extern {
    fn alert(s: &str);
}

#[wasm_bindgen]
pub fn greet() {
    alert("Hello, wasm-game-of-life!");
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod utils;

use wasm_bindgen::prelude::*;

// Lorsque la fonctionnalitÃ© `wee_alloc` est activÃ©e, nous allons utiliser
// `wee_alloc` en tant qu'allocateur global.
#[cfg(feature = &quot;wee_alloc&quot;)]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn saluer() {
    alert(&quot;Salut, wasm-jeu-de-la-vieÂ !&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<!--
### `wasm-game-of-life/src/utils.rs`
-->
<h3><a class="header" href="#wasm-jeu-de-la-viesrcutilsrs" id="wasm-jeu-de-la-viesrcutilsrs"><code>wasm-jeu-de-la-vie/src/utils.rs</code></a></h3>
<!--
The `src/utils.rs` module provides common utilities to make working with Rust
compiled to WebAssembly easier. We will take a look at some of these utilities
in more detail later in the tutorial, such as when we look at [debugging our wasm
code](debugging.html), but we can ignore this file for now.
-->
<p>Le module <code>src/utils.rs</code> fournit quelques outils communs pour faciliter la
compilation de Rust en WebAssembly. Nous nous discuterons en dÃ©tails de ces
outils plus tard dans le tutoriel, en particulier lorsque nous demanderons
comment <a href="game-of-life/debugging.html">dÃ©boguer notre code wasm</a>, mais pour l'instant nous
pouvons nous contenter d'ignorer ce fichier.</p>
<!--
## Build the Project
-->
<h2><a class="header" href="#compiler-le-projet" id="compiler-le-projet">Compiler le projet</a></h2>
<!--
We use `wasm-pack` to orchestrate the following build steps:
-->
<p>Nous allons utiliser <code>wasm-pack</code> pour orchestrer les Ã©tapes de compilation
suivantesÂ :</p>
<!--
* Ensure that we have Rust 1.30 or newer and the `wasm32-unknown-unknown`
  target installed via `rustup`,
* Compile our Rust sources into a WebAssembly `.wasm` binary via `cargo`,
* Use `wasm-bindgen` to generate the JavaScript API for using our Rust-generated
  WebAssembly.
-->
<ul>
<li>S'assurer que nous avons Rust 1.30 ou plus rÃ©cent et la cible
<code>wasm32-unknown-unknown</code> via <code>rustup</code>,</li>
<li>Compiler nos sources Rust en binaires WebAssembly <code>.wasm</code> via <code>cargo</code>,</li>
<li>Utiliser <code>wasm-bindgen</code> pour gÃ©nÃ©rer l'API JavaScript pour utiliser notre
WebAssembly gÃ©nÃ©rÃ© par Rust.</li>
</ul>
<!--
To do all of that, run this command inside the project directory:
-->
<p>Pour faire tout cela, lancez cette commande dans le dossier du projetÂ :</p>
<pre><code>wasm-pack build
</code></pre>
<!--
When the build has completed, we can find its artifacts in the `pkg` directory,
and it should have these contents:
-->
<p>Lorsque la compilation sera achevÃ©e, nous pourrons trouver ses artefacts dans le
dossier <code>pkg</code>, et il devrait avoir ce contenuÂ :</p>
<!--
```
pkg/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ wasm_game_of_life_bg.wasm
â”œâ”€â”€ wasm_game_of_life.d.ts
â””â”€â”€ wasm_game_of_life.js
```
-->
<pre><code>pkg/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ wasm_jeu_de_la_vie_bg.wasm
â”œâ”€â”€ wasm_jeu_de_la_vie.d.ts
â””â”€â”€ wasm_jeu_de_la_vie.js
</code></pre>
<!--
The `README.md` file is copied from the main project, but the others are
completely new.
-->
<p>Le fichier <code>README.md</code> est copiÃ© Ã  partir de la racine du projet, mais les
autres sont complÃ¨tement nouveaux.</p>
<!--
### `wasm-game-of-life/pkg/wasm_game_of_life_bg.wasm`
-->
<h3><a class="header" href="#wasm-jeu-de-la-viepkgwasm_jeu_de_la_vie_bgwasm" id="wasm-jeu-de-la-viepkgwasm_jeu_de_la_vie_bgwasm"><code>wasm-jeu-de-la-vie/pkg/wasm_jeu_de_la_vie_bg.wasm</code></a></h3>
<!--
The `.wasm` file is the WebAssembly binary that is generated by the Rust
compiler from our Rust sources. It contains the compiled-to-wasm versions of all
of our Rust functions and data. For example, it has an exported "greet"
function.
-->
<p>Le fichier <code>.wasm</code> est le binaire WebAssembly qui est gÃ©nÃ©rÃ© par le compilateur
Rust Ã  partir de nos sources Rust. Il contient les formes compilÃ©es en wasm de
toutes nos fonctions et nos donnÃ©es. Par exemple, il a une fonction exportÃ©e
<code>saluer</code>.</p>
<!--
### `wasm-game-of-life/pkg/wasm_game_of_life.js`
-->
<h3><a class="header" href="#wasm-jeu-de-la-viepkgwasm-jeu-de-la-viejs" id="wasm-jeu-de-la-viepkgwasm-jeu-de-la-viejs"><code>wasm-jeu-de-la-vie/pkg/wasm-jeu-de-la-vie.js</code></a></h3>
<!--
The `.js` file is generated by `wasm-bindgen` and contains JavaScript glue for
importing DOM and JavaScript functions into Rust and exposing a nice API to the
WebAssembly functions to JavaScript. For example, there is a JavaScript `greet`
function that wraps the `greet` function exported from the WebAssembly
module. Right now, this glue isn't doing much, but when we start passing more
interesting values back and forth between wasm and JavaScript, it will help
shepherd those values across the boundary.
-->
<p>Le fichier <code>.js</code> est gÃ©nÃ©rÃ© par <code>wasm-bindgen</code> et contient la glu en JavaScript
pour importer le DOM et les fonctions JavaScript dans Rust et exposer une API
conviviale aux fonctions en WebAssembly Ã  destination du JavaScript. Par
exemple, il existe une fonction JavaScript <code>saluer</code> qui englobe la fonction
<code>saluer</code> exportÃ©e du module en WebAssembly. Pour le moment, cette glu ne fait
pas grand-chose, mais lorsque nous commencerons Ã  y envoyer des valeurs plus
intÃ©ressantes qui vont et viennent entre wasm et JavaScript, cela facilitera le
passage de l'un Ã  l'autre cÃ´tÃ©.</p>
<!--
```js
import * as wasm from './wasm_game_of_life_bg';

// ...

export function greet() {
    return wasm.greet();
}
```
-->
<pre><code class="language-js">import * as wasm from './wasm_jeu_de_la_vie_bg';

// ...

export function saluer() {
    return wasm.saluer();
}
</code></pre>
<!--
### `wasm-game-of-life/pkg/wasm_game_of_life.d.ts`
-->
<h3><a class="header" href="#wasm-jeu-de-la-viepkgwasm_jeu_de_la_viedts" id="wasm-jeu-de-la-viepkgwasm_jeu_de_la_viedts"><code>wasm-jeu-de-la-vie/pkg/wasm_jeu_de_la_vie.d.ts</code></a></h3>
<!--
The `.d.ts` file contains [TypeScript][] type declarations for the JavaScript
glue. If you are using TypeScript, you can have your calls into WebAssembly
functions type checked, and your IDE can provide autocompletions and
suggestions! If you aren't using TypeScript, you can safely ignore this file.
-->
<p>Le fichier <code>.d.ts</code> contient des dÃ©clarations de type <a href="http://www.typescriptlang.org/">TypeScript</a> pour la glu
JavaScript. Si vous utilisez TypeScript, vous pourrez faire en sorte que les
appels aux fonctions en WebAssembly vÃ©rifient les types, et votre IDE pourra
vous proposer de l'autocompletion et des suggestionsÂ ! Si vous n'utilisez pas le
TypeScript, vous pouvez ignorer ce fichier sans problÃ¨me.</p>
<!--
```typescript
export function greet(): void;
```
-->
<pre><code class="language-typescript">export function saluer(): void;
</code></pre>
<!--
### `wasm-game-of-life/pkg/package.json`
-->
<h3><a class="header" href="#wasm-jeu-de-la-viepkgpackagejson" id="wasm-jeu-de-la-viepkgpackagejson"><code>wasm-jeu-de-la-vie/pkg/package.json</code></a></h3>
<!--
[The `package.json` file contains metadata about the generated JavaScript and
WebAssembly package.][package.json] This is used by npm and JavaScript bundlers
to determine dependencies across packages, package names, versions, and a bunch
of other stuff. It helps us integrate with JavaScript tooling and allows us to
publish our package to npm.
-->
<p><a href="https://docs.npmjs.com/files/package.json">Le fichier <code>package.json</code> contient des mÃ©tadonnÃ©es sur le paquet gÃ©nÃ©rÃ© en
JavaScript et en WebAssembly</a>. Il est utilisÃ© par npm et les
packageurs JavaScript pour dÃ©crire les dÃ©pendances entre les paquets, les noms
de ces paquets, leurs versions, et un tas d'autres choses. Il nous aide Ã  nous
intÃ©grer avec les outils JavaScript et nous permet de publier notre paquet sur
npm.</p>
<!--
```json
{
  "name": "wasm-game-of-life",
  "collaborators": [
    "Your Name <your.email@example.com>"
  ],
  "description": null,
  "version": "0.1.0",
  "license": null,
  "repository": null,
  "files": [
    "wasm_game_of_life_bg.wasm",
    "wasm_game_of_life.d.ts"
  ],
  "main": "wasm_game_of_life.js",
  "types": "wasm_game_of_life.d.ts"
}
```
-->
<pre><code class="language-json">{
  &quot;name&quot;: &quot;wasm-jeu-de-la-vie&quot;,
  &quot;collaborators&quot;: [
    &quot;Votre nom &lt;votre.email@exemple.com&gt;&quot;
  ],
  &quot;description&quot;: null,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;license&quot;: null,
  &quot;repository&quot;: null,
  &quot;files&quot;: [
    &quot;wasm_jeu_de_la_vie_bg.wasm&quot;,
    &quot;wasm_jeu_de_la_vie.d.ts&quot;
  ],
  &quot;main&quot;: &quot;wasm_jeu_de_la_vie.js&quot;,
  &quot;types&quot;: &quot;wasm_jeu_de_la_vie.d.ts&quot;
}
</code></pre>
<!--
## Putting it into a Web Page
-->
<h2><a class="header" href="#tout-intÃ©grer-dans-une-page-web" id="tout-intÃ©grer-dans-une-page-web">Tout intÃ©grer dans une page web</a></h2>
<!--
To take our `wasm-game-of-life` package and use it in a Web page, we use [the
`create-wasm-app` JavaScript project template][create-wasm-app].
-->
<p>Pour intÃ©grer notre paquet <code>wasm-jeu-de-la-vie</code> dans une page Web et l'utiliser,
nous avons avoir recours au <a href="https://github.com/Jimskapt/create-wasm-app-fr">modÃ¨le de projet JavaScript
<code>create-wasm-app-fr</code></a>.</p>
<!--
[create-wasm-app]: https://github.com/rustwasm/create-wasm-app
-->
<!--
Run this command within the `wasm-game-of-life` directory:
-->
<p>Lancez ensuite la commande suivante dans le dossier <code>wasm-jeu-de-la-vie</code>Â :</p>
<!--
```
npm init wasm-app www
```
-->
<pre><code>npm init wasm-app-fr www
</code></pre>
<p>ou, pour sa version anglaiseÂ :</p>
<pre><code>npm init wasm-app www
</code></pre>
<!--
Here's what our new `wasm-game-of-life/www` subdirectory contains:
-->
<p>Maintenant, notre nouveau sous-dossier <code>wasm-jeu-de-la-vie/www</code> contientÂ :</p>
<!--
```
wasm-game-of-life/www/
â”œâ”€â”€ bootstrap.js
â”œâ”€â”€ index.html
â”œâ”€â”€ index.js
â”œâ”€â”€ LICENSE-APACHE
â”œâ”€â”€ LICENSE-MIT
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â””â”€â”€ webpack.config.js
```
-->
<pre><code>wasm-jeu-de-la-vie/www/
â”œâ”€â”€ bootstrap.js
â”œâ”€â”€ index.html
â”œâ”€â”€ index.js
â”œâ”€â”€ LICENSE-APACHE
â”œâ”€â”€ LICENSE-MIT
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â””â”€â”€ webpack.config.js
</code></pre>
<!--
Once again, let's take a closer look at some of these files.
-->
<p>A nouveau, regardons certains de ces fichiers.</p>
<!--
### `wasm-game-of-life/www/package.json`
-->
<h3><a class="header" href="#wasm-jeu-de-la-viewwwpackagejson" id="wasm-jeu-de-la-viewwwpackagejson"><code>wasm-jeu-de-la-vie/www/package.json</code></a></h3>
<!--
This `package.json` comes pre-configured with `webpack` and `webpack-dev-server`
dependencies, as well as a dependency on `hello-wasm-pack`, which is a version
of the initial `wasm-pack-template` package that has been published to npm.
-->
<p>Ce <code>package.json</code> est prÃ©configurÃ© avec les dÃ©pendances <code>webpack</code> et
<code>webpack-dev-server</code>, ainsi qu'une dÃ©pendance Ã  <code>salut-wasm-pack</code>, qui est une
version du paquet initial <code>wasm-pack-template</code> qui a Ã©tÃ© publiÃ© sur npm.</p>
<!--
### `wasm-game-of-life/www/webpack.config.js`
-->
<h3><a class="header" href="#wasm-jeu-de-la-viewwwwebpackconfigjs" id="wasm-jeu-de-la-viewwwwebpackconfigjs"><code>wasm-jeu-de-la-vie/www/webpack.config.js</code></a></h3>
<!--
This file configures webpack and its local development server. It comes
pre-configured, and you shouldn't have to tweak this at all to get webpack and
its local development server working.
-->
<p>Ce fichier configure webpack et son serveur de dÃ©veloppement local. Il est
prÃ©configurÃ© pour que vous n'ayez pas Ã  y toucher pour que webpack et son
serveur de dÃ©veloppement local fonctionnent correctement.</p>
<!--
### `wasm-game-of-life/www/index.html`
-->
<h3><a class="header" href="#wasm-jeu-de-la-viewwwindexhtml" id="wasm-jeu-de-la-viewwwindexhtml"><code>wasm-jeu-de-la-vie/www/index.html</code></a></h3>
<!--
This is the root HTML file for the Web page. It doesn't do much other than
load `bootstrap.js`, which is a very thin wrapper around `index.js`.
-->
<p>C'est le fichier HTML racine de notre page Web. Elle ne fait pas grand-chose
d'autre que de charger <code>bootstrap.js</code>, qui est une petite enveloppe autour de
<code>index.js</code>.</p>
<!--
```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello wasm-pack!</title>
  </head>
  <body>
    <script src="./bootstrap.js"></script>
  </body>
</html>
```
-->
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Salut, wasm-packÂ !&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;Cette page utilise du webassembly et du javascript, veuillez activer le javascript dans votre navigateur.&lt;/noscript&gt;
    &lt;script src=&quot;./bootstrap.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!--
### `wasm-game-of-life/www/index.js`
-->
<h3><a class="header" href="#wasm-jeu-de-la-viewwwindexjs" id="wasm-jeu-de-la-viewwwindexjs"><code>wasm-jeu-de-la-vie/www/index.js</code></a></h3>
<!--
The `index.js` is the main entry point for our Web page's JavaScript. It imports
the `hello-wasm-pack` npm package, which contains the default
`wasm-pack-template`'s compiled WebAssembly and JavaScript glue, then it calls
`hello-wasm-pack`'s `greet` function.
-->
<p>Le fichier <code>index.js</code> est le point d'entrÃ©e central du JavaScript de notre page
Web. Il importe le paquet npm <code>salut-wasm-pack</code>, qui contient la glu
WebAssembly et JavaScript prÃ©compilÃ©e de <code>wasm-pack-template</code>, et qui ensuite
appelle la fonction <code>saluer</code> de <code>salut-wasm-pack</code>.</p>
<!--
```js
import * as wasm from "hello-wasm-pack";

wasm.greet();
```
-->
<pre><code class="language-js">import * as wasm from &quot;salut-wasm-pack&quot;;

wasm.saluer();
</code></pre>
<!--
### Install the dependencies
-->
<h3><a class="header" href="#installer-les-dÃ©pendances" id="installer-les-dÃ©pendances">Installer les dÃ©pendances</a></h3>
<!--
First, ensure that the local development server and its dependencies are
installed by running `npm install` within the `wasm-game-of-life/www`
subdirectory:
-->
<p>D'abord, il va falloir s'assurer que le serveur de dÃ©veloppement local et ses
dÃ©pendances sont installÃ©es en lanÃ§ant <code>npm install</code> dans le sous-dossier
<code>wasm-jeu-de-la-vie/www</code>Â :</p>
<pre><code class="language-text">npm install
</code></pre>
<!--
This command only needs to be run once, and will install the `webpack`
JavaScript bundler and its development server.
-->
<p>Cette commande n'a besoin d'Ãªtre exÃ©cutÃ©e une seule fois, et va installer le
packageur JavaScript <code>webpack</code> et son serveur de dÃ©veloppement. </p>
<!--
> Note that `webpack` is not required for working with Rust and WebAssembly, it
> is just the bundler and development server we've chosen for convenience
> here. Parcel and Rollup should also support importing WebAssembly as
> ECMAScript modules. You can also use Rust and WebAssembly [without a
> bundler][] if you prefer!
-->
<blockquote>
<p>Notez que <code>webpack</code> n'est pas nÃ©cessaire pour travailler Rust et WebAssembly,
c'est juste le packageur et le serveur de dÃ©veloppement que nous avons choisi
par confort ici. Parcel et Rollup devraient aussi implÃ©menter l'import de
WebAssembly en tant que module ECMAScript. Vous pouvez aussi utiliser Rust et
WebAssembly <a href="https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html">sans packageur</a> si vous le prÃ©fÃ©rezÂ !</p>
</blockquote>
<!--
### Using our Local `wasm-game-of-life` Package in `www`
-->
<h3><a class="header" href="#utiliser-notre-paquet-local-wasm-jeu-de-la-vie-dans-www" id="utiliser-notre-paquet-local-wasm-jeu-de-la-vie-dans-www">Utiliser notre paquet local <code>wasm-jeu-de-la-vie</code> dans <code>www</code></a></h3>
<!--
Rather than use the `hello-wasm-pack` package from npm, we want to use our local
`wasm-game-of-life` package instead. This will allow us to incrementally develop
our Game of Life program.
-->
<p>PlutÃ´t que d'utiliser le paquet <code>hello-wasm-pack</code> provenant de npm, nous voulons
utiliser notre paquet local <code>wasm-jeu-de-la-vie</code>. Cela va nous permettre de
dÃ©velopper de maniÃ¨re incrÃ©mentale notre programme de &quot;Jeu de la vie&quot;.</p>
<!--
Open up `wasm-game-of-life/www/package.json` and next to `"devDependencies"`, add the `"dependencies"` field,
including a `"wasm-game-of-life": "file:../pkg"` entry:
-->
<p>Ouvrez <code>wasm-jeu-de-la-vie/www/package.json</code> et Ã  cÃ´tÃ© de <code>&quot;devDependencies&quot;</code>,
ajoutez le champ <code>&quot;dependencies&quot;</code>, et ajoutez-lui l'entrÃ©e
<code>&quot;wasm-jeu-de-la-vie&quot;: &quot;file:../pkg&quot;</code>Â :</p>
<!--
```js
{
  // ...
  "dependencies": {                     // Add this three lines block!
    "wasm-game-of-life": "file:../pkg"
  },
  "devDependencies": {
    //...
  }
}
```
-->
<pre><code class="language-js">{
  // ...
  &quot;dependencies&quot;: {                     // Ajoutez ce bloc de trois lignesÂ !
    &quot;wasm-jeu-de-la-vie&quot;: &quot;file:../pkg&quot;
  },
  &quot;devDependencies&quot;: {
    //...
  }
}
</code></pre>
<!--
Next, modify `wasm-game-of-life/www/index.js` to import `wasm-game-of-life`
instead of the `hello-wasm-pack` package:
-->
<p>Ensuite, modifiez <code>wasm-jeu-de-la-vie/www/index.js</code> pour importer
<code>wasm-jeu-de-la-vie</code> Ã  la place du paquet <code>salut-wasm-pack</code>Â :</p>
<!--
```js
import * as wasm from "wasm-game-of-life";

wasm.greet();
```
-->
<pre><code class="language-js">import * as wasm from &quot;wasm-jeu-de-la-vie&quot;;

wasm.saluer();
</code></pre>
<!--
Since we declared a new dependency, we need to install it:
```text
npm install
```
-->
<p>Comme nous avons dÃ©clarÃ© une nouvelle dÃ©pendance, nous devons l'installerÂ :</p>
<pre><code class="language-text">npm install
</code></pre>
<!--
Our Web page is now ready to be served locally!
-->
<p>Notre page web est maintenant prÃªte Ã  Ãªtre servie localementÂ !</p>
<!--
## Serving Locally
-->
<h2><a class="header" href="#servir-localement" id="servir-localement">Servir localement</a></h2>
<!--
Next, open a new terminal for the development server. Running the server in a
new terminal lets us leave it running in the background, and doesn't block us
from running other commands in the meantime. In the new terminal, run this
command from within the `wasm-game-of-life/www` directory:
-->
<p>Maintenant, ouvrez un nouveau terminal pour le serveur de dÃ©veloppement.
ExÃ©cuter le serveur dans un nouveau terminal nous permet de l'exÃ©cuter en
arriÃ¨re-plan, et ainsi ne nous empÃªche pas de lancer d'autres commandes en mÃªme
temps. Dans le nouveau terminal, lancez cette commande dans le dossier
<code>wasm-jeu-de-la-vie/www</code>Â :</p>
<pre><code>npm run start
</code></pre>
<!--
Navigate your Web browser to [http://localhost:8080/](http://localhost:8080/)
and you should be greeted with an alert message:
-->
<p>Rendez-vous Ã  l'adresse <a href="http://localhost:8080/">http://localhost:8080/</a> avec
votre navigateur web et vous devriez Ãªtre accueilli par un message
d'avertissementÂ :</p>
<!--
[![Screenshot of the "Hello, wasm-game-of-life!" Web page alert](../images/game-of-life/hello-world.png)](../images/game-of-life/hello-world.png)
-->
<p><a href="game-of-life/images/game-of-life/hello-world.png"><img src="game-of-life/images/game-of-life/hello-world.png" alt="Capture d'Ã©cran de l'alerte &quot;Salut, wasm-jeu-de-la-vieÂ !&quot; sur la page web" /></a></p>
<!--
Anytime you make changes and want them reflected on
[http://localhost:8080/](http://localhost:8080/), just re-run the `wasm-pack
build` command within the `wasm-game-of-life` directory.
-->
<p>A chaque fois que vous allez faire des changements dans le code Rust et que vous
souhaitez les intÃ©grer dans <a href="http://localhost:8080/">http://localhost:8080/</a>,
relancez simplement la commande <code>wasm-pack build</code> dans le dossier
<code>wasm-jeu-de-la-vie</code>.</p>
<!--
## Exercises
-->
<h2><a class="header" href="#exercice" id="exercice">Exercice</a></h2>
<!--
* Modify the `greet` function in `wasm-game-of-life/src/lib.rs` to take a `name:
  &str` parameter that customizes the alerted message, and pass your name to the
  `greet` function from inside `wasm-game-of-life/www/index.js`. Rebuild the
  `.wasm` binary with `wasm-pack build`, then refresh
  [http://localhost:8080/](http://localhost:8080/) in your Web browser and you
  should see a customized greeting!
-->
<ul>
<li>Essayez de modifier la fonction <code>saluer</code> dans <code>wasm-jeu-de-la-vie/src/lib.rs</code>
pour prendre en paramÃ¨tre un <code>nom: &amp;str</code> qui personnalise le message d'alerte,
et passez votre nom Ã  la fonction <code>saluer</code> Ã  l'intÃ©rieur de
<code>wasm-jeu-de-la-vie/www/index.js</code>. Recompilez le binaire <code>.wasm</code> avec
<code>wasm-pack build</code>, et ensuite rafraÃ®chissez
<a href="http://localhost:8080/">http://localhost:8080/</a> dans votre navigateur web, et
vous devrez voir une salutation personnalisÃ©eÂ !</li>
</ul>
<!--
  <details>
    <summary>Answer</summary>

    New version of the `greet` function in `wasm-game-of-life/src/lib.rs`:

    ```rust
    #[wasm_bindgen]
    pub fn greet(name: &str) {
        alert(&format!("Hello, {}!", name));
    }
    ```

    New invocation of `greet` in `wasm-game-of-life/www/index.js`:

    ```js
    wasm.greet("Your Name");
    ```

  </details>
-->
<details>
  <summary>RÃ©ponse</summary>
<p>Nouvelle version de la fonction <code>saluer</code> dans <code>wasm-jeu-de-la-vie/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn saluer(nom: &amp;str) {
    alert(&amp;format!(&quot;Salut, {}Â !&quot;, nom));
}
<span class="boring">}
</span></code></pre></pre>
<p>Nouvelle utilisation de <code>saluer</code> dans <code>wasm-jeu-de-la-vie/www/index.js</code>:</p>
<pre><code class="language-js">wasm.saluer(&quot;votre nom&quot;);
</code></pre>
</details>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--7" id="-attention-peinture-fraÃ®che--7">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Rules of Conway's Game of Life
-->
<h1><a class="header" href="#les-rÃ¨gles-du-jeu-de-la-vie-de-conway" id="les-rÃ¨gles-du-jeu-de-la-vie-de-conway">Les rÃ¨gles du jeu de la vie de Conway</a></h1>
<!--
*Note: If you are already familiar with Conway's Game of Life and its rules,
feel free to skip to the next section!*
-->
<p><em>NoteÂ : si vous connaissez bien les rÃ¨gles du jeu de la vie de Conway, vous
pouvez sauter Ã  la section suivanteÂ !</em></p>
<!--
[Wikipedia gives a great description of the rules of Conway's Game of
Life:][wikipedia]
-->
<p><a href="https://fr.wikipedia.org/wiki/Jeu_de_la_vie">Wikipedia dÃ©crit bien les rÃ¨gles du jeu de la vie de ConwayÂ :</a></p>
<!--
> The universe of the Game of Life is an infinite two-dimensional orthogonal
> grid of square cells, each of which is in one of two possible states, alive or
> dead, or "populated" or "unpopulated". Every cell interacts with its eight
> neighbours, which are the cells that are horizontally, vertically, or
> diagonally adjacent. At each step in time, the following transitions occur:
>
> 1. Any live cell with fewer than two live neighbours dies, as if caused by
>    underpopulation.
>
> 2. Any live cell with two or three live neighbours lives on to the next
>    generation.
>
> 3. Any live cell with more than three live neighbours dies, as if by
>    overpopulation.
>
> 4. Any dead cell with exactly three live neighbours becomes a live cell, as if
>    by reproduction.
>
> The initial pattern constitutes the seed of the system. The first generation
> is created by applying the above rules simultaneously to every cell in the
> seedâ€”births and deaths occur simultaneously, and the discrete moment at which
> this happens is sometimes called a tick (in other words, each generation is a
> pure function of the preceding one). The rules continue to be applied
> repeatedly to create further generations.
-->
<blockquote>
<p>L'univers du jeu de la vie est une grille orthogonale infinie de cellules
carrÃ©es sur deux dimensions, qui ont deux Ã©tats possibles, soit vivante soit
morte. Chaque cellule interagit avec ses 8 cellules voisines, celles qui sont
alignÃ©es verticalement, horizontalement, et en diagonale. A chaque Ã©tape, les
Ã©volutions suivantes se produisentÂ :</p>
<ol>
<li>
<p>Toute cellule vivante avec moins de deux voisines vivantes meurt, comme si
cela Ã©tait un effet de sous-population.</p>
</li>
<li>
<p>Toute cellule vivante avec deux ou trois voisines vivantes survit jusqu'Ã 
la prochaine gÃ©nÃ©ration.</p>
</li>
<li>
<p>Toute cellule vivante avec plus de trois voisines vivantes meurt, comme si
cela Ã©tait un effet de surpopulation.</p>
</li>
<li>
<p>Toute cellule morte avec exactement trois voisines vivantes devient une
cellule vivante, comme si cela Ã©tait un effet de reproduction.</p>
</li>
</ol>
<p>Le dessin initial reprÃ©sente la graine du systÃ¨me. La premiÃ¨re gÃ©nÃ©ration est
crÃ©Ã©e en appliquant simultanÃ©ment les rÃ¨gles prÃ©cÃ©dentes sur chaque cellule de
la graine, ainsi les naissances et les morts se produisent simultanÃ©ment, et
le moment prÃ©cis oÃ¹ cela se produit est parfois appelÃ© un tick (autrement dit,
chaque gÃ©nÃ©ration dÃ©pend purement de la prÃ©cÃ©dente). Les rÃ¨gles continuent Ã 
s'appliquer en boucle pour engendrer les gÃ©nÃ©rations suivantes.</p>
</blockquote>
<!--
[wikipedia]: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life
-->
<!--
Consider the following initial universe:
-->
<p>Imaginons l'univers initial suivantÂ :</p>
<!--
<img src='images/game-of-life/initial-universe.png' alt='Initial Universe' width=80 />
-->
<p><img
  src='images/game-of-life/initial-universe.png'
  alt='Univers initial'
  width=80 /></p>
<!--
We can calculate the next generation by considering each cell. The top left cell
is dead. Rule (4) is the only transition rule that applies to dead
cells. However, because the top left cell does not have exactly three live
neighbors, the transition rule does not apply, and it remains dead in the next
generation. The same goes for every other cell in the first row as well.
-->
<p>Nous pouvons calculer la prochaine gÃ©nÃ©ration en analysant chaque cellule. La
cellule d'en haut Ã  gauche est morte. La rÃ¨gle (4) est la seule rÃ¨gle
d'Ã©volution qui s'applique aux cellules mortes. Cependant, comme la cellule
d'en haut Ã  gauche n'a pas exactement trois voisines vivantes, la rÃ¨gle
d'Ã©volution ne peut pas s'appliquer, et elle reste morte Ã  la prochaine
gÃ©nÃ©ration. C'est aussi ce qui se passe pour les autres cellules dans la
premiÃ¨re ligne.</p>
<!--
Things get interesting when we consider the top live cell, in the second row,
third column. For live cells, any of the first three rules potentially
applies. In this cell's case, it has only one live neighbor, and therefore rule
(1) applies: this cell will die in the next generation. The same fate awaits the
bottom live cell.
-->
<p>Les choses deviennent intÃ©ressantes lorsque nous analysons la premiÃ¨re cellule
vivante en haut, dans la deuxiÃ¨me ligne et troisiÃ¨me colonne. Pour les cellules
vivantes, les trois premiÃ¨res rÃ¨gles peuvent potentiellement s'appliquer. Dans
le cas de cette cellule, elle n'a qu'une seule voisine vivante, ce qui fait que
la rÃ¨gle (1) s'appliqueÂ : cette cellule va mourir Ã  la prochaine gÃ©nÃ©ration. Le
mÃªme destin va se produire pour la cellule vivante d'en bas.</p>
<!--
The middle live cell has two live neighbors: the top and bottom live cells. This
means that rule (2) applies, and it remains live in the next generation.
-->
<p>La cellule du milieu a deux voisines vivantesÂ : les cellules du haut et du bas.
Cela signifie que la rÃ¨gle (2) s'applique, et donc elle reste vivante Ã  la
prochaine gÃ©nÃ©ration.</p>
<!--
The final interesting cases are the dead cells just to the left and right of the
middle live cell. The three live cells are all neighbors both of these cells,
which means that rule (4) applies, and these cells will become alive in the next
generation.
-->
<p>Les derniers cas intÃ©ressants concernent les cellules mortes Ã  la gauche et la
droite de la cellule vivante du milieu. Les trois cellules vivantes sont toutes
des voisines de ces deux cellules, ce qui signifie que la rÃ¨gle (4) s'applique,
et que ces cellules vont naÃ®tre et Ãªtre vivantes Ã  la prochaine gÃ©nÃ©ration.</p>
<!--
Put it all together, and we get this universe after the next tick:
-->
<p>Une fois toutes ces conditions assemblÃ©es, nous obtenons l'univers suivant aprÃ¨s
le prochain tickÂ :</p>
<!--
<img src='images/game-of-life/next-universe.png' alt='Next Universe' width=80 />
-->
<p><img
  src='images/game-of-life/next-universe.png'
  alt="L'univers suivant"
  width=80 /></p>
<!--
From these simple, deterministic rules, strange and exciting behavior emerges:
-->
<p>Un comportement intÃ©ressant et Ã©trange Ã©merge de ces rÃ¨gles simples et
dÃ©terministesÂ :</p>
<!--
| Gosper's glider gun | Pulsar | Space ship |
|---|---|---|
| ![Gosper's glider gun](https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif) | ![Pulsar](https://upload.wikimedia.org/wikipedia/commons/0/07/Game_of_life_pulsar.gif) | ![Lighweight space ship](https://upload.wikimedia.org/wikipedia/commons/3/37/Game_of_life_animated_LWSS.gif) |
-->
<table><thead><tr><th>Le canon Ã  planeurs de Gosper</th><th>Un pulsar</th><th>Un vaisseau spatial</th></tr></thead><tbody>
<tr><td><img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif" alt="Le canon Ã  planeurs de Gosper" /></td><td><img src="https://upload.wikimedia.org/wikipedia/commons/0/07/Game_of_life_pulsar.gif" alt="Un pulsar" /></td><td><img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Game_of_life_animated_LWSS.gif" alt="Un petit vaisseau spatial" /></td></tr>
</tbody></table>
<!--
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/C2vgICfQawE?rel=0&amp;start=65" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</center>
-->
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Gbvy6gY5Ev4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>
<!--
## Exercises
-->
<h2><a class="header" href="#exercices" id="exercices">Exercices</a></h2>
<!--
* Compute by hand the next tick of our example universe. Notice anything
  familiar?
-->
<ul>
<li>Calculez Ã  la main la prochaine tick de notre univers d'exemple. Est-ce que
vous ne remarquez pas quelque choseÂ ?</li>
</ul>
<!--
  <details>
    <summary>Answer</summary>

    It should be the initial state of the example universe:

    <img src='images/game-of-life/initial-universe.png' alt='Initial Universe' width=80 />

    This pattern is *periodic*: it returns to the initial state after every two
    ticks.

  </details>
-->
<details>
  <summary>RÃ©ponse</summary>
<p>Vous devriez retrouver l'Ã©tat initial de l'univers de l'exempleÂ :</p>
<p><img
    src='images/game-of-life/initial-universe.png'
    alt='Univers initial'
    width=80 /></p>
<p>Ce schÃ©ma est <em>pÃ©riodique</em>Â : il retourne Ã  son Ã©tat initial tous les deux
ticks.</p>
</details>
<!--
* Can you find an initial universe that is stable? That is, a universe in which
  every generation is always the same.
-->
<ul>
<li>Pouvez-vous trouver un univers initial qui est stableÂ ? Cela dÃ©signe un
univers dont chaque gÃ©nÃ©ration est toujours la mÃªme.</li>
</ul>
<!--
  <details>
    <summary>Answer</summary>

    There are an infinite number of stable universes! The trivially stable
    universe is the empty universe. A two-by-two square of live cells is also a
    stable universe.

  </details>
-->
<details>
  <summary>RÃ©ponse</summary>
<p>Il y a un nombre infini d'univers stablesÂ ! L'univers stable le plus trivial
est l'univers qui est vide. Un carrÃ© de deux cellules de large et de deux
cellules de haut est aussi un univers stable.</p>
</details>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--8" id="-attention-peinture-fraÃ®che--8">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Implementing Conway's Game of Life
-->
<h1><a class="header" href="#implÃ©menter-le-jeu-de-la-vie-de-conway" id="implÃ©menter-le-jeu-de-la-vie-de-conway">ImplÃ©menter le jeu de la vie de Conway</a></h1>
<!--
## Design
-->
<h2><a class="header" href="#conception" id="conception">Conception</a></h2>
<!--
Before we dive in, we have some design choices to consider.
-->
<p>Avant de nous plonger dans le sujet, nous devons prendre en considÃ©ration
quelques choix de conception.</p>
<!--
### Infinite Universe
-->
<h3><a class="header" href="#un-univers-infini" id="un-univers-infini">Un univers infini</a></h3>
<!--
The Game of Life is played in an infinite universe, but we do not have infinite
memory and compute power. Working around this rather annoying limitation usually
comes in one of three flavors:
-->
<p>Le jeu de la vie se dÃ©roule dans un univers infini, mais nous n'avons pas une
mÃ©moire et une puissance de calcul infinie. Pour contourner cette limitation
plutÃ´t ennuyeuse, il a gÃ©nÃ©ralement trois possibilitÃ©sÂ :</p>
<!--
1. Keep track of which subset of the universe has interesting things happening,
   and expand this region as needed. In the worst case, this expansion is
   unbounded and the implementation will get slower and slower and eventually
   run out of memory.
-->
<ol>
<li>Identifier dans quel sous-ensemble de l'univers il se passe des choses
intÃ©ressantes, et agrandir cette zone si nÃ©cessaire. Dans le pire des cas,
cette expansion se fera sans limites et donc la simulation deviendra de plus
en plus lent et arrivera Ã  cours de mÃ©moire.</li>
</ol>
<!--
2. Create a fixed-size universe, where cells on the edges have fewer neighbors
   than cells in the middle. The downside with this approach is that infinite
   patterns, like gliders, that reach the end of the universe are snuffed out.
-->
<ol start="2">
<li>CrÃ©er un univers Ã  taille fixe, dans lequel les cellules sur ses bords auront
moins de voisines que les cellules au centre. Le dÃ©savantage de cette
approche est que les schÃ©mas infinis, comme les planeurs, qui atteignent
probablement la fin de l'univers, seront Ã©liminÃ©s.</li>
</ol>
<!--
3. Create a fixed-size, periodic universe, where cells on the edges have
   neighbors that wrap around to the other side of the universe. Because
   neighbors wrap around the edges of the universe, gliders can keep running
   forever.
-->
<ol start="3">
<li>CrÃ©er un univers Ã  taille fixe, mais en boucle, oÃ¹ les cellules sur les bords
seront directement voisines de celles qui sont de l'autre cÃ´tÃ© de l'univers.
Comme les voisines de recoupent d'un bout Ã  l'autre de l'univers, les
planeurs pourront continuer Ã  vivre Ã  l'infini.</li>
</ol>
<!--
We will implement the third option.
-->
<p>Nous allons implÃ©menter la troisiÃ¨me option.</p>
<!--
### Interfacing Rust and JavaScript
-->
<h3><a class="header" href="#interfacer-rust-et-le-javascript" id="interfacer-rust-et-le-javascript">Interfacer Rust et le JavaScript</a></h3>
<!--
> âš¡ This is one of the most important concepts to understand and take away from
> this tutorial!
-->
<blockquote>
<p>âš¡ C'est l'un des concepts les plus importants Ã  comprendre et Ã  retenir de ce
tutorielÂ !</p>
</blockquote>
<!--
JavaScript's garbage-collected heap â€” where `Object`s, `Array`s, and DOM nodes
are allocated â€” is distinct from WebAssembly's linear memory space, where our
Rust values live. WebAssembly currently has no direct access to the
garbage-collected heap (as of April 2018, this is expected to change with the
["Interface Types" proposal][interface-types]). JavaScript, on the other hand, can
read and write to the WebAssembly linear memory space, but only as an
[`ArrayBuffer`][array-buf] of scalar values (`u8`, `i32`, `f64`,
etc...). WebAssembly functions also take and return scalar values. These are the
building blocks from which all WebAssembly and JavaScript communication is
constituted.
-->
<p>Le <em>tas</em> du JavaScript qui est gÃ©rÃ© par le ramasse-miettes â€” dans lequel sont
stockÃ©s les objets <code>Object</code>, les tableaux <code>Array</code>, et les noeuds du DOM â€” se
distingue de l'espace mÃ©moire linÃ©aire du WebAssembly, dans lequel vivent nos
valeurs Rust. WebAssembly n'a actuellement pas d'accÃ¨s direct au tas gÃ©rÃ© par le
ramasse-miettes (du moins en avril 2018, cela peut changer Ã  l'avenir avec la
<a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md">proposition des &quot;Interface Types&quot;</a>). JavaScript, de l'autre
cÃ´tÃ©, peut lire et Ã©crire sur l'espace mÃ©moire linÃ©aire de WebAssembly, mais
seulement via un <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> de valeurs scalaires (comme le <code>u8</code>,
<code>i32</code>, <code>f64</code>, etc ...). Les fonctions WebAssembly prennent elles aussi des
valeurs scalaires et en retourne. Ce sont les Ã©lÃ©ments de base sur lesquels
repose la communication entre WebAssembly et JavaScript.</p>
<!--
[interface-types]: https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md
[array-buf]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer
-->
<!--
`wasm_bindgen` defines a common understanding of how to work with compound
structures across this boundary. It involves boxing Rust structures, and
wrapping the pointer in a JavaScript class for usability, or indexing into a
table of JavaScript objects from Rust. `wasm_bindgen` is very convenient, but it
does not remove the need to consider our data representation, and what values
and structures are passed across this boundary. Instead, think of it as a tool
for implementing the interface design you choose.
-->
<p><code>wasm_bindgen</code> dÃ©finit une vision partagÃ©e pour travailler avec des structures
composÃ©es pour passer outre ces limites. Cette crate passe une structure Rust
dans une <code>std::boxed::Box</code> et enveloppe ce pointeur dans une classe JavaScript
pour faciliter son utilisation, ou utilise des indices dans une table d'objets
dans Rust qui reprÃ©sentent des objets JavaScript. <code>wasm_bindgen</code> est trÃ¨s utile,
mais nous devons toujours garder en tÃªte comment les donnÃ©es sont modÃ©lisÃ©es, et
quelles sont les valeurs et les structures qui passent entre ces deux domaines.
ConsidÃ©rez-la plutÃ´t comme un outil permettant de choisir votre moyen pour
s'interfacer.</p>
<!--
When designing an interface between WebAssembly and JavaScript, we want to
optimize for the following properties:
-->
<p>Lorsqu'on conÃ§oit une interface entre WebAssembly et JavaScript, nous voulons
optimiser les propriÃ©tÃ©s suivantesÂ :</p>
<!--
1. **Minimizing copying into and out of the WebAssembly linear memory.**
   Unnecessary copies impose unnecessary overhead.
-->
<ol>
<li><strong>RÃ©duire au maximum les copies de donnÃ©es sur et Ã  partir de la mÃ©moire
linÃ©aire de WebAssembly.</strong>
Les copies inutiles provoquent des surcharges inutiles.</li>
</ol>
<!--
2. **Minimizing serializing and deserializing.** Similar to copies, serializing
   and deserializing also imposes overhead, and often imposes copying as
   well. If we can pass opaque handles to a data structure â€” instead of
   serializing it on one side, copying it into some known location in the
   WebAssembly linear memory, and deserializing on the other side â€” we can often
   reduce a lot of overhead. `wasm_bindgen` helps us define and work with opaque
   handles to JavaScript `Object`s or boxed Rust structures.
-->
<ol start="2">
<li><strong>Minimiser les sÃ©rialisations et les dÃ©serialisations.</strong> Pour la mÃªme raison
que pour les copies, les sÃ©rialisations et la dÃ©serialisations provoquent des
surcharges, et impose parfois aussi des copies, en plus. Si nous pouvons
utiliser des manipulateurs opaques pour une structure de donnÃ©es, plutÃ´t que
d'avoir Ã  la sÃ©rialiser d'un cÃ´tÃ©, de la copier dans un endroit connu dans la
mÃ©moire linÃ©aire de WebAssembly, et la dÃ©serialiser de l'autre cÃ´tÃ©, alors
trÃ¨s souvent on Ã©conomise beaucoup de ressources. <code>wasm_bindgen</code> nous aide Ã 
dÃ©finir et travailler avec des manipulateurs opaques d'objets JavaScript ou
de structures Rust intÃ©grÃ©es dans des <code>Box</code>.</li>
</ol>
<!--
As a general rule of thumb, a good JavaScriptâ†”WebAssembly interface design is
often one where large, long-lived data structures are implemented as Rust types
that live in the WebAssembly linear memory, and are exposed to JavaScript as
opaque handles. JavaScript calls exported WebAssembly functions that take these
opaque handles, transform their data, perform heavy computations, query the
data, and ultimately return a small, copy-able result. By only returning the
small result of the computation, we avoid copying and/or serializing everything
back and forth between the JavaScript garbage-collected heap and the WebAssembly
linear memory.
-->
<p>En rÃ¨gle gÃ©nÃ©rale, une bonne conception d'interface JavaScriptâ†”WebAssembly
nÃ©cessite souvent que les grosses structures de donnÃ©es Ã  durÃ©e de vie longue
soient implÃ©mentÃ©es comme Ã©tant des types Rust qui vivent dans la mÃ©moire
linÃ©aire de WebAssembly, et soient utilisÃ©es en JavaScript via des manipulateurs
opaques. Le JavaScript appelle les fonctions WebAssembly exportÃ©es qui prennent
en argument ces manipulateurs opaques, transforment leurs donnÃ©es, procÃ¨dent Ã 
des calculs lourds, consultent les donnÃ©es, et retournent finalement un petit
rÃ©sultat copiable. En retournant uniquement un petit rÃ©sultat de l'opÃ©ration,
nous Ã©vitons de copier et/ou de tout sÃ©rialiser tout ce qui transite entre le
tas gÃ©rÃ© par le ramasse-miettes de JavaScript et la mÃ©moire linÃ©aire de
WebAssembly.</p>
<!--
### Interfacing Rust and JavaScript in our Game of Life
-->
<h3><a class="header" href="#interfacer-rust-et-javascript-dans-notre-jeu-de-la-vie" id="interfacer-rust-et-javascript-dans-notre-jeu-de-la-vie">Interfacer Rust et JavaScript dans notre jeu de la vie</a></h3>
<!--
Let's start by enumerating some hazards to avoid. We don't want to copy the
whole universe into and out of the WebAssembly linear memory on every tick. We
do not want to allocate objects for every cell in the universe, nor do we want
to impose a cross-boundary call to read and write each cell.
-->
<p>CommenÃ§ons par Ã©voquer les piÃ¨ges Ã  Ã©viter. Nous ne devons pas copier tout
l'univers Ã  l'intÃ©rieur et Ã  partir de la mÃ©moire linÃ©aire de WebAssembly Ã 
chaque tick. Nous ne devons pas allouer des objets pour chaque cellule dans
l'univers, ni faire des appels transversaux entre les deux domaines pour lire et
Ã©crire chaque cellule.</p>
<!--
Where does this leave us? We can represent the universe as a flat array that
lives in the WebAssembly linear memory, and has a byte for each cell. `0` is a
dead cell and `1` is a live cell.
-->
<p>Qu'est-ce que tout cela impliqueÂ ? Que nous pouvons reprÃ©senter l'univers comme
un tableau Ã  une dimension qui vit dans la mÃ©moire linÃ©aire de WebAssembly, et
qui a un octet pour chaque cellule. <code>0</code> modÃ©lisera une cellule morte, et <code>1</code>
sera une cellule vivante.</p>
<!--
Here is what a 4 by 4 universe looks like in memory:
-->
<p>Voici Ã  quoi ressemble un univers de 4 par 4 dans la mÃ©moireÂ :</p>
<!--
![Screenshot of a 4 by 4 universe](../images/game-of-life/universe.png)
-->
<p><img src="game-of-life/images/game-of-life/universe.png" alt="Capture d'Ã©cran d'un univers 4 par 4" /></p>
<!--
To find the array index of the cell at a given row and column in the universe,
we can use this formula:
-->
<p>Pour trouver l'indice d'une cellule dans le tableau Ã  partir d'une ligne et
d'une colonne, nous pouvons utiliser cette formuleÂ :</p>
<!--
```text
index(row, column, universe) = row * width(universe) + column
```
-->
<pre><code class="language-text">indice(ligne, colonne, univers) = ligne * largeur(univers) + colonne
</code></pre>
<!--
We have several ways of exposing the universe's cells to JavaScript. To begin,
we will implement [`std::fmt::Display`][`Display`] for `Universe`, which we can
use to generate a Rust `String` of the cells rendered as text characters. This
Rust String is then copied from the WebAssembly linear memory into a JavaScript
String in the JavaScript's garbage-collected heap, and is then displayed by
setting HTML `textContent`. Later in the chapter, we'll evolve this
implementation to avoid copying the universe's cells between heaps and to render
to `<canvas>`.
-->
<p>Nous pouvons exposer les cellules de l'univers au JavaScript de diffÃ©rentes
maniÃ¨res. Pour commencer, nous allons implÃ©menter
<a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>std::fmt::Display</code></a> sur <code>Univers</code>, qui nous permettra de gÃ©nÃ©rer
une <code>String</code> en Rust des cellules qui reprÃ©sentera les cellules avec des
caractÃ¨res. Cette chaÃ®ne de caractÃ¨res Rust est ensuite copiÃ©e Ã  partir de la
mÃ©moire linÃ©aire de WebAssembly dans une chaÃ®ne de caractÃ¨res en JavaScript,
stockÃ©e dans le tas gÃ©rÃ© par le ramasse-miettes de JavaScript, et est ensuite
affichÃ©e dans l'Ã©lÃ©ment HTML <code>contenuTextuel</code>. Plus tard dans ce chapitre, nous
allons faire Ã©voluer cette implÃ©mentation pour Ã©viter de copier les cellules de
l'univers entre les tas et les intÃ©grer dans un <code>&lt;canvas&gt;</code>.</p>
<!--
*Another viable design alternative would be for Rust to return a list of every
cell that changed states after each tick, instead of exposing the whole universe
to JavaScript. This way, JavaScript wouldn't need to iterate over the whole
universe when rendering, only the relevant subset. The trade off is that this
delta-based design is slightly more difficult to implement.*
-->
<p><em>Une autre conception alternative acceptable serait que Rust retourne une liste
de toutes les cellules qui changent d'Ã©tat aprÃ¨s chaque tick, au lieu de donner
l'intÃ©gralitÃ© de l'univers au JavaScript. Ainsi, JavaScript n'aurait pas besoin
d'itÃ©rer sur tout l'univers lorsqu'il s'occupe du rendu, mais uniquement sur le
sous-ensemble concernÃ©. Le dÃ©savantage est que cette conception basÃ©e sur les
diffÃ©rences et un peu plus difficile Ã  implÃ©menter.</em></p>
<!--
## Rust Implementation
-->
<h2><a class="header" href="#implÃ©mentation-de-rust" id="implÃ©mentation-de-rust">ImplÃ©mentation de Rust</a></h2>
<!--
In the last chapter, we cloned an initial project template. We will modify that
project template now.
-->
<p>Dans le dernier chapitre, nous avons clonÃ© un modÃ¨le initial de projet. Nous
allons maintenant modifier ce projet.</p>
<!--
Let's begin by removing the `alert` import and `greet` function from
`wasm-game-of-life/src/lib.rs`, and replacing them with a type definition for
cells:
-->
<p>CommenÃ§ons par enlever l'import de <code>alert</code> et la fonction <code>saluer</code> dans
<code>wasm-jeu-de-la-vie/src/lib.rs</code>, et remplacons-les par une dÃ©finition d'un type
pour les cellulesÂ :</p>
<!--
```rust
#[wasm_bindgen]
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1,
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cellule {
    Morte = 0,
    Vivante = 1,
}
<span class="boring">}
</span></code></pre></pre>
<!--
It is important that we have `#[repr(u8)]`, so that each cell is represented as
a single byte. It is also important that the `Dead` variant is `0` and that the
`Alive` variant is `1`, so that we can easily count a cell's live neighbors with
addition.
-->
<p>Il est important d'avoir <code>#[repr(u8)]</code> pour que chaque cellule soit reprÃ©sentÃ©e
par un seul octet. Il est aussi important que la variante <code>Morte</code> soit <code>0</code> et
que la variante <code>Vivante</code> vaut <code>1</code>, afin que nous puissions facilement compter
les voisines vivantes d'une cellule en les additionnant.</p>
<!--
Next, let's define the universe. The universe has a width and a height, and a
vector of cells of length `width * height`.
-->
<p>Ensuite, dÃ©finissons l'univers. L'univers a une largeur et une hauteur, et a un
vecteur de cellules qui a une taille de <code>largeur * hauteur</code>.</p>
<!--
```rust
#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec<Cell>,
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub struct Univers {
    largeur: u32,
    hauteur: u32,
    cellules: Vec&lt;Cellule&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<!--
To access the cell at a given row and column, we translate the row and column
into an index into the cells vector, as described earlier:
-->
<p>Pour accÃ©der Ã  la cellule Ã  une ligne et colonne donnÃ©e, nous calculons
l'emplacement dans le vecteur de cellules avec la ligne et la colonne comme nous
l'avons dÃ©crit prÃ©cÃ©demmentÂ :</p>
<!--
```rust
impl Universe {
    fn get_index(&self, row: u32, column: u32) -> usize {
        (row * self.width + column) as usize
    }

    // ...
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Univers {
    fn calculer_indice(&amp;self, ligne: u32, colonne: u32) -&gt; usize {
        (ligne * self.largeur + colonne) as usize
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<!--
In order to calculate the next state of a cell, we need to get a count of how
many of its neighbors are alive. Let's write a `live_neighbor_count` method to
do just that!
-->
<p>Pour calculer le prochain Ã©tat d'une cellule, nous devons compter combien de
cellules sont vivantes dans son voisinage. Ecrivons donc une mÃ©thode
<code>compter_voisines_vivantes</code> pour celaÂ !</p>
<!--
```rust
impl Universe {
    // ...

    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {
        let mut count = 0;
        for delta_row in [self.height - 1, 0, 1].iter().cloned() {
            for delta_col in [self.width - 1, 0, 1].iter().cloned() {
                if delta_row == 0 && delta_col == 0 {
                    continue;
                }

                let neighbor_row = (row + delta_row) % self.height;
                let neighbor_col = (column + delta_col) % self.width;
                let idx = self.get_index(neighbor_row, neighbor_col);
                count += self.cells[idx] as u8;
            }
        }
        count
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    // ...

    fn compter_voisines_vivantes(&amp;self, ligne: u32, colonne: u32) -&gt; u8 {
        let mut compteur = 0;
        for delta_ligne in [self.hauteur - 1, 0, 1].iter().cloned() {
            for delta_colonne in [self.largeur - 1, 0, 1].iter().cloned() {
                if delta_ligne == 0 &amp;&amp; delta_colonne == 0 {
                    continue;
                }

                let ligne_voisine = (ligne + delta_ligne) % self.hauteur;
                let colonne_voisine = (colonne + delta_colonne) % self.largeur;
                let indice = self.calculer_indice(ligne_voisine, colonne_voisine);
                compteur += self.cellules[indice] as u8;
            }
        }
        compteur
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `live_neighbor_count` method uses deltas and modulo to avoid special casing
the edges of the universe with `if`s. When applying a delta of `-1`, we *add*
`self.height - 1` and let the modulo do its thing, rather than attempting to
subtract `1`. `row` and `column` can be `0`, and if we attempted to subtract `1`
from them, there would be an unsigned integer underflow.
-->
<p>La mÃ©thode <code>compter_voisines_vivantes</code> utilise les deltas et les modulos pour
Ã©viter de traiter les cas particuliers des bords de l'univers avec le <code>if</code>.
Lorsqu'on applique un delta de <code>-1</code>, nous <em>ajoutons</em> <code>self.hauteur - 1</code> et nous
laissons le modulo faire son travail, plutÃ´t que d'essayer d'enlever <code>1</code>.
<code>ligne</code> ou <code>colonne</code> peut valoir <code>0</code>, et si nous essayons de leur soustraire
<code>1</code>, nous serons alors en dehors des valeurs acceptÃ©es par les entiers
non-signÃ©s.</p>
<!--
Now we have everything we need to compute the next generation from the current
one! Each of the Game's rules follows a straightforward translation into a
condition on a `match` expression. Additionally, because we want JavaScript to
control when ticks happen, we will put this method inside a `#[wasm_bindgen]`
block, so that it gets exposed to JavaScript.
-->
<p>Maintenant, nous avons tout ce dont nous avons besoin pour calculer la prochaine
gÃ©nÃ©rationÂ ! Chaque rÃ¨gle du jeu suit des transformations simples suivant des
conditions qui peuvent tenir dans une expression <code>match</code>. De plus, comme nous
souhaitons que le JavaScript contrÃ´le lorsque les ticks se produisent, nous
allons intÃ©grer cette mÃ©thode dans un bloc <code>#[wasm_bindgen]</code>, pour qu'il soit
exposÃ© au JavaScript.</p>
<!--
```rust
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    pub fn tick(&mut self) {
        let mut next = self.cells.clone();

        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x < 2 => Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x > 3 => Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) => Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) => otherwise,
                };

                next[idx] = next_cell;
            }
        }

        self.cells = next;
    }

    // ...
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// MÃ©thodes publiques, exportÃ©es en JavaScript.
#[wasm_bindgen]
impl Univers {
    pub fn tick(&amp;mut self) {
        let mut generation_suivante = self.cellules.clone();

        for ligne in 0..self.hauteur {
            for colonne in 0..self.largeur {
                let indice = self.calculer_indice(ligne, colonne);
                let cellule = self.cellules[indice];
                let voisines_vivantes = self.compter_voisines_vivantes(ligne, colonne);

                let prochain_etat = match (cellule, voisines_vivantes) {
                    // RÃ¨gle 1Â : toute cellule vivante avec moins de deux
                    // voisines vivantes meurt, comme si cela Ã©tait un effet de
                    //  sous-population.
                    (Cellule::Vivante, x) if x &lt; 2 =&gt; Cellule::Morte,
                    // RÃ¨gle 2Â : toute cellule vivante avec deux ou trois
                    // voisines vivantes survit jusqu'Ã  la prochaine gÃ©nÃ©ration.
                    (Cellule::Vivante, 2) | (Cellule::Vivante, 3) =&gt; Cellule::Vivante,
                    // RÃ¨gle 3Â : toute cellule vivante avec plus de trois
                    // voisines vivantes meurt, comme si cela Ã©tait un effet de
                    // surpopulation.
                    (Cellule::Vivante, x) if x &gt; 3 =&gt; Cellule::Morte,
                    // RÃ¨gle 4Â : toute cellule morte avec exactement trois
                    // voisines vivantes devient une cellule vivante, comme si
                    // cela Ã©tait un effet de reproduction.
                    (Cellule::Morte, 3) =&gt; Cellule::Vivante,
                    // Les cellules qui ne rÃ©pondent Ã  aucune de ces conditions
                    // restent dans le mÃªme Ã©tat.
                    (statut, _) =&gt; statut,
                };

                generation_suivante[idx] = prochain_etat;
            }
        }

        self.cellules = generation_suivante;
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<!--
So far, the state of the universe is represented as a vector of cells. To make
this human readable, let's implement a basic text renderer. The idea is to write
the universe line by line as text, and for each cell that is alive, print the
Unicode character `â—¼` ("black medium square"). For dead cells, we'll print `â—»`
(a "white medium square").
-->
<p>Pour l'instant, l'Ã©tat de l'univers est modÃ©lisÃ© par un vecteur de cellules.
Pour rendre cela lisible pour un humain, implÃ©mentons un rendu textuel basique.
L'idÃ©e est d'Ã©crire l'univers ligne par ligne textuellement, ainsi nous allons
Ã©crire le caractÃ¨re Unicode <code>â—¼</code> (le &quot;carrÃ© moyen noir&quot;) pour chaque cellule
vivante. Et pour les cellules mortes, nous allons Ã©crire <code>â—»</code> (le &quot;carrÃ© moyen
blanc&quot;).</p>
<!--
By implementing the [`Display`] trait from Rust's standard library, we can add a
way to format a structure in a user-facing manner. This will also automatically
give us a [`to_string`] method.
-->
<p>En implÃ©mentant le trait <a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>Display</code></a> de la bibliothÃ¨que standard de Rust, nous
pouvons ajouter un moyen de formater la structure de maniÃ¨re Ã  ce qu'elle soit
adaptÃ©e pour l'utilisateur. Cela va aussi nous fournir automatiquement une
mÃ©thode <a href="https://doc.rust-lang.org/1.25.0/std/string/trait.ToString.html"><code>to_string</code></a>.</p>
<!--
[`Display`]: https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html
[`to_string`]: https://doc.rust-lang.org/1.25.0/std/string/trait.ToString.html
-->
<!--
```rust
use std::fmt;

impl fmt::Display for Universe {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for line in self.cells.as_slice().chunks(self.width as usize) {
            for &cell in line {
                let symbol = if cell == Cell::Dead { 'â—»' } else { 'â—¼' };
                write!(f, "{}", symbol)?;
            }
            write!(f, "\n")?;
        }

        Ok(())
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

impl fmt::Display for Univers {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        for ligne in self.cellules.as_slice().chunks(self.largeur as usize) {
            for &amp;cellules in ligne {
                let symbole = if cellule == Cellule::Morte { 'â—»' } else { 'â—¼' };
                write!(f, &quot;{}&quot;, symbole)?;
            }
            write!(f, &quot;\n&quot;)?;
        }

        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Finally, we define a constructor that initializes the universe with an
interesting pattern of live and dead cells, as well as a `render` method:
-->
<p>Enfin, nous dÃ©finissons un constructeur qui initialise l'univers avec un schÃ©ma
intÃ©ressant avec des cellules vivantes et mortes, ainsi qu'une mÃ©thode <code>rendu</code>Â :</p>
<!--
```rust
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn new() -> Universe {
        let width = 64;
        let height = 64;

        let cells = (0..width * height)
            .map(|i| {
                if i % 2 == 0 || i % 7 == 0 {
                    Cell::Alive
                } else {
                    Cell::Dead
                }
            })
            .collect();

        Universe {
            width,
            height,
            cells,
        }
    }

    pub fn render(&self) -> String {
        self.to_string()
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// MÃ©thodes publiques, exportÃ©es en JavaScript.
#[wasm_bindgen]
impl Univers {
    // ...

    pub fn new() -&gt; Univers {
        let largeur = 64;
        let hauteur = 64;

        let cellules = (0..largeur * hauteur)
            .map(|i| {
                if i % 2 == 0 || i % 7 == 0 {
                    Cellule::Vivante
                } else {
                    Cellule::Morte
                }
            })
            .collect();

        Univers {
            largeur,
            hauteur,
            cellules,
        }
    }

    pub fn rendu(&amp;self) -&gt; String {
        self.to_string()
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
With that, the Rust half of our Game of Life implementation is complete!
-->
<p>Avec tout cela, la partie Rust de notre jeu de la vie est complÃ¨teÂ !</p>
<!--
Recompile it to WebAssembly by running `wasm-pack build` within the
`wasm-game-of-life` directory.
-->
<p>Recompilez-la en WebAssembly en lanÃ§ant <code>wasm-pack build</code> dans le dossier
<code>wasm-jeu-de-la-vie</code>.</p>
<!--
## Rendering with JavaScript
-->
<h2><a class="header" href="#le-rendu-avec-javascript" id="le-rendu-avec-javascript">Le rendu avec JavaScript</a></h2>
<!--
First, let's add a `<pre>` element to `wasm-game-of-life/www/index.html` to
render the universe into, just above the `<script>` tag:
-->
<p>Pour commencer, ajoutons une balise <code>&lt;pre&gt;</code> Ã 
<code>wasm-jeu-de-la-vie/www/index.html</code>, dans lequel afficher l'univers, juste avant
la balise <code>&lt;script&gt;</code>Â :</p>
<!--
```html
<body>
  <pre id="game-of-life-canvas"></pre>
  <script src="./bootstrap.js"></script>
</body>
```
-->
<pre><code class="language-html">&lt;body&gt;
  &lt;pre id=&quot;canvas-jeu-de-la-vie&quot;&gt;&lt;/pre&gt;
  &lt;script src=&quot;./bootstrap.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<!--
Additionally, we want the `<pre>` centered in the middle of the Web page. We can
use CSS flex boxes to accomplish this task. Add the following `<style>` tag
inside `wasm-game-of-life/www/index.html`'s `<head>`:
-->
<p>De plus, nous voulons que le <code>&lt;pre&gt;</code> soit centrÃ© au milieu de la page Web. Nous
pouvons utiliser les boites flex pour faire cela. Ajoutez la balise <code>&lt;style&gt;</code>
suivante dans le <code>&lt;head&gt;</code> de <code>wasm-jeu-de-la-vie/www/index.html</code>Â :</p>
<!--
```html
<style>
  body {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
</style>
```
-->
<pre><code class="language-html">&lt;style&gt;
  body {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
&lt;/style&gt;
</code></pre>
<!--
At the top of `wasm-game-of-life/www/index.js`, let's fix our import to bring in
the `Universe` rather than the old `greet` function:
-->
<p>En haut de <code>wasm-jeu-de-la-vie/www/index.js</code>, corrigeons notre import pour
importer le <code>Univers</code> plutÃ´t que la vieille fonction <code>saluer</code>Â :</p>
<!--
```js
import { Universe } from "wasm-game-of-life";
```
-->
<pre><code class="language-js">import { Univers } from &quot;wasm-jeu-de-la-vie&quot;;
</code></pre>
<!--
Also, let's get that `<pre>` element we just added and instantiate a new
universe:
-->
<p>Ensuite, obtenez la balise <code>&lt;pre&gt;</code> que nous venons juste d'ajouter et instancier
un nouvel universÂ :</p>
<!--
```js
const pre = document.getElementById("game-of-life-canvas");
const universe = Universe.new();
```
-->
<pre><code class="language-js">const pre = document.getElementById(&quot;canvas-jeu-de-la-vie&quot;);
const univers = Univers.new();
</code></pre>
<!--
The JavaScript runs in [a `requestAnimationFrame`
loop][requestAnimationFrame]. On each iteration, it draws the current universe
to the `<pre>`, and then calls `Universe::tick`.
-->
<p>Le JavaScript exÃ©cute dans <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">une boucle
<code>requestAnimationFrame</code></a>. A chaque itÃ©ration, il Ã©crit
l'univers courant dans le <code>&lt;pre&gt;</code>, et fait ensuite appel Ã  <code>Univers::tick</code>.</p>
<!--
[requestAnimationFrame]: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
-->
<!--
```js
const renderLoop = () => {
  pre.textContent = universe.render();
  universe.tick();

  requestAnimationFrame(renderLoop);
};
```
-->
<pre><code class="language-js">const boucleDeRendu = () =&gt; {
  pre.textContent = univers.rendu();
  univers.tick();

  requestAnimationFrame(boucleDeRendu);
};
</code></pre>
<!--
To start the rendering process, all we have to do is make the initial call for
the first iteration of the rendering loop:
-->
<p>Pour initier le processus de rendu, tout ce que nous avons Ã  faire est de faire
le premier appel Ã  la premiÃ¨re itÃ©ration de la boucle de renduÂ :</p>
<!--
```js
requestAnimationFrame(renderLoop);
```
-->
<pre><code class="language-js">requestAnimationFrame(boucleDeRendu);
</code></pre>
<!--
Make sure your development server is still running (run `npm run start` inside
`wasm-game-of-life/www`) and this is what
[http://localhost:8080/](http://localhost:8080/) should look like:
-->
<p>Assurez-vous que votre serveur de dÃ©veloppement continue de s'exÃ©cuter (lancez
<code>npm run start</code> dans <code>wasm-jeu-de-la-vie/www</code>) et voici ce Ã  quoi
<a href="http://localhost:8080/">http://localhost:8080/</a> devrait ressemblerÂ :</p>
<!--
[![Screenshot of the Game of Life implementation with text rendering](../images/game-of-life/initial-game-of-life-pre.png)](../images/game-of-life/initial-game-of-life-pre.png)
-->
<p><a href="game-of-life/images/game-of-life/initial-game-of-life-pre.png"><img src="game-of-life/images/game-of-life/initial-game-of-life-pre.png" alt="Capture d'Ã©cran de l'implÃ©mentation du jeu de la vie avec le rendu textuel" /></a></p>
<!--
## Rendering to Canvas Directly from Memory
-->
<h2><a class="header" href="#afficher-dans-un-canvas-directement-Ã -partir-de-la-mÃ©moire" id="afficher-dans-un-canvas-directement-Ã -partir-de-la-mÃ©moire">Afficher dans un canvas directement Ã  partir de la mÃ©moire</a></h2>
<!--
Generating (and allocating) a `String` in Rust and then having `wasm-bindgen`
convert it to a valid JavaScript string makes unnecessary copies of the
universe's cells. As the JavaScript code already knows the width and
height of the universe, and can read WebAssembly's linear memory that make up
the cells directly, we'll modify the `render` method to return a pointer to the
start of the cells array.
-->
<p>GÃ©nÃ©rer (et allouer) un <code>String</code> en Rust et le convertir en String JavaScript
valide par <code>wasm-bindgen</code> gÃ©nÃ¨re des copies inutiles des cellules de l'univers.
Comme le code JavaScript connait dÃ©jÃ  la largeur et la hauteur de l'univers,
et peux lire la mÃ©moire linÃ©aire de WebAssembly qui contient les cellules, nous
allons modifier la mÃ©thode <code>rendu</code> pour retourner un pointeur vers le dÃ©but du
tableau des cellules.</p>
<!--
Also, instead of rendering Unicode text, we'll switch to using the [Canvas
API]. We will use this design in the rest of the tutorial.
-->
<p>De plus, au lieu d'afficher du texte Unicode, nous allons utiliser <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">l'API de
canvas</a>. Nous utiliserons alors cette conception dans la suite du
tutoriel.</p>
<!--
[Canvas API]: https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API
-->
<!--
Inside `wasm-game-of-life/www/index.html`, let's replace the `<pre>` we added
earlier with a `<canvas>` we will render into (it too should be within the
`<body>`, before the `<script>` that loads our JavaScript):
-->
<p>Dans <code>wasm-jeu-de-la-vie/www/index.html</code>, remplaÃ§ons le <code>&lt;pre&gt;</code> que nous avons
ajoutÃ© prÃ©cÃ©demment par un <code>&lt;canvas&gt;</code> dans lequel nous allons faire notre rendu
(il devrait toujours se trouver dans la <code>&lt;body&gt;</code>, avant le <code>&lt;script&gt;</code> qui charge
notre JavaScript)Â :</p>
<!--
```html
<body>
  <canvas id="game-of-life-canvas"></canvas>
  <script src='./bootstrap.js'></script>
</body>
```
-->
<pre><code class="language-html">&lt;body&gt;
  &lt;canvas id=&quot;canvas-jeu-de-la-vie&quot;&gt;&lt;/canvas&gt;
  &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<!--
To get the necessary information from the Rust implementation, we'll need to add
some more getter functions for a universe's width, height, and pointer to its
cells array. All of these are exposed to JavaScript as well. Make these
additions to `wasm-game-of-life/src/lib.rs`:
-->
<p>Pour obtenir les informations de l'implÃ©mentation Rust nÃ©cessaires, nous avons
besoin d'ajouter plus d'accesseurs pour obtenir la largeur, la hauteur de
l'univers, et le pointeur Ã  son tableau de cellules. Ils seront eux aussi
exposÃ©s au JavaScript. Faites ces ajouts Ã  <code>wasm-jeu-de-la-vie/src/lib.rs</code>Â :</p>
<!--
```rust
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn width(&self) -> u32 {
        self.width
    }

    pub fn height(&self) -> u32 {
        self.height
    }

    pub fn cells(&self) -> *const Cell {
        self.cells.as_ptr()
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// MÃ©thodes publiques, exportÃ©es en JavaScript.
#[wasm_bindgen]
impl Univers {
    // ...

    pub fn largeur(&amp;self) -&gt; u32 {
        self.largeur
    }

    pub fn hauteur(&amp;self) -&gt; u32 {
        self.hauteur
    }

    pub fn cellules(&amp;self) -&gt; *const Cellule {
        self.cellules.as_ptr()
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Next, in `wasm-game-of-life/www/index.js`, let's also import `Cell` from
`wasm-game-of-life`, and define some constants that we will use when rendering
to the canvas:
-->
<p>Ensuite, dans <code>wasm-jeu-de-la-vie/www/index.js</code>, ajoutons aussi l'import de
<code>Cellule</code> de <code>wasm-jeu-de-la-vie</code>, et dÃ©finissons quelques constantes que nous
utiliserons lorsque nous ferons le rendu dans le canvasÂ :</p>
<!--
```js
import { Universe, Cell } from "wasm-game-of-life";

const CELL_SIZE = 5; // px
const GRID_COLOR = "#CCCCCC";
const DEAD_COLOR = "#FFFFFF";
const ALIVE_COLOR = "#000000";
```
-->
<pre><code class="language-js">import { Univers, Cellule } from &quot;wasm-jeu-de-la-vie&quot;;

const TAILLE_CELLULE = 5; // px
const COULEUR_GRILLE = &quot;#CCCCCC&quot;;
const COULEUR_MORTE = &quot;#FFFFFF&quot;;
const COULEUR_VIVANTE = &quot;#000000&quot;;
</code></pre>
<!--
Now, let's rewrite the rest of this JavaScript code to no longer write to the
`<pre>`'s `textContent` but instead draw to the `<canvas>`:
-->
<p>Maintenant, rÃ©-Ã©crivons le reste du code JavaScript pour ne plus avoir Ã  Ã©crire
avec <code>textContent</code> dans le <code>&lt;pre&gt;</code> mais dessiner dans <code>&lt;canvas&gt;</code> Ã  la placeÂ :</p>
<!--
```js
// Construct the universe, and get its width and height.
const universe = Universe.new();
const width = universe.width();
const height = universe.height();

// Give the canvas room for all of our cells and a 1px border
// around each of them.
const canvas = document.getElementById("game-of-life-canvas");
canvas.height = (CELL_SIZE + 1) * height + 1;
canvas.width = (CELL_SIZE + 1) * width + 1;

const ctx = canvas.getContext('2d');

const renderLoop = () => {
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
```
-->
<pre><code class="language-js">// Construit l'univers, et obtient sa largeur et son hauteur
const univers = Univers.new();
const largeur = univers.largeur();
const hauteur = univers.hauteur();

// Applique une taille au canvas pour accueillir toutes nos cellules et une
// bordure de 1px autour d'elles.

const canvas = document.getElementById(&quot;canvas-jeu-de-la-vie&quot;);
canvas.height = (TAILLE_CELLULE + 1) * largeur + 1;
canvas.width = (TAILLE_CELLULE + 1) * hauteur + 1;

const ctx = canvas.getContext('2d');

const boucleDeRendu = () =&gt; {
  univers.tick();

  dessinerGrille();
  dessinerCellules();

  requestAnimationFrame(boucleDeRendu);
};
</code></pre>
<!--
To draw the grid between cells, we draw a set of equally-spaced horizontal
lines, and a set of equally-spaced vertical lines. These lines criss-cross to
form the grid.
-->
<p>Pour dessiner la grille entre les cellules, nous dessinons un jeu de lignes
espacÃ©es rÃ©guliÃ¨rement horizontalement, et un jeu de lignes espacÃ©es
rÃ©guliÃ¨rement verticalement. Ces lignes s'entrecroisent pour former la grille.</p>
<!--
```js
const drawGrid = () => {
  ctx.beginPath();
  ctx.strokeStyle = GRID_COLOR;

  // Vertical lines.
  for (let i = 0; i <= width; i++) {
    ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);
    ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);
  }

  // Horizontal lines.
  for (let j = 0; j <= height; j++) {
    ctx.moveTo(0,                           j * (CELL_SIZE + 1) + 1);
    ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);
  }

  ctx.stroke();
};
```
-->
<pre><code class="language-js">const dessinerGrille = () =&gt; {
  ctx.beginPath();
  ctx.strokeStyle = COULEUR_GRILLE;

  // Lignes verticales.
  for (let i = 0; i &lt;= largeur; i++) {
    ctx.moveTo(i * (TAILLE_CELLULE + 1) + 1, 0);
    ctx.lineTo(i * (TAILLE_CELLULE + 1) + 1, (TAILLE_CELLULE + 1) * hauteur + 1);
  }

  // Lignes horizontales.
  for (let j = 0; j &lt;= hauteur; j++) {
    ctx.moveTo(0,                                  j * (TAILLE_CELLULE + 1) + 1);
    ctx.lineTo((TAILLE_CELLULE + 1) * largeur + 1, j * (TAILLE_CELLULE + 1) + 1);
  }

  ctx.stroke();
};
</code></pre>
<!--
We can directly access WebAssembly's linear memory via `memory`, which is
defined in the raw wasm module `wasm_game_of_life_bg`. To draw the cells, we
get a pointer to the universe's cells, construct a `Uint8Array` overlaying the
cells buffer, iterate over each cell, and draw a white or black rectangle
depending on whether the cell is dead or alive, respectively. By working with
pointers and overlays, we avoid copying the cells across the boundary on every
tick.
-->
<p>Nous pouvons accÃ©der directement Ã  la mÃ©moire linÃ©aire de WebAssembly via
<code>memory</code>, qui est dÃ©fini dans le module brut <code>wasm_jeu_de_la_vie_bg</code>. Pour
dessiner les cellules, nous obtenons le pointeur vers les cellules de l'univers,
construisons un <code>Uint8Array</code> qui sert de surcouche tampon pour les cellules,
itÃ¨re sur chaque cellule, et dessine un rectangle blanc ou noir, respectivement
si la cellule est morte ou vivante. En travaillant avec des pointeurs et des
surcouches, nous Ã©vitons de copier les cellules entre les deux domaines Ã  chaque
tick.</p>
<!--
```js
// Import the WebAssembly memory at the top of the file.
import { memory } from "wasm-game-of-life/wasm_game_of_life_bg";

// ...

const getIndex = (row, column) => {
  return row * width + column;
};

const drawCells = () => {
  const cellsPtr = universe.cells();
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height);

  ctx.beginPath();

  for (let row = 0; row < height; row++) {
    for (let col = 0; col < width; col++) {
      const idx = getIndex(row, col);

      ctx.fillStyle = cells[idx] === Cell.Dead
        ? DEAD_COLOR
        : ALIVE_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
```
-->
<pre><code class="language-js">// Importe la mÃ©moire de WebAssembly au dÃ©but du fichier.
import { memory } from &quot;wasm-jeu-de-la-vie/wasm_jeu_de_la_vie_bg&quot;;

// ...

const calculerIndice = (ligne, colonne) =&gt; {
  return ligne * largeur + colonne;
};

const dessinerCellules = () =&gt; {
  const pointeurCellules = univers.cellules();
  const cellules = new Uint8Array(memory.buffer, pointeurCellules, largeur * hauteur);

  ctx.beginPath();

  for (let ligne = 0; ligne &lt; hauteur; ligne++) {
    for (let colonne = 0; colonne &lt; largeur; colonne++) {
      const indice = calculerIndice(ligne, colonne);

      ctx.fillStyle = cellules[indice] === Cellule.Morte
        ? COULEUR_MORTE
        : COULEUR_VIVANTE;

      ctx.fillRect(
        colonne * (TAILLE_CELLULE + 1) + 1,
        ligne * (TAILLE_CELLULE + 1) + 1,
        TAILLE_CELLULE,
        TAILLE_CELLULE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
<!--
To start the rendering process, we'll use the same code as above to start the
first iteration of the rendering loop:
-->
<p>Pour dÃ©marrer le processus de rendu, nous allons utiliser le mÃªme code que
ci-dessus pour dÃ©marrer la premiÃ¨re itÃ©ration de la boucle de renduÂ :</p>
<!--
```js
drawGrid();
drawCells();
requestAnimationFrame(renderLoop);
```
-->
<pre><code class="language-js">dessinerGrille();
dessinerCellules();
requestAnimationFrame(boucleDeRendu);
</code></pre>
<!--
Note that we call `drawGrid()` and `drawCells()` here _before_ we call
`requestAnimationFrame()`. The reason we do this is so that the _initial_ state
of the universe is drawn before we make modifications. If we instead simply
called `requestAnimationFrame(renderLoop)`, we'd end up with a situation where
the first frame that was drawn would actually be _after_ the first call to
`universe.tick()`, which is the second "tick" of the life of these cells.
-->
<p>Notez que nous faisons appel Ã  <code>dessinerGrille()</code> et Ã  <code>dessinerCellules()</code> ici
<em>avant</em> de faire appel Ã  <code>requestAnimationFrame()</code>. La raison Ã  cela est que
l'Ã©tat <em>initial</em> de l'univers est dessinÃ© avant que nous procÃ©dions Ã  nos
modifications. Si nous avions simplement appelÃ©
<code>requestAnimationFrame(boucleDeRendu)</code> Ã  la place, nous nous serions retrouvÃ©
dans une situation dans laquelle la premiÃ¨re sÃ©quence serait dessinÃ©e <em>aprÃ¨s</em>
le premier appel Ã  <code>univers.tick()</code>, qui est le second &quot;tick&quot; dans la vie de ces
cellules.</p>
<!--
## It Works!
-->
<h2><a class="header" href="#cela-fonctionne-" id="cela-fonctionne-">Cela fonctionneÂ !</a></h2>
<!--
Rebuild the WebAssembly and bindings glue by running this command from within
the root `wasm-game-of-life` directory:
-->
<p>Recompilez le WebAssembly et la glue de liaison en lanÃ§ant cette commande dans
le dossier racine <code>wasm-jeu-de-la-vie</code>Â :</p>
<!--
```
wasm-pack build
```
-->
<pre><code>wasm-pack build
</code></pre>
<!--
Make sure your development server is still running. If it isn't, start it again
from within the `wasm-game-of-life/www` directory:
-->
<p>Assurez-vous que votre serveur de dÃ©veloppement fonctionne toujours. Si ce n'est
plus le cas, relancez-le dans le dossier <code>wasm-jeu-de-la-vie/www</code>Â :</p>
<!--
```
npm run start
```
-->
<pre><code>npm run start
</code></pre>
<!--
If you refresh [http://localhost:8080/](http://localhost:8080/), you should be
greeted with an exciting display of life!
-->
<p>Si vous rafraÃ®chissez <a href="http://localhost:8080/">http://localhost:8080/</a>, vous
devriez Ãªtre accueilli par une simulation de la vie captivanteÂ !</p>
<!--
[![Screenshot of the Game of Life implementation](../images/game-of-life/initial-game-of-life.png)](../images/game-of-life/initial-game-of-life.png)
-->
<p><a href="game-of-life/images/game-of-life/initial-game-of-life.png"><img src="game-of-life/images/game-of-life/initial-game-of-life.png" alt="Capture d'Ã©cran de l'implÃ©mentation du jeu de la vie" /></a></p>
<!--
As an aside, there is also a really neat algorithm for implementing the Game of
Life called [hashlife](https://en.wikipedia.org/wiki/Hashlife). It uses
aggressive memoizing and can actually get *exponentially faster* to compute
future generations the longer it runs! Given that, you might be wondering why we
didn't implement hashlife in this tutorial. It is out of scope for this text,
where we are focusing on Rust and WebAssembly integration, but we highly
encourage you to go learn about hashlife on your own!
-->
<p>Ceci dit, il existe aussi un algorithme trÃ¨s intÃ©ressant pour implÃ©menter le jeu
de la vie qui s'appelle <a href="https://fr.wikipedia.org/wiki/Hashlife">hashlive</a>. Il
utilise une mÃ©thode de gestion de la mÃ©moire poussÃ©e et peut devenir
<em>exponentiellement plus rapide</em> pour calculer les prochaines gÃ©nÃ©rations au fur
et Ã  mesure qu'il s'exÃ©cuteÂ ! Sachant cela, vous vous demandez peut-Ãªtre
pourquoi nous n'avons pas implÃ©mentÃ© hashlife dans ce tutoriel. Ce n'est pas le
but de ce document, car nous nous concentrons sur l'intÃ©gration de Rust en
WebAssembly, mais nous vous encourageons vivement d'en apprendre plus sur
hashlife par vous-mÃªmeÂ !</p>
<!--
## Exercises
-->
<h2><a class="header" href="#exercices-1" id="exercices-1">Exercices</a></h2>
<!--
* Initialize the universe with a single space ship.
-->
<ul>
<li>Initialiser l'univers avec un simple vaisseau spatial.</li>
</ul>
<!--
* Instead of hard-coding the initial universe, generate a random one, where each
  cell has a fifty-fifty chance of being alive or dead.
-->
<ul>
<li>
<p>Au lieu de coder en dur l'univers initial, gÃ©nÃ©rez-en un alÃ©atoire, dans
lequel chaque cellule a cinquante pour cent de chance d'Ãªtre vivante ou morte.</p>
<!--
*Hint: use [the `js-sys` crate](https://crates.io/crates/js-sys) to import
[the `Math.random` JavaScript
function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random).*
-->
<p><em>AstuceÂ : utilisez <a href="https://crates.io/crates/js-sys">la crate <code>js-sys</code></a> pour
importer <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random">la fonction JavaScript
<code>Math.random</code></a>.</em></p>
<!--
<details>
  <summary>Answer</summary>
  *First, add `js-sys` as a dependency in `wasm-game-of-life/Cargo.toml`:*

  ```toml
  # ...
  [dependencies]
  js-sys = "0.3"
  # ...
  ```

  *Then, use the `js_sys::Math::random` function to flip a coin:*

  ```rust
  extern crate js_sys;

  // ...

  if js_sys::Math::random() < 0.5 {
      // Alive...
  } else {
      // Dead...
  }
  ```
</details>
-->
<details>
  <summary>RÃ©ponse</summary>
<p><em>PremiÃ¨rement, ajoutez <code>js-sys</code> comme dÃ©pendance dans
<code>wasm-jeu-de-la-vie/Cargo.toml</code>Â :</em></p>
<pre><code class="language-toml"># ...
[dependencies]
js-sys = &quot;0.3&quot;
# ...
</code></pre>
<p><em>Ensuite, utilisez la fonction <code>js_sys::Math::random</code> pour gÃ©nÃ©rer un nombre
alÃ©atoireÂ :</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate js_sys; // (facultatif Ã  partir de Rust 2018)

// ...

if js_sys::Math::random() &lt; 0.5 {
    // Vivante ...
} else {
    // Morte ...
}
<span class="boring">}
</span></code></pre></pre>
</details>
</li>
</ul>
<!--
* Representing each cell with a byte makes iterating over cells easy, but it
  comes at the cost of wasting memory. Each byte is eight bits, but we only
  require a single bit to represent whether each cell is alive or dead. Refactor
  the data representation so that each cell uses only a single bit of space.
-->
<ul>
<li>
<p>ReprÃ©senter chaque cellule avec un octet facilite l'itÃ©ration sur les
cellules, mais cela gaspille de la mÃ©moire. Chaque octet a huit bits, mais
nous n'avons besoin d'un seul bit pour reprÃ©senter si chaque cellule est
vivante ou morte. Remaniez la reprÃ©sentation des donnÃ©es pour que chaque
cellule utilise uniquement un seul bit en mÃ©moire.</p>
<!--
<details>
  <summary>Answer</summary>

  In Rust, you can use [the `fixedbitset` crate and its `FixedBitSet`
  type](https://crates.io/crates/fixedbitset) to represent cells instead of
  `Vec<Cell>`:

  ```rust
  // Make sure you also added the dependency to Cargo.toml!
  extern crate fixedbitset;
  use fixedbitset::FixedBitSet;

  // ...

  #[wasm_bindgen]
  pub struct Universe {
      width: u32,
      height: u32,
      cells: FixedBitSet,
  }
  ```

  The Universe constructor can be adjusted the following way:

  ```rust
  pub fn new() -> Universe {
      let width = 64;
      let height = 64;

      let size = (width * height) as usize;
      let mut cells = FixedBitSet::with_capacity(size);

      for i in 0..size {
          cells.set(i, i % 2 == 0 || i % 7 == 0);
      }

      Universe {
          width,
          height,
          cells,
      }
  }
  ```

  To update a cell in the next tick of the universe, we use the `set` method
  of `FixedBitSet`:

  ```rust
  next.set(idx, match (cell, live_neighbors) {
      (true, x) if x < 2 => false,
      (true, 2) | (true, 3) => true,
      (true, x) if x > 3 => false,
      (false, 3) => true,
      (otherwise, _) => otherwise
  });
  ```

  To pass a pointer to the start of the bits to JavaScript, you can convert
  the `FixedBitSet` to a slice and then convert the slice to a pointer:

  ```rust
  #[wasm_bindgen]
  impl Universe {
      // ...

      pub fn cells(&self) -> *const u32 {
          self.cells.as_slice().as_ptr()
      }
  }
  ```

  In JavaScript, constructing a `Uint8Array` from Wasm memory is the same as
  before, except that the length of the array is not `width * height` anymore,
  but `width * height / 8` since we have a cell per bit rather than per byte:

  ```js
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);
  ```

  Given an index and `Uint8Array`, you can determine whether the
  *n<sup>th</sup>* bit is set with the following function:

  ```js
  const bitIsSet = (n, arr) => {
    const byte = Math.floor(n / 8);
    const mask = 1 << (n % 8);
    return (arr[byte] & mask) === mask;
  };
  ```

  Given all that, the new version of `drawCells` looks like this:

  ```js
  const drawCells = () => {
    const cellsPtr = universe.cells();

    // This is updated!
    const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);

    ctx.beginPath();

    for (let row = 0; row < height; row++) {
      for (let col = 0; col < width; col++) {
        const idx = getIndex(row, col);

        // This is updated!
        ctx.fillStyle = bitIsSet(idx, cells)
          ? ALIVE_COLOR
          : DEAD_COLOR;

        ctx.fillRect(
          col * (CELL_SIZE + 1) + 1,
          row * (CELL_SIZE + 1) + 1,
          CELL_SIZE,
          CELL_SIZE
        );
      }
    }

    ctx.stroke();
  };
  ```

</details>
-->
<details>
  <summary>RÃ©ponse</summary>
<p>En Rust, vous pouvez utiliser <a href="https://crates.io/crates/fixedbitset">la crate <code>fixedbitset</code> et son type
<code>FixedBitSet</code></a> pour reprÃ©senter les
cellules au lieu d'utiliser <code>Vec&lt;Cell&gt;</code>Â :</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Assurez-vous d'avoir aussi ajoutÃ© la dÃ©pendance dans Cargo.tomlÂ !
extern crate fixedbitset; // (facultatif en Rust 2018)
use fixedbitset::FixedBitSet;

// ...

#[wasm_bindgen]
pub struct Univers {
    largeur: u32,
    hauteur: u32,
    cellules: FixedBitSet,
}
<span class="boring">}
</span></code></pre></pre>
<p>Le constructeur de l'Univers peut Ãªtre corrigÃ© comme ceciÂ :</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Univers {
    let largeur = 64;
    let hauteur = 64;

    let taille = (largeur * hauteur) as usize;
    let mut cellules = FixedBitSet::with_capacity(taille);

    for i in 0..taille {
        cellules.set(i, i % 2 == 0 || i % 7 == 0);
    }

    Univers {
        largeur,
        hauteur,
        cellules,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Pour modifier une cellule Ã  la prochaine tick de l'univers, nous utilisons la
mÃ©thode <code>set</code> de <code>FixedBitSet</code>Â :</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>generation_suivante.set(indice, match (cellule, voisines_vivantes) {
    (true, x) if x &lt; 2 =&gt; false,
    (true, 2) | (true, 3) =&gt; true,
    (true, x) if x &gt; 3 =&gt; false,
    (false, 3) =&gt; true,
    (statut, _) =&gt; statut
});
<span class="boring">}
</span></code></pre></pre>
<p>Pour passer un pointeur vers le dÃ©part des bits en JavaScript, vous pouvez
convertir le <code>FixedBitSet</code> en une slice et ensuite convertir la slice en
pointeurÂ :</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
impl Univers {
    // ...

    pub fn cellules(&amp;self) -&gt; *const u32 {
        self.cellules.as_slice().as_ptr()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>En JavaScript, la construction d'un <code>Uint8Array</code> Ã  partir de la mÃ©moire de
WebAssembly est la mÃªme que prÃ©cÃ©demment, exceptÃ© que la longueur du tableau
n'est plus <code>largeur * hauteur</code>, mais <code>largeur * hauteur / 8</code> puisque nous
avons un bit par cellule au lieu d'un octetÂ :</p>
<pre><code class="language-js">const cellules = new Uint8Array(memory.buffer, pointeurCellules, largeur * hauteur / 8);
</code></pre>
<p>Pour un indice et un <code>Uint8Array</code> donnÃ©, vous pouvez obtenir le
<em>n<sup>iÃ¨me</sup></em> bit avec la fonction suivanteÂ :</p>
<pre><code class="language-js">const bitVautTrue = (n, tableau) =&gt; {
  const octet = Math.floor(n / 8);
  const masque = 1 &lt;&lt; (n % 8);
  return (tableau[octet] &amp; masque) === masque;
};
</code></pre>
<p>En ayant tout cela, la nouvelle version de <code>dessinerCellules</code> ressemble Ã 
ceciÂ :</p>
<pre><code class="language-js">const dessinerCellules = () =&gt; {
  const pointeurCellules = univers.cellules();

  // On a modifiÃ© celaÂ !
  const cellules = new Uint8Array(memory.buffer, pointeurCellules, largeur * hauteur / 8);

  ctx.beginPath();

  for (let ligne = 0; ligne &lt; hauteur; ligne++) {
    for (let colonne = 0; colonne &lt; largeur; colonne++) {
      const indice = calculerIndice(ligne, colonne);

      // On a modifiÃ© celaÂ !
      ctx.fillStyle = bitVautTrue(indice, cellules)
        ? COULEUR_VIVANTE
        : COULEUR_MORTE;

      ctx.fillRect(
        colonne * (TAILLE_CELLULE + 1) + 1,
        ligne * (TAILLE_CELLULE + 1) + 1,
        TAILLE_CELLULE,
        TAILLE_CELLULE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
</details>
</li>
</ul>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--9" id="-attention-peinture-fraÃ®che--9">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Testing Conway's Game of Life
-->
<h1><a class="header" href="#tester-le-jeu-de-la-vie-de-conway" id="tester-le-jeu-de-la-vie-de-conway">Tester le jeu de la vie de Conway</a></h1>
<!--
Now that we have our Rust implementation of the Game of Life rendering in the 
browser with JavaScript, let's talk about testing our Rust-generated 
WebAssembly functions.
-->
<p>Maintenant que nous avons notre implÃ©mentation en Rust du jeu de la vie qui
s'exÃ©cute dans le navigateur web avec JavaScript, nous pouvons voir comment
tester nos fonctions WebAssembly gÃ©nÃ©rÃ©es par Rust.</p>
<!--
We are going to test our `tick` function to make sure that it gives us the 
output that we expect.
-->
<p>Nous allons tester notre fonction <code>tick</code> pour s'assurer qu'elle nous donne bien
le rÃ©sultat que nous souhaitons.</p>
<!--
Next, we'll want to create some setter and getter 
functions inside our existing `impl Universe` block in the
`wasm_game_of_life/src/lib.rs` file. We are going to create a `set_width`
and a `set_height` function so we can create `Universe`s of different sizes.
-->
<p>Ensuite, nous allons crÃ©er des mutateurs et des accesseurs dans notre bloc
<code>impl Univers</code> dans le ficher <code>wasm-jeu-de-la-vie/src/lib.rs</code>. Nous allons crÃ©er
une fonction <code>set_largeur</code> et <code>set_hauteur</code> pour que nous puissions crÃ©er des
<code>Univers</code> de diffÃ©rentes tailles.</p>
<!--
```rust
#[wasm_bindgen]
impl Universe { 
    // ...

    /// Set the width of the universe.
    ///
    /// Resets all cells to the dead state.
    pub fn set_width(&mut self, width: u32) {
        self.width = width;
        self.cells = (0..width * self.height).map(|_i| Cell::Dead).collect();
    }

    /// Set the height of the universe.
    ///
    /// Resets all cells to the dead state.
    pub fn set_height(&mut self, height: u32) {
        self.height = height;
        self.cells = (0..self.width * height).map(|_i| Cell::Dead).collect();
    }

}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
impl Univers {
    // ...

    /// DÃ©finit la largeur de l'univers.
    ///
    /// Cela va tuer toutes les cellules.
    pub fn set_largeur(&amp;mut self, largeur: u32) {
        self.largeur = largeur;
        self.cellules = (0..largeur * self.hauteur).map(|_i| Cellule::Morte).collect();
    }

    /// DÃ©finit la hauteur de l'univers.
    ///
    /// Cela va tuer toutes les cellules.
    pub fn set_hauteur(&amp;mut self, hauteur: u32) {
        self.hauteur = hauteur;
        self.cellules = (0..self.largeur * hauteur).map(|_i| Cellule::Morte).collect();
    }

}
<span class="boring">}
</span></code></pre></pre>
<!--
We are going to create another `impl Universe` block inside our
`wasm_game_of_life/src/lib.rs` file without the `#[wasm_bindgen]` attribute.
There are a few functions we need for testing that we don't want to expose to
our JavaScript. Rust-generated WebAssembly functions cannot return
borrowed references. Try compiling the Rust-generated WebAssembly with the
attribute and take a look at the errors you get.
-->
<p>Nous allons crÃ©er un autre bloc <code>impl Univers</code> dans notre fichier
<code>wasm-jeu-de-la-vie</code> sans l'attribut <code>#[wasm_bindgen]</code>. Il y a quelques
fonctions que nous avons besoin pour tester que nous ne souhaitons pas exposer
au JavaScript. Les fonctions WebAssembly gÃ©nÃ©rÃ©es par Rust ne peut pas retourner
des rÃ©fÃ©rences empruntÃ©es. Essayez de compiler le WebAssembly gÃ©nÃ©rÃ© par Rust
avec l'attribut et constatez les erreurs que vous obtenez.</p>
<!--
We are going to write the implementation of `get_cells` to get the contents of
the `cells` of a `Universe`. We'll also write a `set_cells` function so we can
set `cells` in a specific row and column of a `Universe` to be `Alive.`
-->
<p>Nous allons Ã©crire l'implÃ©mentation de <code>get_cellules</code> pour obtenir le contenu de
<code>cellules</code> d'un <code>Univers</code>. Nous allons aussi Ã©crire une fonction <code>set_cellules</code>
pour que nous puissions donner vie Ã  des <code>cellules</code> d'un <code>Univers</code>.</p>
<!--
```rust
impl Universe {
    /// Get the dead and alive values of the entire universe.
    pub fn get_cells(&self) -> &[Cell] {
        &self.cells
    }

    /// Set cells to be alive in a universe by passing the row and column
    /// of each cell as an array.
    pub fn set_cells(&mut self, cells: &[(u32, u32)]) {
        for (row, col) in cells.iter().cloned() {
            let idx = self.get_index(row, col);
            self.cells[idx] = Cell::Alive;
        }
    }

}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Univers {
    /// Donne toutes les cellules mortes et vivantes de l'univers.
    pub fn get_cellules(&amp;self) -&gt; &amp;[Cellule] {
        &amp;self.cellules
    }

    /// DÃ©finit les cellules vivantes de l'univers en lui fournissant la ligne
    /// et la colonne de chacune des cellules dans un tableau.
    pub fn set_cellules(&amp;mut self, cellules: &amp;[(u32, u32)]) {
        for (ligne, colonne) in cellules.iter().cloned() {
            let indice = self.get_index(ligne, colonne);
            self.cellules[indice] = Cellule::Vivante;
        }
    }

}
<span class="boring">}
</span></code></pre></pre>
<!--
Now we're going to create our test in the `wasm_game_of_life/tests/web.rs` file.
-->
<p>Maintenant nous pouvons crÃ©er notre test dans le fichier
<code>wasm-jeu-de-la-vie/tests/web.rs</code>.</p>
<!--
Before we do that, there is already one working test in the file. You can
confirm that the Rust-generated WebAssembly test is working by running
`wasm-pack test --chrome --headless` in the `wasm-game-of-life` directory.
You can also use the `--firefox`, `--safari`, and `--node` options to
test your code in those browsers.
-->
<p>Avant de nous lancer, nous constatons qu'il existe dÃ©jÃ  un test qui fonctionne
dans ce fichier. Vous pouvez confirmer que le test du WebAssembly gÃ©nÃ©rÃ© par
Rust fonctionne en exÃ©cutant <code>wasm-pack test --chrome --headless</code> dans le
dossier <code>wasm-jeu-de-la-vie</code>. Vous pouvez utiliser les options <code>--firefox</code>,
<code>--safari</code>, et <code>--node</code> pour tester votre code dans ces navigateurs.</p>
<!--
In the `wasm_game_of_life/tests/web.rs` file, we need to export our
`wasm_game_of_life` crate and the `Universe` type.
-->
<p>Dans le fichier <code>wasm-jeu-de-la-vie/tests/web.rs</code>, nous devons importer notre
crate <code>wasm_jeu_de_la_vie</code> et le type <code>Univers</code>.</p>
<!--
```rust
extern crate wasm_game_of_life;
use wasm_game_of_life::Universe;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate wasm_jeu_de_la_vie; // (facultatif en Rust 2018)
use wasm_jeu_de_la_vie::Univers;
<span class="boring">}
</span></code></pre></pre>
<!--
In the `wasm_game_of_life/tests/web.rs` file we'll want to create some
spaceship builder functions.
-->
<p>Dans le fichier <code>wasm-jeu-de-la-vie/tests/web.rs</code>, nous allons ajouter quelques
fonctions qui crÃ©ent des crÃ©ateurs de vaisseaux spatiaux.</p>
<!--
We'll want one for our input spaceship that we'll call the `tick` function on
and we'll want the expected spaceship we will get after one tick. We picked the
cells that we want to initialize as `Alive` to create our spaceship in the
`input_spaceship` function. The position of the spaceship in the
`expected_spaceship` function after the tick of the `input_spaceship` was
calculated manually. You can confirm for yourself that the cells of the input
spaceship after one tick is the same as the expected spaceship.
-->
<p>Nous allons en ajouter une pour crÃ©er notre vaisseau spatial initial lorsque
nous appellerons la fonction <code>tick</code> et nous voulons qu'il soit toujours lÃ  aprÃ¨s
une <code>tick</code>. Nous avons choisi les cellules que nous voulons donner vie pour
crÃ©er notre vaisseau spatial dans la fonction <code>vaisseau_spatial_initial</code>. La
position du vaisseau spatial dans la fonction <code>vaisseau_spatial_attendu</code> dans
la <code>tick</code> suivant <code>vaisseau_spatial_initial</code> a Ã©tÃ© calculÃ©e manuellement. Vous
pouvez vÃ©rifier par vous-mÃªme que les cellules du vaisseau spatial initial sont
les mÃªmes que celles attendues aprÃ¨s une <code>tick</code>.</p>
<!--
```rust
#[cfg(test)]
pub fn input_spaceship() -> Universe {
    let mut universe = Universe::new();
    universe.set_width(6);
    universe.set_height(6);
    universe.set_cells(&[(1,2), (2,3), (3,1), (3,2), (3,3)]);
    universe
}

#[cfg(test)]
pub fn expected_spaceship() -> Universe {
    let mut universe = Universe::new();
    universe.set_width(6);
    universe.set_height(6);
    universe.set_cells(&[(2,1), (2,3), (3,2), (3,3), (4,2)]);
    universe
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
pub fn vaisseau_spatial_initial() -&gt; Univers {
    let mut univers = Univers::new();
    univers.set_largeur(6);
    univers.set_hauteur(6);
    univers.set_cellules(&amp;[(1,2), (2,3), (3,1), (3,2), (3,3)]);
    univers
}

#[cfg(test)]
pub fn vaisseau_spatial_attendu() -&gt; Univers {
    let mut univers = Univers::new();
    univers.set_largeur(6);
    univers.set_hauteur(6);
    univers.set_cellules(&amp;[(2,1), (2,3), (3,2), (3,3), (4,2)]);
    univers
}
<span class="boring">}
</span></code></pre></pre>
<!--
Now we will write the implementation for our `test_tick` function. First, we
create an instance of our `input_spaceship()` and our `expected_spaceship()`.
Then, we call `tick` on the `input_universe`. Finally, we use the `assert_eq!`
macro to call `get_cells()` to ensure that `input_universe` and
`expected_universe` have the same `Cell` array values. We add the
`#[wasm_bindgen_test]` attribute to our code block so we can test our
Rust-generated WebAssembly code and use `wasm-pack test` to test the
WebAssembly code.
-->
<p>Maintenant nous allons Ã©crire l'implÃ©mentation de notre fonction <code>test_tick</code>.
Pour commencer, nous allons crÃ©er une instance de notre
<code>vaisseau_spatial_initial()</code> et de notre <code>vaisseau_spatial_attendu()</code>. Ensuite,
nous appellerons <code>tick</code> sur <code>univers_initial</code>. Enfin, nous utiliserons la macro
<code>assert_eq!</code> pour faire appel Ã  <code>get_cellules()</code> pour s'assurer que
<code>univers_initial</code> et <code>univers_attendu</code> ont la mÃªme valeur pour leur tableau de
<code>Cellules</code>. Nous avons ajoutÃ© l'attribut <code>#[wasm_bindgen_test]</code> Ã  notre bloc de
code pour que nous puissions tester notre code WebAssembly gÃ©nÃ©rÃ© par Rust et
utiliser <code>wasm-pack test</code> pour tester le code WebAssembly.</p>
<!--
```rust
#[wasm_bindgen_test]
pub fn test_tick() {
    // Let's create a smaller Universe with a small spaceship to test!
    let mut input_universe = input_spaceship();

    // This is what our spaceship should look like
    // after one tick in our universe.
    let expected_universe = expected_spaceship();

    // Call `tick` and then see if the cells in the `Universe`s are the same.
    input_universe.tick();
    assert_eq!(&input_universe.get_cells(), &expected_universe.get_cells());
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen_test]
pub fn test_tick() {
    // On crÃ©e un petit univers avec un petit vaisseau spatial, pour testerÂ !
    let mut univers_initial = vaisseau_spatial_initial();

    // C'est ce Ã  quoi doit ressembler notre vaisseau spatial aprÃ¨s une tick
    // dans notre univers.
    let univers_attendu = vaisseau_spatial_attendu();

    // Appelons `tick` et voyons ensuite si les cellules dans les `Univers` sont
    // les mÃªmes.
    univers_initial.tick();
    assert_eq!(&amp;univers_initial.get_cells(), &amp;univers_attendu.get_cells());
}
<span class="boring">}
</span></code></pre></pre>
<!--
Run the tests within the `wasm-game-of-life` directory by running
`wasm-pack test --firefox --headless`.
-->
<p>ExÃ©cutez les tests dans le dossier <code>wasm-jeu-de-la-vie</code> en exÃ©cutant
<code>wasm-pack test --firefox --headless</code>.</p>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--10" id="-attention-peinture-fraÃ®che--10">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Debugging
-->
<h1><a class="header" href="#dÃ©bogage" id="dÃ©bogage">DÃ©bogage</a></h1>
<!--
Before we write much more code, we will want to have some debugging tools in our
belt for when things go wrong. Take a moment to review the [reference page
listing tools and approaches available for debugging Rust-generated
WebAssembly][reference-debugging].
-->
<p>Avant d'Ã©crire plus de code, nous devons nous Ã©quiper d'outils de dÃ©bogage pour
les moments oÃ¹ cela se passe mal. Prenez donc une minute pour consulter la <a href="game-of-life/reference/debugging.html">page
de rÃ©fÃ©rence qui liste les outils et les approches pour dÃ©boguer le WebAssembly
gÃ©nÃ©rÃ© par Rust</a>.</p>
<!--
[reference-debugging]: ../reference/debugging.html
-->
<!--
## Enable Logging for Panics
-->
<h2><a class="header" href="#activer-les-journaux-pour-les-paniques" id="activer-les-journaux-pour-les-paniques">Activer les journaux pour les paniques</a></h2>
<!--
[If our code panics, we want informative error messages to appear in the
developer console.](../reference/debugging.html#logging-panics)
-->
<p><a href="game-of-life/reference/debugging.html#journaliser-les-paniques">Si notre code panique, nous souhaitons avoir un message d'erreur qui nous en
informe dans la console de
dÃ©veloppement</a>.</p>
<!--
Our `wasm-pack-template` comes with an optional, enabled-by-default dependency
on [the `console_error_panic_hook` crate][panic-hook] that is configured in
`wasm-game-of-life/src/utils.rs`. All we need to do is install the hook in an
initialization function or common code path. We can call it inside the
`Universe::new` constructor in `wasm-game-of-life/src/lib.rs`:
-->
<p>Notre <code>wasm-pack-template-fr</code> applique une dÃ©pendance optionnelle et activÃ©e par
dÃ©faut envers <a href="https://github.com/rustwasm/console_error_panic_hook">la crate <code>console_error_panic_hook</code></a> qui est
configurÃ©e dans <code>wasm-jeu-de-la-vie/src/utils.rs</code>. Tout ce que nous avons besoin
de faire est d'installer le systÃ¨me dans une fonction d'initialisation ou dans
un code standard qui s'exÃ©cutera. Nous pouvons faire appel Ã  cela dans le
constructeur <code>Univers::new</code> dans <code>wasm-jeu-de-la-vie/src/lib.rs</code>Â :</p>
<!--
```rust
pub fn new() -> Universe {
    utils::set_panic_hook();

    // ...
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Univers {
    utils::set_panic_hook();

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<!--
[panic-hook]: https://github.com/rustwasm/console_error_panic_hook
-->
<!--
## Add Logging to our Game of Life
-->
<h2><a class="header" href="#ajouter-des-journaux-dans-notre-jeu-de-la-vie" id="ajouter-des-journaux-dans-notre-jeu-de-la-vie">Ajouter des journaux dans notre jeu de la vie</a></h2>
<!--
Let's [use the `console.log` function via the `web-sys` crate to add some
logging][logging] about each cell in our `Universe::tick` function.
-->
<p><a href="game-of-life/reference/debugging.html#journaliser-avec-les-api-de-console">Utilisons la fonction <code>console.log</code> via la crate <code>web-sys</code> pour ajouter
quelques journaux</a> sur le traitement de chaque cellule dans notre
fonction <code>Univers::tick</code>.</p>
<!--
First, add `web-sys` as a dependency and enable its `"console"` feature in
`wasm-game-of-life/Cargo.toml`:
-->
<p>Pour commencer, ajoutez <code>web-sys</code> comme dÃ©pendance et ajoutez sa fonctionnalitÃ©
<code>&quot;console&quot;</code> dans <code>wasm-jeu-de-la-vie/Cargo.toml</code>Â :</p>
<!--
```toml
[dependencies.web-sys]
version = "0.3"
features = [
  "console",
]
```
-->
<pre><code class="language-toml">[dependencies.web-sys]
version = &quot;0.3&quot;
features = [
  &quot;console&quot;,
]
</code></pre>
<!--
For ergonomics, we'll wrap the `console.log` function up in a `println!`-style
macro:
-->
<p>Pour que ce soit plus pratique, nous allons intÃ©grer la fonction <code>console.log</code>
dans une macro du mÃªme style que <code>println!</code>Â :</p>
<!--
[logging]: ../reference/debugging.html#logging-with-the-console-apis
-->
<!--
```rust
extern crate web_sys;

// A macro to provide `println!(..)`-style syntax for `console.log` logging.
macro_rules! log {
    ( $( $t:tt )* ) => {
        web_sys::console::log_1(&format!( $( $t )* ).into());
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

// Une macro dans le mÃªme style que `println!(..)` pour la journalisation avec
// `console.log`.
macro_rules! log {
    ( $( $t:tt )* ) =&gt; {
        web_sys::console::log_1(&amp;format!( $( $t )* ).into());
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Now, we can start logging messages to the console by inserting calls to `log` in
Rust code. For example, to log each cell's state, live neighbors count, and next
state, we could modify `wasm-game-of-life/src/lib.rs` like this:
-->
<p>Maintenant nous pouvons commencer Ã  ajouter des journaux dans la console en
insÃ©rant des appels Ã  <code>log</code> dans le code Rust. Par exemple, pour afficher l'Ã©tat
de chaque cellule, le compteur de ses voisines vivantes, et le prochain Ã©tat,
nous pouvons modifier <code>wasm-jeu-de-la-vie/src/lib.rs</code> comme ceciÂ :</p>
<!--
```diff
diff --git a/src/lib.rs b/src/lib.rs
index f757641..a30e107 100755
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -123,6 +122,14 @@ impl Universe {
                 let cell = self.cells[idx];
                 let live_neighbors = self.live_neighbor_count(row, col);

+                log!(
+                    "cell[{}, {}] is initially {:?} and has {} live neighbors",
+                    row,
+                    col,
+                    cell,
+                    live_neighbors
+                );
+
                 let next_cell = match (cell, live_neighbors) {
                     // Rule 1: Any live cell with fewer than two live neighbours
                     // dies, as if caused by underpopulation.
@@ -140,6 +147,8 @@ impl Universe {
                     (otherwise, _) => otherwise,
                 };

+                log!("    it becomes {:?}", next_cell);
+
                 next[idx] = next_cell;
             }
         }
```
-->
<pre><code class="language-diff">diff --git a/src/lib.rs b/src/lib.rs
index f757641..a30e107 100755
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -123,6 +122,14 @@ impl Univers {
                 let cellule = self.cellules[indice];
                 let voisines_vivantes = self.compter_voisines_vivantes(ligne, colonne);

+                log!(
+                    &quot;La cellule [{}, {}] est initialement {:?} et a {} voisines vivantes&quot;,
+                    ligne,
+                    colonne,
+                    cellule,
+                    voisines_vivantes
+                );
+
                 let prochain_etat = match (cellule, voisines_vivantes) {
                     // RÃ¨gle 1 : toute cellule vivante avec moins de deux
                     // voisines vivantes meurt, comme si cela Ã©tait un effet de
                     // sous-population.
@@ -140,6 +147,8 @@ impl Universe {
                     (statut, _) =&gt; statut,
                 };

+                log!(&quot;    et elle devient {:?}&quot;, prochain_etat);
+
                 generation_suivante[idx] = prochain_etat;
             }
         }
</code></pre>
<!--
## Using a Debugger to Pause Between Each Tick
-->
<h2><a class="header" href="#utiliser-un-dÃ©bogueur-pour-faire-une-pause-entre-chaque-tick" id="utiliser-un-dÃ©bogueur-pour-faire-une-pause-entre-chaque-tick">Utiliser un dÃ©bogueur pour faire une pause entre chaque tick</a></h2>
<!--
[Browser's stepping debuggers are useful for inspecting the JavaScript that our
Rust-generated WebAssembly interacts
with.](../reference/debugging.html#using-a-debugger)
-->
<p><a href="game-of-life/reference/debugging.html#utiliser-un-d%C3%A9bogueur">Les dÃ©bogueurs par Ã©tape des navigateurs sont utiles pour inspecter le
JavaScript avec lequel interagit notre WebAssembly gÃ©nÃ©rÃ© par
Rust</a>.</p>
<!--
For example, we can use the debugger to pause on each iteration of our
`renderLoop` function by placing [a JavaScript `debugger;` statement][dbg-stmt]
above our call to `universe.tick()`.
-->
<p>Par exemple, nous pouvons utiliser le dÃ©bogueur pour faire une pause sur chaque
itÃ©ration de notre fonction <code>boucleDeRendu</code> en plaÃ§ant <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/debugger">une instruction
JavaScript <code>debugger;</code></a> juste avant l'appel Ã  <code>univers.tick()</code>.</p>
<!--
```js
const renderLoop = () => {
  debugger;
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
```
-->
<pre><code class="language-js">const boucleDeRendu = () =&gt; {
  debugger;
  univers.tick();

  dessinerGrille();
  dessinerCellules();

  requestAnimationFrame(boucleDeRendu);
};
</code></pre>
<!--
This provides us with a convenient checkpoint for inspecting logged messages,
and comparing the currently rendered frame to the previous one.
-->
<p>Cela nous fournit un point de passage efficace pour inspecter les journaux, et
pour comparer le rendu actuel avec le prÃ©cÃ©dent.</p>
<!--
[dbg-stmt]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger
-->
<!--
[![Screenshot of debugging the Game of Life](../images/game-of-life/debugging.png)](../images/game-of-life/debugging.png)
-->
<p><a href="game-of-life/images/game-of-life/debugging.png"><img src="game-of-life/images/game-of-life/debugging.png" alt="Capture d'Ã©cran du dÃ©bogage du jeu de la vie" /></a></p>
<!--
## Exercises
-->
<h2><a class="header" href="#exercices-2" id="exercices-2">Exercices</a></h2>
<!--
* Add logging to the `tick` function that records the row and column of each
  cell that transitioned states from live to dead or vice versa.
-->
<ul>
<li>Ajoutez des journaux Ã  la fonction <code>tick</code> qui affiche la ligne et la colonne
de chaque cellule qui chaque d'Ã©tat, de vivante Ã  morte et vice-versa.</li>
</ul>
<!--
* Introduce a `panic!()` in the `Universe::new` method. Inspect the panic's
  backtrace in your Web browser's JavaScript debugger. Disable debug symbols,
  rebuild without the `console_error_panic_hook` optional dependency, and
  inspect the stack trace again. Not as useful is it?
-->
<ul>
<li>Ajoutez un <code>panic!()</code> dans la mÃ©thode <code>Univers::new</code>. Inspectez alors la trace
de pile dans le dÃ©bogueur JavaScript de votre navigateur Web. Puis, dÃ©sactivez
les symboles de dÃ©bogage, recompilez sans la dÃ©pendance optionnelle Ã 
<code>console_error_panic_hook</code>, et inspectez Ã  nouveau la trace de pile. Pratique,
n'est-ce pasÂ ?</li>
</ul>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--11" id="-attention-peinture-fraÃ®che--11">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Adding Interactivity
-->
<h1><a class="header" href="#ajouter-de-linteractivitÃ©" id="ajouter-de-linteractivitÃ©">Ajouter de l'interactivitÃ©</a></h1>
<!--
We will continue to explore the JavaScript and WebAssembly interface by adding
some interactive features to our Game of Life implementation. We will enable
users to toggle whether a cell is alive or dead by clicking on it, and
allow pausing the game, which makes drawing cell patterns a lot easier.
-->
<p>Nous allons continuer Ã  explorer l'interfaÃ§age entre le JavaScript et le
WebAssembly en ajouter des fonctionnalitÃ©s d'interaction avec notre
implÃ©mentation du jeu de la vie. Nous allons permettre aux utilisateurs de
changer le statut vivant ou mort d'une cellule en cliquant dessus, et aussi leur
permettre de mettre en pause le jeu, ce qui va faciliter le dessin de certains
schÃ©mas.</p>
<!--
## Pausing and Resuming the Game
-->
<h2><a class="header" href="#mettre-en-pause-et-reprendre-le-jeu" id="mettre-en-pause-et-reprendre-le-jeu">Mettre en pause et reprendre le jeu</a></h2>
<!--
Let's add a button to toggle whether the game is playing or paused. To
`wasm-game-of-life/www/index.html`, add the button right above the `<canvas>`:
-->
<p>Ajoutons un bouton pour changer si le jeu est en cours de lecture ou en pause.
Dans <code>wasm-jeu-de-la-vie/www/index.html</code>, ajoutez le bouton juste au-dessus le
<code>&lt;canvas&gt;</code>Â :</p>
<!--
```html
<button id="play-pause"></button>
```
-->
<pre><code class="language-html">&lt;button id=&quot;lecture-pause&quot;&gt;&lt;/button&gt;
</code></pre>
<!--
In the `wasm-game-of-life/www/index.js` JavaScript, we will make the following
changes:
-->
<p>Dans le JavaScript <code>wasm-game-of-life/www/index.js</code>, nous allons faire les
changements suivantsÂ :</p>
<!--
* Keep track of the identifier returned by the latest call to
  `requestAnimationFrame`, so that we can cancel the animation by calling
  `cancelAnimationFrame` with that identifier.
-->
<ul>
<li>Conserver l'identifiant retournÃ© par le dernier appel Ã 
<code>requestAnimationFrame</code>, pour que nous puissions annuler l'animation en
faisant appel Ã  <code>cancelAnimationFrame</code> avec cet identifiant.</li>
</ul>
<!--
* When the play/pause button is clicked, check for whether we have the
  identifier for a queued animation frame. If we do, then the game is currently
  playing, and we want to cancel the animation frame so that `renderLoop` isn't
  called again, effectively pausing the game. If we do not have an identifier
  for a queued animation frame, then we are currently paused, and we would like
  to call `requestAnimationFrame` to resume the game.
-->
<ul>
<li>Lorsque le bouton lecture/pause sera actionnÃ©, on va regarder si nous avons un
identifiant pour un calcul d'une gÃ©nÃ©ration de l'animation. Si c'est le cas,
alors le jeu est actuellement en cours de lecture, et cela veut donc dire que
nous souhaitons annuler le calcul pour Ã©viter que <code>boucleDeRendu</code> soit appelÃ©
Ã  nouveau, ce qui aura pour effet de mettre en pause le jeu. Si nous n'avons
pas d'identifiant pour un calcul d'une gÃ©nÃ©ration de l'animation, alors cela
veut dire que nous sommes actuellement en pause, et nous devons faire appel Ã 
<code>requestAnimationFrame</code> pour reprendre le jeu.</li>
</ul>
<!--
Because the JavaScript is driving the Rust and WebAssembly, this is all we need
to do, and we don't need to change the Rust sources.
-->
<p>Comme le JavaScript pilote le Rust via le WebAssembly, c'est tout ce que nous
avons besoin de faire, et nous n'avons pas besoin de changer le code source
Rust.</p>
<!--
We introduce the `animationId` variable to keep track of the identifier returned
by `requestAnimationFrame`. When there is no queued animation frame, we set this
variable to `null`.
-->
<p>Nous ajoutons la variable <code>animationId</code> pour conserver l'identifiant retournÃ©
par <code>requestAnimationFrame</code>. Lorsqu'il n'y a pas de calcul d'une gÃ©nÃ©ration de
l'animation, nous donnons assignons la valeur <code>null</code> Ã  cette variable.</p>
<!--
```js
let animationId = null;

// This function is the same as before, except the
// result of `requestAnimationFrame` is assigned to
// `animationId`.
const renderLoop = () => {
  drawGrid();
  drawCells();

  universe.tick();

  animationId = requestAnimationFrame(renderLoop);
};
```
-->
<pre><code class="language-js">let animationId = null;

// Cette fonction est la mÃªme qu'avant, sauf que le rÃ©sultat de
// `requestAnimationFrame` est assignÃ© Ã  `animationId`.
const boucleDeRendu = () =&gt; {
  dessinerGrille();
  dessinerCellules();

  univers.tick();

  animationId = requestAnimationFrame(boucleDeRendu);
};
</code></pre>
<!--
At any instant in time, we can tell whether the game is paused or not by
inspecting the value of `animationId`:
-->
<p>A n'importe quel moment, nous pouvons savoir si le jeu est en pause ou non en
vÃ©rifiant la valeur de <code>animationId</code>Â :</p>
<!--
```js
const isPaused = () => {
  return animationId === null;
};
```
-->
<pre><code class="language-js">const estEnPause = () =&gt; {
  return animationId === null;
};
</code></pre>
<!--
Now, when the play/pause button is clicked, we check whether the game is
currently paused or playing, and resume the `renderLoop` animation or cancel the
next animation frame respectively. Additionally, we update the button's text
icon to reflect the action that the button will take when clicked next.
-->
<p>Maintenant lorsque le bouton lecture/pause est cliquÃ©, nous vÃ©rifions si le jeu
est en pause ou en lecture, et respectivement nous reprenons l'animation
<code>boucleDeRendu</code> ou nous arrÃªtons le calcul de la prochaine gÃ©nÃ©ration de
l'animation. De plus, nous allons changer le texte du bouton pour reflÃ©ter
l'action que le bouton va faire lors du prochain clic.</p>
<!--
```js
const playPauseButton = document.getElementById("play-pause");

const play = () => {
  playPauseButton.textContent = "â¸";
  renderLoop();
};

const pause = () => {
  playPauseButton.textContent = "â–¶";
  cancelAnimationFrame(animationId);
  animationId = null;
};

playPauseButton.addEventListener("click", event => {
  if (isPaused()) {
    play();
  } else {
    pause();
  }
});
```
-->
<pre><code class="language-js">const boutonLecturePause = document.getElementById(&quot;lecture-pause&quot;);

const lecture = () =&gt; {
  boutonLecturePause.textContent = &quot;â¸&quot;;
  boucleDeRendu();
};

const pause = () =&gt; {
  boutonLecturePause.textContent = &quot;â–¶&quot;;
  cancelAnimationFrame(animationId);
  animationId = null;
};

boutonLecturePause.addEventListener(&quot;click&quot;, event =&gt; {
  if (estEnPause()) {
    lecture();
  } else {
    pause();
  }
});
</code></pre>
<!--
Finally, we were previously kick-starting the game and its animation by calling
`requestAnimationFrame(renderLoop)` directly, but we want to replace that with a
call to `play` so that the button gets the correct initial text icon.
-->
<p>Enfin, jusqu'ici nous avons dÃ©marrÃ© le jeu et son animation en faisant
directement appel Ã  <code>requestAnimationFrame(boucleDeRendu)</code>, mais nous voulons
remplacer cela par l'appel Ã  <code>lecture</code> pour que le bouton ait la bonne icone
initiale.</p>
<!--
```diff
// This used to be `requestAnimationFrame(renderLoop)`.
play();
```
-->
<pre><code class="language-diff">// On utilise cela Ã  la place de `requestAnimationFrame(boucleDeRendu)`.
lecture();
</code></pre>
<!--
Refresh [http://localhost:8080/](http://localhost:8080/) and we should now be
able to pause and resume the game by clicking on the button!
-->
<p>RafraÃ®chissez <a href="http://localhost:8080/">http://localhost:8080/</a> et vous devriez
maintenant mettre en pause et reprendre le jeu en cliquant sur le boutonÂ !</p>
<!--
## Toggling a Cell's State on `"click"` Events
-->
<h2><a class="header" href="#changer-lÃ©tat-dune-cellule-avec-un-Ã©vÃ¨nement-click" id="changer-lÃ©tat-dune-cellule-avec-un-Ã©vÃ¨nement-click">Changer l'Ã©tat d'une cellule avec un Ã©vÃ¨nement <code>&quot;click&quot;</code></a></h2>
<!--
Now that we can pause the game, it's time to add the ability to mutate the cells
by clicking on them.
-->
<p>Maintenant que nous pouvons mettre le jeu en pause, nous pouvons ajouter la
possibilitÃ© de muter les cellules en cliquant sur elles.</p>
<!--
To toggle a cell is to flip its state from alive to dead or from dead to
alive. Add a `toggle` method to `Cell` in `wasm-game-of-life/src/lib.rs`:
-->
<p>Pour basculer le statut d'une cellule de vivante Ã  morte, ou de morte Ã  vivante.
Ajoutez une mÃ©thode <code>basculer</code> Ã  <code>Cellule</code> dans
<code>wasm-jeu-de-la-vie/src/lib.rs</code>Â :</p>
<!--
```rust
impl Cell {
    fn toggle(&mut self) {
        *self = match *self {
            Cell::Dead => Cell::Alive,
            Cell::Alive => Cell::Dead,
        };
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cellule {
    fn basculer(&amp;mut self) {
        *self = match *self {
            Cellule::Morte =&gt; Cellule::Vivante,
            Cellule::Vivante =&gt; Cellule::Morte,
        };
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
To toggle the state of a cell at given row and column, we translate the row and
column pair into an index into the cells vector and call the toggle method on
the cell at that index:
-->
<p>Pour basculer l'Ã©tat d'une cellule Ã  une ligne et colonne donnÃ©e, nous
traduisons le couple ligne et colonne en indice du vecteur de toutes les
cellules et nous faisons appel Ã  la mÃ©thode <code>basculer</code> sur la cellule Ã  cet
indiceÂ :</p>
<!--
```rust
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn toggle_cell(&mut self, row: u32, column: u32) {
        let idx = self.get_index(row, column);
        self.cells[idx].toggle();
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// MÃ©thodes publiques, exportÃ©es en JavaScript.
#[wasm_bindgen]
impl Univers {
    // ...

    pub fn basculer_cellule(&amp;mut self, ligne: u32, colonne: u32) {
        let indice = self.calculer_indice(ligne, colonne);
        self.cellules[indice].basculer();
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
This method is defined within the `impl` block that is annotated with
`#[wasm_bindgen]` so that it can be called by JavaScript.
-->
<p>Cette mÃ©thode est dÃ©finie dans le bloc <code>impl</code> qui est annotÃ© avec
<code>#[wasm_bingen]</code> afin qu'il puisse Ãªtre appelÃ© en JavaScript.</p>
<!--
In `wasm-game-of-life/www/index.js`, we listen to click events on the `<canvas>`
element, translate the click event's page-relative coordinates into
canvas-relative coordinates, and then into a row and column, invoke the
`toggle_cell` method, and finally redraw the scene.
-->
<p>Dans <code>wasm-jeu-de-la-vie/www/index.js</code>, nous Ã©coutons les Ã©vÃ¨nements de clics
sur le noeud <code>&lt;canvas&gt;</code>, puis nous traduisons les coordonnÃ©es du clic dans le
contexte de la page en coordonnÃ©es dans le canvas, et ensuite ces coordonnÃ©es
en ligne et colonne, puis nous Ã©voquons la mÃ©thode <code>basculer_cellule</code>, et enfin
nous redessinons la scÃ¨ne.</p>
<!--
```js
canvas.addEventListener("click", event => {
  const boundingRect = canvas.getBoundingClientRect();

  const scaleX = canvas.width / boundingRect.width;
  const scaleY = canvas.height / boundingRect.height;

  const canvasLeft = (event.clientX - boundingRect.left) * scaleX;
  const canvasTop = (event.clientY - boundingRect.top) * scaleY;

  const row = Math.min(Math.floor(canvasTop / (CELL_SIZE + 1)), height - 1);
  const col = Math.min(Math.floor(canvasLeft / (CELL_SIZE + 1)), width - 1);

  universe.toggle_cell(row, col);

  drawGrid();
  drawCells();
});
```
-->
<pre><code class="language-js">canvas.addEventListener(&quot;click&quot;, evenement =&gt; {
  const zoneRectangulaire = canvas.getBoundingClientRect();

  const echelleX = canvas.width / zoneRectangulaire.width;
  const echelleY = canvas.height / zoneRectangulaire.height;

  const distanceGaucheDuCanvas = (evenement.clientX - zoneRectangulaire.left) * echelleX;
  const distanceHautDuCanvas = (evenement.clientY - zoneRectangulaire.top) * echelleY;

  const ligne = Math.min(Math.floor(distanceHautDuCanvas / (CELL_SIZE + 1)), hauteur - 1);
  const colonne = Math.min(Math.floor(distanceGaucheDuCanvas / (CELL_SIZE + 1)), largeur - 1);

  univers.basculer_cellule(ligne, colonne);

  dessinerGrille();
  dessinerCellules();
});
</code></pre>
<!--
Rebuild with `wasm-pack build` in `wasm-game-of-life`, then refresh
[http://localhost:8080/](http://localhost:8080/) again and we can now draw our
own patterns by clicking on the cells and toggling their state.
-->
<p>Recompilez avec <code>wasm-pack build</code> dans le dossier <code>wasm-jeu-de-la-vie</code>, ensuite
rafraÃ®chissez Ã  nouveau la page <a href="http://localhost:8080/">http://localhost:8080/</a>
et vous devriez pouvoir dessiner vos propres schÃ©mas en cliquant sur les
cellules pour pouvoir changer leur Ã©tat.</p>
<!--
## Exercises
-->
<h2><a class="header" href="#exercices-3" id="exercices-3">Exercices</a></h2>
<!--
* Introduce an [`<input type="range">`][input-range] widget to control how many
  ticks occur per animation frame.
-->
<ul>
<li>Ajouter un composant <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range"><code>&lt;input type=&quot;range&quot;&gt;</code></a> pour pouvoir rÃ©gler
combien de ticks se produisent Ã  chaque sÃ©quence de l'animation.</li>
</ul>
<!--
* Add a button that resets the universe to a random initial state when
  clicked. Another button that resets the universe to all dead cells.
-->
<ul>
<li>Ajouter un bouton qui rÃ©initialise l'univers dans un Ã©tat initial alÃ©atoire
lorsqu'on clique dessus. Et un autre bouton qui rÃ©initialise l'univers avec
uniquement des cellules mortes.</li>
</ul>
<!--
* On `Ctrl + Click`, insert a
  [glider](https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)) centered on
  the target cell. On `Shift + Click`, insert a pulsar.
-->
<ul>
<li>Lors d'un <code>Ctrl + Clic</code>, insÃ©rez un
<a href="https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)">planeur</a> centrÃ© sur
la cellule cible.
Lors d'un <code>Shift + Clic</code>, insÃ©rez un pulsar.</li>
</ul>
<!--
[input-range]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--12" id="-attention-peinture-fraÃ®che--12">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<blockquote>
<p>ğŸš§ Les captures d'Ã©cran de cette page n'ont pas encore Ã©tÃ© traduites !</p>
</blockquote>
<!--
# Time Profiling
-->
<h1><a class="header" href="#le-profilage-temporel" id="le-profilage-temporel">Le profilage temporel</a></h1>
<!--
In this chapter, we will improve the performance of our Game of Life
implementation. We will use time profiling to guide our efforts.
-->
<p>Dans ce chapitre, nous allons amÃ©liorer la performance de l'implÃ©mentation de
notre jeu de la vie. Nous allons utiliser le profilage temporel pour orienter
notre travail.</p>
<!--
Familiarize yourself with [the available tools for time profiling Rust and
WebAssembly code](../reference/time-profiling.md) before continuing.
-->
<p>Avant de continuer, familiarisez-vous avec [les outils disponibles pour le
profilage temporel pour le code Rust et WebAssembly].</p>
<!--
## Creating a Frames Per Second Timer with the `window.performance.now` Function
-->
<h2><a class="header" href="#crÃ©er-un-compteur-dimages-par-seconde-avec-windowperformancenow" id="crÃ©er-un-compteur-dimages-par-seconde-avec-windowperformancenow">CrÃ©er un compteur d'images par seconde avec <code>window.performance.now</code></a></h2>
<!--
This FPS timer will be useful as we investigate speeding up our Game of Life's
rendering.
-->
<p>Ce compteur d'images par seconde sera un indicateur utile lors de nos
recherches d'amÃ©liorations de performances du rendu de notre jeu de la vie.</p>
<!--
We start by adding an `fps` object to `wasm-game-of-life/www/index.js`:
-->
<p>Nous allons commencer par rajouter un objet <code>ips</code> (pour <code>Images Par Seconde</code>) Ã 
<code>wasm-jeu-de-la-vie/www/index.js</code>Â :</p>
<!--
```js
const fps = new class {
  constructor() {
    this.fps = document.getElementById("fps");
    this.frames = [];
    this.lastFrameTimeStamp = performance.now();
  }

  render() {
    // Convert the delta time since the last frame render into a measure
    // of frames per second.
    const now = performance.now();
    const delta = now - this.lastFrameTimeStamp;
    this.lastFrameTimeStamp = now;
    const fps = 1 / delta * 1000;

    // Save only the latest 100 timings.
    this.frames.push(fps);
    if (this.frames.length > 100) {
      this.frames.shift();
    }

    // Find the max, min, and mean of our 100 latest timings.
    let min = Infinity;
    let max = -Infinity;
    let sum = 0;
    for (let i = 0; i < this.frames.length; i++) {
      sum += this.frames[i];
      min = Math.min(this.frames[i], min);
      max = Math.max(this.frames[i], max);
    }
    let mean = sum / this.frames.length;

    // Render the statistics.
    this.fps.textContent = `
Frames per Second:
         latest = ${Math.round(fps)}
avg of last 100 = ${Math.round(mean)}
min of last 100 = ${Math.round(min)}
max of last 100 = ${Math.round(max)}
`.trim();
  }
};
```
-->
<pre><code class="language-js">const ips = new class {
  constructor() {
    this.ips = document.getElementById(&quot;ips&quot;);
    this.images = [];
    this.timeStampDeLaDerniereImage = performance.now();
  }

  afficher() {
    // Convertit la diffÃ©rence de temps entre la derniÃ¨re image en
    // images par seconde.
    const maintenant = performance.now();
    const difference = maintenant - this.timeStampDeLaDerniereImage;
    this.timeStampDeLaDerniereImage = maintenant;
    const ips = 1 / difference * 1000;

    // Ne conserve que les 100 derniÃ¨res images.
    this.images.push(ips);
    if (this.images.length &gt; 100) {
      this.images.shift();
    }

    // Trouve la valeur minimale, maximale, et la moyenne des
    // 100 derniÃ¨res images.
    let min = Infinity;
    let max = -Infinity;
    let somme = 0;
    for (let i = 0; i &lt; this.images.length; i++) {
      somme += this.images[i];
      min = Math.min(this.images[i], min);
      max = Math.max(this.images[i], max);
    }
    let moyenne = somme / this.images.length;

    // Affiche les statistiques.
    this.ips.textContent = `
Images Par SecondeÂ :
                           actuel = ${Math.round(ips)}
 moyenne des 100 derniÃ¨res images = ${Math.round(moyenne)}
mininima des 100 derniÃ¨res images = ${Math.round(min)}
  maxima des 100 derniÃ¨res images = ${Math.round(max)}
`.trim();
  }
};
</code></pre>
<!--
Next we call the `fps` `render` function on each iteration of `renderLoop`:
-->
<p>Ensuite, nous devons appeler la fonction <code>afficher</code> Ã  chaque itÃ©ration de
<code>boucleDeRendu</code>Â :</p>
<!--
```js
const renderLoop = () => {
    fps.render(); //new

    universe.tick();
    drawGrid();
    drawCells();

    animationId = requestAnimationFrame(renderLoop);
};
```
-->
<pre><code class="language-js">const boucleDeRendu = () =&gt; {
    ips.afficher(); //new

    univers.tick();
    dessinerGrille();
    dessinerCellules();

    animationId = requestAnimationFrame(boucleDeRendu);
};
</code></pre>
<!--
Finally, don't forget to add the `fps` element to
`wasm-game-of-life/www/index.html`, just above the `<canvas>`:
-->
<p>Enfin, n'oubliez pas d'ajouter le noeud <code>#ips</code> Ã 
<code>wasm-jeu-de-la-vie/www/index.html</code>, juste au-dessus du <code>&lt;canvas&gt;</code>Â :</p>
<!--
```html
<div id="fps"></div>
```
-->
<pre><code class="language-html">&lt;div id=&quot;ips&quot;&gt;&lt;/div&gt;
</code></pre>
<!--
And add CSS to make its formatting nice:
-->
<p>Ainsi qu'un peu de style CSS pour amÃ©liorer son renduÂ :</p>
<!--
```css
#fps {
  white-space: pre;
  font-family: monospace;
}
```
-->
<pre><code class="language-css">#ips {
  white-space: pre;
  font-family: monospace;
}
</code></pre>
<!--
And voila! Refresh [http://localhost:8080](http://localhost:8080) and now we
have an FPS counter!
-->
<p>Et voilÃ Â ! RafraÃ®chissez la page <a href="http://localhost:8080">http://localhost:8080</a>
et vous avez maintenant un compteur d'images par secondeÂ !</p>
<!--
[perf-now]: https://developer.mozilla.org/en-US/docs/Web/API/Performance/now
-->
<!--
### Time Each `Universe::tick` with `console.time` and `console.timeEnd`
-->
<h3><a class="header" href="#chronomÃ¨trer-chaque-universtick-avec-consoletime-et-consoletimeend" id="chronomÃ¨trer-chaque-universtick-avec-consoletime-et-consoletimeend">ChronomÃ¨trer chaque <code>Univers::tick</code> avec <code>console.time</code> et <code>console.timeEnd</code></a></h3>
<!--
To measure how long each invocation of `Universe::tick` takes, we can use
`console.time` and `console.timeEnd` via the `web-sys` crate.
-->
<p>Pour mesurer la durÃ©e que prends chaque appel Ã  <code>Univers::tick</code>, nous pouvons
utiliser <code>console.time</code> et <code>console.timeEnd</code> avec la crate <code>web-sys</code>.</p>
<!--
First, add `web-sys` as a dependency to `wasm-game-of-life/Cargo.toml`:
-->
<p>Pour commencer, ajoutez la dÃ©pendance <code>web-sys</code> dans
<code>wasm-jeu-de-la-vie/Cargo.toml</code>Â :</p>
<!--
```toml
[dependencies.web-sys]
version = "0.3"
features = [
  "console",
]
```
-->
<pre><code class="language-toml">[dependencies.web-sys]
version = &quot;0.3&quot;
features = [
  &quot;console&quot;,
]
</code></pre>
<!--
Because there should be a corresponding `console.timeEnd` invocation for every
`console.time` call, it is convenient to wrap them both up in an [RAII][] type:
-->
<p>Comme nous aurons un appel Ã  <code>console.timeEnd</code> correspondant Ã  chaque appel Ã 
<code>console.time</code>, il nous est plus pratique de les intÃ©grer dans un type qui
implÃ©mente le concept de <a href="https://jimskapt.github.io/rust-book-fr/ch04-01-what-is-ownership.html?highlight=RAII#m%C3%A9moire-et-allocation">RAII</a>Â :</p>
<!--
```rust
extern crate web_sys;
use web_sys::console;

pub struct Timer<'a> {
    name: &'a str,
}

impl<'a> Timer<'a> {
    pub fn new(name: &'a str) -> Timer<'a> {
        console::time_with_label(name);
        Timer { name }
    }
}

impl<'a> Drop for Timer<'a> {
    fn drop(&mut self) {
        console::time_end_with_label(self.name);
    }
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;
use web_sys::console;

pub struct Chronometre&lt;'a&gt; {
    nom: &amp;'a str,
}

impl&lt;'a&gt; Chronometre&lt;'a&gt; {
    pub fn new(nom: &amp;'a str) -&gt; Chronometre&lt;'a&gt; {
        console::time_with_label(nom);
        Chronometre { nom }
    }
}

impl&lt;'a&gt; Drop for Chronometre&lt;'a&gt; {
    fn drop(&amp;mut self) {
        console::time_end_with_label(self.nom);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Then, we can time how long each `Universe::tick` takes by adding this snippet to
the top of the method:
-->
<p>Maintenant, nous pouvons chronomÃ©trer le temps que prend <code>Univers::tick</code> en
ajoutant ceci en haut de la mÃ©thodeÂ :</p>
<!--
```rust
let _timer = Timer::new("Universe::tick");
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _chronometre = Chronometre::new(&quot;Univers::tick&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
The time of how long each call to `Universe::tick` took are now logged in the
console:
-->
<p>La durÃ©e de chaque appel Ã  <code>Univers::tick</code> est maintenant affichÃ©e dans la
consoleÂ :</p>
<!-- markdownlint-disable -->
<!--
[![Screenshot of console.time logs](../images/game-of-life/console-time.png)](../images/game-of-life/console-time.png)
-->
<!-- markdownlint-enable -->
<p><a href="game-of-life/../images/game-of-life/console-time.png"><img src="game-of-life/../images/game-of-life/console-time.png" alt="Capture d'Ã©cran des journaux de console.time" /></a></p>
<!-- markdownlint-disable -->
<!--
Additionally, `console.time` and `console.timeEnd` pairs will show up in your
browser's profiler's "timeline" or "waterfall" view:
pp
[![Screenshot of console.time logs](../images/game-of-life/console-time-in-profiler.png)](../images/game-of-life/console-time-in-profiler.png)
-->
<!-- markdownlint-enable -->
<p>De plus, les coupes de <code>console.time</code> et de <code>console.timeEnd</code> vont Ãªtre mis en
Ã©vidence dans la vue &quot;timeline&quot; ou &quot;chronologie&quot; du profileur du navigateurÂ :</p>
<p><a href="game-of-life/../images/game-of-life/console-time-in-profiler.png"><img src="game-of-life/../images/game-of-life/console-time-in-profiler.png" alt="Capture d'Ã©cran des journaux de console.time" /></a></p>
<!--
[RAII]: https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization
-->
<!--
## Growing our Game of Life Universe
-->
<h2><a class="header" href="#agrandir-lunivers-de-notre-jeu-de-la-vie" id="agrandir-lunivers-de-notre-jeu-de-la-vie">Agrandir l'univers de notre jeu de la vie</a></h2>
<!--
> âš ï¸ This section utilizes example screenshots from Firefox. While all modern
> browsers have similar tools, there might be slight nuances to working with
> different developer tools. The profile information you extract will be
> essentially the same, but your mileage might vary in terms of the views you
> see and the naming of different tools.
-->
<blockquote>
<p>âš ï¸ Cette section utilise des captures d'Ã©cran de Firefox comme exemples. Bien
que tous les navigateurs ont des outils qui se ressemblent, il peut y avoir
quelques petites diffÃ©rences lorsque vous travaillez avec des outils de
dÃ©veloppements diffÃ©rents. Les informations du profilage que vous allez
rÃ©cupÃ©rer sera gÃ©nÃ©ralement le mÃªme, mais sa reprÃ©sentation peut changer en
fonction des vues des diffÃ©rents outils que vous aurez et leur faÃ§on de nommer
les choses.</p>
</blockquote>
<!--
What happens if we make our Game of Life universe larger? Replacing the 64 by 64
universe with a 128 by 128 universe (by modifying `Universe::new` in
`wasm-game-of-life/src/lib.rs`) results in FPS dropping from a smooth 60 to a
choppy 40-ish on my machine.
-->
<p>Que va-t-il se passer si nous agrandissons l'univers de notre jeu de la vie ?
Remplacer l'univers de 64 par 64 par un univers de 128 par 128 (en modifiant
<code>Univers::new</code> dans <code>wasm-jeu-de-la-vie/src/lib.rs</code>) va rÃ©duire drastiquement
les images par seconde de 60 ips fluide Ã  un 40 ips trouble sur certaines
machines.</p>
<!--
If we record a profile and look at the waterfall view, we see that each
animation frame is taking over 20 milliseconds. Recall that 60 frames per second
leaves sixteen milliseconds for the whole process of rendering a frame. That's
not just our JavaScript and WebAssembly, but also everything else the browser is
doing, such as painting.
-->
<p>Si nous gÃ©nÃ©rons un profilage et regardons la vue &quot;chronologie&quot;, nous pouvons
constater que chaque image de l'animation prend plus de 20 millisecondes de
calcul. Retenez que 60 images par seconde signifie qu'il se passe environ 16
millisecondes entre chaque image. Cela ne s'applique pas uniquement aux calculs
du JavaScript et du WebAssembly, mais aussi Ã  tout ce que le navigateur fait
d'autre pendant ce temps, comme le rendu et l'affichage Ã  l'Ã©cran.</p>
<!-- markdownlint-disable -->
<!--
[![Screenshot of a waterfall view of rendering a frame](../images/game-of-life/drawCells-before-waterfall.png)](../images/game-of-life/drawCells-before-waterfall.png)
-->
<!-- markdownlint-enable -->
<p><a href="game-of-life/../images/game-of-life/drawCells-before-waterfall.png"><img src="game-of-life/../images/game-of-life/drawCells-before-waterfall.png" alt="Capture d'Ã©cran de la vue chronologie du rendu d'une image" /></a></p>
<!--
If we look at what happens within a single animation frame, we see that the
`CanvasRenderingContext2D.fillStyle` setter is very expensive!
-->
<p>Si nous analysons ce qui se passe Ã  chaque image de l'animation, on peut voir
que le mutateur <code>CanvasRenderingContext2D.fillStyle</code> prend beaucoup de tempsÂ !</p>
<!-- markdownlint-disable -->
<!--
> âš ï¸ In Firefox, if you see a line that simply says "DOM" instead of the
> `CanvasRenderingContext2D.fillStyle` mentioned above, you may need to turn on
> the option for "Show Gecko Platform Data" in your performance developer tools
> options:
>
> [![Turning on Show Gecko Platform Data](../images/game-of-life/profiler-firefox-show-gecko-platform.png)](../images/game-of-life/profiler-firefox-show-gecko-platform.png)
-->
<!-- markdownlint-enable -->
<blockquote>
<p>âš ï¸ Dans Firefox, si vous voyez une ligne qui dit simplement &quot;DOM&quot; au lieu du
<code>canvasRenderingContext2D.filleStyle</code> que nous avons mentionnÃ© prÃ©cÃ©demment,
vous devriez activer l'option &quot;Afficher les donnÃ©es de la plate-forme Gecko&quot;
dans les options de vos outils de dÃ©veloppementÂ :</p>
<p><a href="game-of-life/../images/game-of-life/profiler-firefox-show-gecko-platform.png"><img src="game-of-life/../images/game-of-life/profiler-firefox-show-gecko-platform.png" alt="Activation de l'option afficher les donnÃ©es de la plate-forme Gecko" /></a></p>
</blockquote>
<!-- markdownlint-disable -->
<!--
[![Screenshot of a flamegraph view of rendering a frame](../images/game-of-life/drawCells-before-flamegraph.png)](../images/game-of-life/drawCells-before-flamegraph.png)
-->
<!-- markdownlint-enable -->
<p><a href="game-of-life/../images/game-of-life/drawCells-before-flamegraph.png"><img src="game-of-life/../images/game-of-life/drawCells-before-flamegraph.png" alt="Capture d'Ã©cran d'une vue flamegraph du rendu d'une image" /></a></p>
<!--
And we can confirm that this isn't an abnormality by looking at the call tree's
aggregation of many frames:
-->
<p>Et nous pouvons confirmer que ce n'est pas une anomalie en analysant
l'agrÃ©gation de l'arbre d'appels de plusieurs imagesÂ :</p>
<!-- markdownlint-disable -->
<!--
[![Screenshot of a flamegraph view of rendering a frame](../images/game-of-life/drawCells-before-calltree.png)](../images/game-of-life/drawCells-before-calltree.png)
-->
<!-- markdownlint-enable -->
<p><a href="game-of-life/../images/game-of-life/drawCells-before-calltree.png"><img src="game-of-life/../images/game-of-life/drawCells-before-calltree.png" alt="Capture d'Ã©cran d'une vue flamegraph du rendu d'une image" /></a></p>
<!--
Nearly 40% of our time is spent in this setter!
-->
<p>On passe presque 40% du temps dans ce mutateurÂ !</p>
<!--
> âš¡ We might have expected something in the `tick` method to be the performance
> bottleneck, but it wasn't. Always let profiling guide your focus, since time
> may be spent in places you don't expect it to be.
-->
<blockquote>
<p>âš¡ Nous pourrions nous attendre Ã  ce que la mÃ©thode <code>tick</code> explique la perte
de performances, mais ce n'est pas le cas. Ayez toujours le rÃ©flexe d'utiliser
le profileur pour orienter vos efforts, autrement vous risquez de perdre votre
temps Ã  optimiser des parties qui sont nÃ©gligeables en terme de performance.</p>
</blockquote>
<!--
In the `drawCells` function in `wasm-game-of-life/www/index.js`, the `fillStyle`
property is set once for every cell in the universe, on every animation frame:
-->
<p>Dans la fonction <code>dessinerCellules</code> de <code>wasm-jeu-de-la-vie/www/index.js</code>, la
propriÃ©tÃ© <code>fillStyle</code> est dÃ©finie pour chaque cellule de l'univers, Ã  chaque
image de l'animation.</p>
<!--
```js
for (let row = 0; row < height; row++) {
  for (let col = 0; col < width; col++) {
    const idx = getIndex(row, col);

    ctx.fillStyle = cells[idx] === DEAD
      ? DEAD_COLOR
      : ALIVE_COLOR;

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
```
-->
<pre><code class="language-js">for (let ligne = 0; ligne &lt; hauteur; ligne++) {
  for (let colonne = 0; colonne &lt; largeur; colonne++) {
    const indice = calculerIndice(ligne, colonne);

    ctx.fillStyle = cellules[indice] === Cellule.Morte
      ? COULEUR_MORTE
      : COULEUR_VIVANTE;

    ctx.fillRect(
      colonne * (TAILLE_CELLULE + 1) + 1,
      ligne * (TAILLE_CELLULE + 1) + 1,
      TAILLE_CELLULE,
      TAILLE_CELLULE
    );
  }
}
</code></pre>
<!--
Now that we have discovered that setting `fillStyle` is so expensive, what can
we do to avoid setting it so often? We need to change `fillStyle` depending on
whether a cell is alive or dead. If we set `fillStyle = ALIVE_COLOR` and then
draw every alive cell in one pass, and then set `fillStyle = DEAD_COLOR` and
draw every dead cell in another pass, then we only end setting `fillStyle`
twice, rather than once for every cell.
-->
<p>Maintenant que nous avons dÃ©couvert qu'utiliser <code>fillStyle</code> est trÃ¨s
chronophage, qu'est-ce que nous pouvons faire pour Ã©viter de l'utiliser aussi
souventÂ ? Nous devons changer <code>fillStyle</code> si une cellule est vivante ou morte.
Si nous faisons en sorte que <code>fillStyle = COULEUR_VIVANTE</code> et que nous dessinons
ensuite toutes les cellules vivantes en une seule fois sur une premiÃ¨re passe,
et que nous faisons ensuite en sorte que <code>fillStyle = COULEUR_MORTE</code> puis que
nous dessinons toutes les cellules mortes en une deuxiÃ¨me passe, alors nous
utilisons <code>fillStyle</code> seulement deux fois, plutÃ´t qu'une fois sur chaque
cellule.</p>
<!--
```js
// Alive cells.
ctx.fillStyle = ALIVE_COLOR;
for (let row = 0; row < height; row++) {
  for (let col = 0; col < width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Alive) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}

// Dead cells.
ctx.fillStyle = DEAD_COLOR;
for (let row = 0; row < height; row++) {
  for (let col = 0; col < width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Dead) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
```
-->
<pre><code class="language-js">// Cellules vivantes.
ctx.fillStyle = COULEUR_VIVANTE;
for (let ligne = 0; ligne &lt; hauteur; ligne++) {
  for (let colonne = 0; colonne &lt; largeur; colonne++) {
    const indice = calculerIndice(ligne, colonne);
    if (cellules[indice] !== Cellule.Vivante) {
      continue;
    }

    ctx.fillRect(
      colonne * (TAILLE_CELLULE + 1) + 1,
      ligne * (TAILLE_CELLULE + 1) + 1,
      TAILLE_CELLULE,
      TAILLE_CELLULE
    );
  }
}

// Cellules mortes.
ctx.fillStyle = COULEUR_MORTE;
for (let ligne = 0; ligne &lt; hauteur; ligne++) {
  for (let colonne = 0; colonne &lt; largeur; colonne++) {
    const indice = calculerIndice(ligne, colonne);
    if (cellules[indice] !== Cellule.Morte) {
      continue;
    }

    ctx.fillRect(
      colonne * (TAILLE_CELLULE + 1) + 1,
      ligne * (TAILLE_CELLULE + 1) + 1,
      TAILLE_CELLULE,
      TAILLE_CELLULE
    );
  }
}
</code></pre>
<!--
After saving these changes and refreshing
[http://localhost:8080/](http://localhost:8080/), rendering is back to a smooth
60 frames per second.
-->
<p>AprÃ¨s avoir sauvegardÃ© ces changements et rafraÃ®chi
<a href="http://localhost:8080/">http://localhost:8080/</a>, le rendu est Ã  nouveau fluide
Ã  60 images par secondes.</p>
<!--
If we take another profile, we can see that only about ten milliseconds are
spent in each animation frame now.
-->
<p>Si nous gÃ©nÃ©rons un nouveau profilage, nous pouvons constater que maintenant
seulement 10 millisecondes se passent entre chaque image.</p>
<!-- markdownlint-disable -->
<!--
[![Screenshot of a waterfall view of rendering a frame after the drawCells changes](../images/game-of-life/drawCells-after-waterfall.png)](../images/game-of-life/drawCells-after-waterfall.png)
-->
<!-- markdownlint-enable -->
<p><a href="game-of-life/../images/game-of-life/drawCells-after-waterfall.png"><img src="game-of-life/../images/game-of-life/drawCells-after-waterfall.png" alt="Capture d'Ã©cran de la vue chronologie du rendu d'une image aprÃ¨s les modifications sur dessinerCellules" /></a></p>
<!--
Breaking down a single frame, we see that the `fillStyle` cost is gone, and most
of our frame's time is spent within `fillRect`, drawing each cell's rectangle.
-->
<p>En dÃ©composant image par image, on constate que cette utilisation de <code>fillStyle</code>
n'a plus de impact lourd, et que la plupart du temps de calcul de notre image se
passe dans <code>fillRect</code>, qui dessine le rectangle de chaque cellule.</p>
<!-- markdownlint-disable -->
<!--
[![Screenshot of a flamegraph view of rendering a frame after the drawCells changes](../images/game-of-life/drawCells-after-flamegraph.png)](../images/game-of-life/drawCells-after-flamegraph.png)
-->
<!-- markdownlint-enable -->
<p><a href="game-of-life/../images/game-of-life/drawCells-after-flamegraph.png"><img src="game-of-life/../images/game-of-life/drawCells-after-flamegraph.png" alt="Capture d'Ã©cran d'une vue flamegraph du rendu aprÃ¨s les changements apportÃ©s Ã  dessinerCellules" /></a></p>
<!--
## Making Time Run Faster
-->
<h2><a class="header" href="#faire-en-sorte-que-le-temps-saccÃ©lÃ¨re" id="faire-en-sorte-que-le-temps-saccÃ©lÃ¨re">Faire en sorte que le temps s'accÃ©lÃ¨re</a></h2>
<!--
Some folks don't like waiting around, and would prefer if instead of one tick of
the universe occurred per animation frame, nine ticks did. We can modify the
`renderLoop` function in `wasm-game-of-life/www/index.js` to do this quite
easily:
-->
<p>Certaines personnes n'aiment pas attendre, et prÃ©fÃ¨rent qu'au lieu d'un seul
tick de l'univers se dÃ©roule Ã  chaque image de l'animation, il se passe neuf
ticks. Nous pouvons modifier la fonction <code>boucleDeRendu</code> dans
<code>wasm-jeu-de-la-vie/www/index.js</code> pour implÃ©menter cela facilementÂ :</p>
<!--
```js
for (let i = 0; i < 9; i++) {
  universe.tick();
}
```
-->
<pre><code class="language-js">for (let i = 0; i &lt; 9; i++) {
  univers.tick();
}
</code></pre>
<!--
On my machine, this brings us back down to only 35 frames per second. No
good. We want that buttery 60!
-->
<p>Sur certaines machines, cela nous ralentit Ã  seulement 35 images par secondes.
Ce n'est pas bon, nous voulons en avoir 60Â !</p>
<!--
Now we know that time is being spent in `Universe::tick`, so let's add some
`Timer`s to wrap various bits of it in `console.time` and `console.timeEnd`
calls, and see where that leads us. My hypothesis is that allocating a new
vector of cells and freeing the old vector on every tick is costly, and taking
up a significant portion of our time budget.
-->
<p>Nous savons maintenant que le calcul de <code>Univers::tick</code> prend plus de temps,
donc nous allons ajouter quelques chronomÃ¨tres pour couvrir certaines de ses
parties avec les appels Ã  <code>console.time</code> et <code>console.timeEnd</code> pour voir ce que
cela peut nous apprendre. Notre hypothÃ¨se est que l'allocation d'un nouveau
vecteur de cellules et le nettoyage de l'ancien vecteur Ã  chaque tick est
coÃ»teux, et nous impute d'une partie importante de notre enveloppe de temps.</p>
<!--
```rust
pub fn tick(&mut self) {
    let _timer = Timer::new("Universe::tick");

    let mut next = {
        let _timer = Timer::new("allocate next cells");
        self.cells.clone()
    };

    {
        let _timer = Timer::new("new generation");
        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x < 2 => Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x > 3 => Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) => Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) => otherwise,
                };

                next[idx] = next_cell;
            }
        }
    }

    let _timer = Timer::new("free old cells");
    self.cells = next;
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn tick(&amp;mut self) {
    let _chronometre = Chronometre::new(&quot;Univers::tick&quot;);

    let mut generation_suivante = {
        let _chronometre = Chronometre::new(&quot;crÃ©ation cellules prochaine gÃ©nÃ©ration&quot;);
        self.cellules.clone()
    };

    {
        let _chronometre = Chronometre::new(&quot;calcul nouvelle gÃ©nÃ©ration&quot;);
        for ligne in 0..self.hauteur {
            for colonne in 0..self.largeur {
                let indice = self.calculer_indice(ligne, colonne);
                let cellule = self.cellules[indice];
                let voisines_vivantes = self.compter_voisines_vivantes(ligne, colonne);

                let prochain_etat = match (cellule, voisines_vivantes) {
                    // RÃ¨gle 1 : toute cellule vivante avec moins de deux
                    // voisines vivantes meurt, comme si cela Ã©tait un effet de
                    //  sous-population.
                    (Cellule::Vivante, x) if x &lt; 2 =&gt; Cellule::Morte,
                    // RÃ¨gle 2 : toute cellule vivante avec deux ou trois
                    // voisines vivantes survit jusqu'Ã  la prochaine gÃ©nÃ©ration.
                    (Cellule::Vivante, 2) | (Cellule::Vivante, 3) =&gt; Cellule::Vivante,
                    // RÃ¨gle 3 : toute cellule vivante avec plus de trois
                    // voisines vivantes meurt, comme si cela Ã©tait un effet de
                    // surpopulation.
                    (Cellule::Vivante, x) if x &gt; 3 =&gt; Cellule::Morte,
                    // RÃ¨gle 4 : toute cellule morte avec exactement trois
                    // voisines vivantes devient une cellule vivante, comme si
                    // cela Ã©tait un effet de reproduction.
                    (Cellule::Morte, 3) =&gt; Cellule::Vivante,
                    // Les cellules qui ne rÃ©pondent Ã  aucune de ces conditions
                    // restent dans le mÃªme Ã©tat.
                    (statut, _) =&gt; statut,
                };

                generation_suivante[indice] = prochain_etat;
            }
        }
    }

    let _chronometre = Chronometre::new(&quot;nettoyage des anciennes cellules&quot;);
    self.cellules = generation_suivante;
}
<span class="boring">}
</span></code></pre></pre>
<!--
Looking at the timings, it is clear that my hypothesis is incorrect: the vast
majority of time is spent actually calculating the next generation of
cells. Allocating and freeing a vector on every tick appears to have negligible
cost, surprisingly. Another reminder to always guide our efforts with profiling!
-->
<p>Vu les rÃ©sultats des chronomÃ¨tres, il est clair que notre hypothÃ¨se est
incorrecteÂ : l'Ã©crasante majoritÃ© du temps est consacrÃ© Ã  calculer la prochaine
gÃ©nÃ©ration des cellules. L'allocation et le nettoyage d'un vecteur Ã  chaque tick
est un coÃ»t nÃ©gligeable, contre toute attente. VoilÃ  une bonne raison de
toujours orienter vos efforts avec le profilageÂ !</p>
<!-- markdownlint-disable -->
<!--
[![Screenshot of a Universe::tick timer results](../images/game-of-life/console-time-in-universe-tick.png)](../images/game-of-life/console-time-in-universe-tick.png)
-->
<!-- markdownlint-enable -->
<p><a href="game-of-life/../images/game-of-life/console-time-in-universe-tick.png"><img src="game-of-life/../images/game-of-life/console-time-in-universe-tick.png" alt="Capture d'Ã©cran des rÃ©sultats du chronomÃ¨tre Univers::tick" /></a></p>
<!-- markdownlint-disable -->
<!--
The next section requires the `nightly` compiler. It's required because of
the [test feature gate](https://doc.rust-lang.org/unstable-book/library-features/test.html)
we're going to use for the benchmarks. Another tool we will install is [cargo benchcmp][benchcmp].
It's a small utility for comparing micro-benchmarks produced by `cargo bench`.
-->
<!-- markdownlint-enable -->
<!--
[benchcmp]: https://github.com/BurntSushi/cargo-benchcmp
-->
<!--
Let's write a native code `#[bench]` doing the same thing that our WebAssembly
is doing, but where we can use more mature profiling tools. Here is the new
`wasm-game-of-life/benches/bench.rs`:
-->
<p>Ecrivons un code natif avec <code>#[bench]</code> qui fait les mÃªmes choses que notre
WebAssembly, mais oÃ¹ nous pouvons utiliser des outils de profilage plus mÃ¢tures.
Voici le nouveau fichier <code>wasm-jeu-de-la-vie/benches/bench.rs</code>Â :</p>
<!--
```rust
#![feature(test)]

extern crate test;
extern crate wasm_game_of_life;

#[bench]
fn universe_ticks(b: &mut test::Bencher) {
    let mut universe = wasm_game_of_life::Universe::new();

    b.iter(|| {
        universe.tick();
    });
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(test)]

<span class="boring">fn main() {
</span>extern crate test;
extern crate wasm_jeu_de_la_vie;

#[bench]
fn ticks_univers(b: &amp;mut test::Bencher) {
    let mut univers = wasm_jeu_de_la_vie::Univers::new();

    b.iter(|| {
        univers.tick();
    });
}
<span class="boring">}
</span></code></pre></pre>
<!--
We also have to comment out all the `#[wasm_bindgen]` annotations, and the
`"cdylib"` bits from `Cargo.toml` or else building native code will fail and
have link errors.
-->
<p>Nous devons Ã©galement commenter toutes les annotations <code>#[wasm_bindgen]</code>, et les
parties <code>&quot;cdylib&quot;</code> dans le <code>Cargo.toml</code>, car sinon la compilation du code natif
va Ã©chouer et aura des erreurs de liaisons avec des bibliothÃ¨ques.</p>
<!-- markdownlint-disable -->
<!--
With all that in place, we can run `cargo bench | tee before.txt` to compile and run our
benchmark! The `| tee before.txt` part will take the output from `cargo bench` and put in a file
called `before.txt`.
-->
<!-- markdownlint-enable -->
<p>Une fois ceci en place, nous pouvons exÃ©cuter <code>cargo bench | tee avant.txt</code> pour
compiler et exÃ©cuter notre comparatifÂ ! La partie <code>| tee avant.txt</code> va rÃ©cupÃ©rer
la sortie de <code>cargo bench</code> et l'Ã©crire dans le fichier <code>avant.txt</code>.</p>
<!--
```
$ cargo bench | tee before.txt
    Finished release [optimized + debuginfo] target(s) in 0.0 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:     664,421 ns/iter (+/- 51,926)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
```
-->
<pre><code class="language-txt">$ cargo bench | tee avant.txt
    Finished release [optimized + debuginfo] target(s) in 0.0 secs
     Running target/release/deps/wasm_jeu_de_la_vie-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test ticks_univers ... bench:     664,421 ns/iter (+/- 51,926)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<!--
This also tells us where the binary lives, and we can run the benchmarks again,
but this time under our operating system's profiler. In my case, I'm running
Linux, so [`perf`][perf] is the profiler I'll use:
-->
<p>Cela va aussi nous indiquer oÃ¹ est le binaire, et nous pourrons Ã  nouveau
exÃ©cuter le comparatif, mais cette fois avec le profileur de notre systÃ¨me
d'exploitation. Dans notre cas, nous l'exÃ©cutons sous Linux, donc nous allons
utiliser <a href="https://perf.wiki.kernel.org/index.php/Main_Page"><code>perf</code></a>Â :</p>
<!--
[perf]: https://perf.wiki.kernel.org/index.php/Main_Page
-->
<!--
```
$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench
running 1 test
test universe_ticks ... bench:     635,061 ns/iter (+/- 38,764)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out

[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]
```
-->
<pre><code class="language-txt">$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench
running 1 test
test ticks_univers ... bench:     635,061 ns/iter (+/- 38,764)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out

[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]
</code></pre>
<!--
Loading up the profile with `perf report` shows that all of our time is spent in
`Universe::tick`, as expected:
-->
<p>L'ouverture du profil avec <code>perf report</code> nous montre que tout le temps est passÃ©
dans <code>Univers::tick</code>, comme nous nous y attendionsÂ :</p>
<!-- markdownlint-disable -->
<!--
[![Screenshot of perf report](../images/game-of-life/bench-perf-report.png)](../images/game-of-life/bench-perf-report.png)
-->
<!-- markdownlint-enable -->
<p><a href="game-of-life/../images/game-of-life/bench-perf-report.png"><img src="game-of-life/../images/game-of-life/bench-perf-report.png" alt="Capture d'Ã©cran de perf report" /></a></p>
<!--
`perf` will annotate which instructions in a function time is being spent at if
you press `a`:
-->
<p><code>perf</code> va annoter quel temp est passÃ© dans chaque instruction si vous appuyez
sur <code>a</code>Â :</p>
<!-- markdownlint-disable -->
<!--
[![Screenshot of perf's instruction annotation](../images/game-of-life/bench-perf-annotate.png)](../images/game-of-life/bench-perf-annotate.png)
-->
<!-- markdownlint-enable -->
<p><a href="game-of-life/../images/game-of-life/bench-perf-annotate.png"><img src="game-of-life/../images/game-of-life/bench-perf-annotate.png" alt="Capture d'Ã©cran de l'annotation d'instruction de perf" /></a></p>
<!--
This tells us that 26.67% of time is being spent summing neighboring cells'
values, 23.41% of time is spent getting the neighbor's column index, and another
15.42% of time is spent getting the neighbor's row index. Of these top three
most expensive instructions, the second and third are both costly `div`
instructions. These `div`s implement the modulo indexing logic in
`Universe::live_neighbor_count`.
-->
<p>On apprend donc que 26.67% du temps est passÃ© au comptage des cellules voisines,
que 23.41% du temps est consacrÃ© Ã  calculer l'indice de la colonne
correspondante Ã  la cellule voisine, et que 15.42% du temps en plus est passÃ© Ã 
obtenir l'indice de la ligne de la voisine. Parmi ces trois instructions
coÃ»teuses, la seconde et la troisiÃ¨me sont des instructions <code>div</code> (pour
division) assez coÃ»teuses. Ces divisions sont implÃ©mentÃ©es dans la logique
d'indexation faisant appel aux modulos, dans
<code>Univers::compter_voisines_vivantes</code>.</p>
<!--
Recall the `live_neighbor_count` definition inside
`wasm-game-of-life/src/lib.rs`:
-->
<p>Souvenez-vous de la dÃ©finition de <code>compter_voisines_vivantes</code> dans
<code>wasm-jeu-de-la-vie/src/lib.rs</code>Â :</p>
<!--
```rust
fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {
    let mut count = 0;
    for delta_row in [self.height - 1, 0, 1].iter().cloned() {
        for delta_col in [self.width - 1, 0, 1].iter().cloned() {
            if delta_row == 0 && delta_col == 0 {
                continue;
            }

            let neighbor_row = (row + delta_row) % self.height;
            let neighbor_col = (column + delta_col) % self.width;
            let idx = self.get_index(neighbor_row, neighbor_col);
            count += self.cells[idx] as u8;
        }
    }
    count
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compter_voisines_vivantes(&amp;self, ligne: u32, colonne: u32) -&gt; u8 {
    let mut compteur = 0;
    for delta_ligne in [self.hauteur - 1, 0, 1].iter().cloned() {
        for delta_colonne in [self.largeur - 1, 0, 1].iter().cloned() {
            if delta_ligne == 0 &amp;&amp; delta_colonne == 0 {
                continue;
            }

            let ligne_voisine = (ligne + delta_ligne) % self.hauteur;
            let colonne_voisine = (colonne + delta_colonne) % self.largeur;
            let indice = self.calculer_indice(ligne_voisine, colonne_voisine);
            compteur += self.cellules[indice] as u8;
        }
    }
    compteur
}
<span class="boring">}
</span></code></pre></pre>
<!--
The reason we used modulo was to avoid cluttering up the code with `if` branches
for the first or last row or column edge cases. But we are paying the cost of a
`div` instruction even for the most common case, when neither `row` nor `column`
is on the edge of the universe and they don't need the modulo wrapping
treatment. Instead, if we use `if`s for the edge cases and unroll this loop, the
branches *should* be very well-predicted by the CPU's branch predictor.
-->
<p>La raison pour laquelle nous avions utilisÃ© le modulo Ã©tait d'Ã©viter d'encombrer
le code avec des branches <code>if</code> pour gÃ©rer les cas des bords des premiÃ¨res lignes
et colonnes. Mais nous payons le prix de l'utilisation des instructions de
division mÃªme pour les cas les plus courants, c'est-Ã -dire lorsque ni <code>ligne</code>,
ni la <code>colonne</code> ne se trouvent pas sur les bords de l'univers et n'ont pas
besoin du traitement du rebouclage avec le modulo. Mais si Ã  la place nous
utilisons des <code>if</code> pour dÃ©tecter les cas des bordures et dÃ©rouler cette boucle,
les branches <em>devraient</em> Ãªtre bien apprÃ©hendÃ©es par le prÃ©dicteur de branches du
CPU.</p>
<!--
Let's rewrite `live_neighbor_count` like this:
-->
<p>RÃ©-Ã©crivons <code>compter_voisines_vivantes</code> de cette maniÃ¨reÂ :</p>
<!--
```rust
fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {
    let mut count = 0;

    let north = if row == 0 {
        self.height - 1
    } else {
        row - 1
    };

    let south = if row == self.height - 1 {
        0
    } else {
        row + 1
    };

    let west = if column == 0 {
        self.width - 1
    } else {
        column - 1
    };

    let east = if column == self.width - 1 {
        0
    } else {
        column + 1
    };

    let nw = self.get_index(north, west);
    count += self.cells[nw] as u8;

    let n = self.get_index(north, column);
    count += self.cells[n] as u8;

    let ne = self.get_index(north, east);
    count += self.cells[ne] as u8;

    let w = self.get_index(row, west);
    count += self.cells[w] as u8;

    let e = self.get_index(row, east);
    count += self.cells[e] as u8;

    let sw = self.get_index(south, west);
    count += self.cells[sw] as u8;

    let s = self.get_index(south, column);
    count += self.cells[s] as u8;

    let se = self.get_index(south, east);
    count += self.cells[se] as u8;

    count
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compter_voisines_vivantes(&amp;self, ligne: u32, colonne: u32) -&gt; u8 {
    let mut compteur = 0;

    let nord = if ligne == 0 {
        self.hauteur - 1
    } else {
        ligne - 1
    };

    let sud = if ligne == self.hauteur - 1 {
        0
    } else {
        ligne + 1
    };

    let ouest = if colonne == 0 {
        self.largeur - 1
    } else {
        colonne - 1
    };

    let est = if colonne == self.largeur - 1 {
        0
    } else {
        colonne + 1
    };

    let no = self.calculer_indice(nord, ouest);
    compteur += self.cellules[no] as u8;

    let n = self.calculer_indice(nord, colonne);
    compteur += self.cellules[n] as u8;

    let ne = self.calculer_indice(nord, est);
    compteur += self.cellules[ne] as u8;

    let o = self.calculer_indice(ligne, ouest);
    compteur += self.cellules[o] as u8;

    let e = self.calculer_indice(ligne, est);
    compteur += self.cellules[e] as u8;

    let so = self.calculer_indice(sud, ouest);
    compteur += self.cellules[so] as u8;

    let s = self.calculer_indice(sud, colonne);
    compteur += self.cellules[s] as u8;

    let se = self.calculer_indice(sud, est);
    compteur += self.cellules[se] as u8;

    compteur
}
<span class="boring">}
</span></code></pre></pre>
<!--
Now let's run the benchmarks again! This time output it to `after.txt`.
-->
<p>LanÃ§ons Ã  nouveau les comparatifsÂ ! Et cette fois nous allons l'enregistrer dans
<code>apres.txt</code>.</p>
<!--
```
$ cargo bench | tee after.txt
   Compiling wasm_game_of_life v0.1.0 (file:///home/fitzgen/wasm_game_of_life)
    Finished release [optimized + debuginfo] target(s) in 0.82 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:      87,258 ns/iter (+/- 14,632)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
```
-->
<pre><code class="language-txt">$ cargo bench | tee apres.txt
   Compiling wasm_jeu_de_la_vie v0.1.0 (file:///home/fitzgen/wasm_jeu_de_la_vie)
    Finished release [optimized + debuginfo] target(s) in 0.82 secs
     Running target/release/deps/wasm_jeu_de_la_vie-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test ticks_univers ... bench:      87,258 ns/iter (+/- 14,632)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<!-- markdownlint-disable -->
<!--
That looks a whole lot better! We can see just how much better it is with the `benchcmp` tool and the two text files we created before:
-->
<!-- markdownlint-enable -->
<p>On dirait que cela a fait du bienÂ ! Nous pouvons constater les amÃ©liorations
grÃ¢ce Ã  l'outil <code>benchcmp</code> et des deux fichiers texte que nous avons crÃ©Ã©
prÃ©cÃ©demmentÂ :</p>
<!-- markdownlint-disable -->
<!--
```
$ cargo benchcmp before.txt after.txt
 name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup
 universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61
```
-->
<!-- markdownlint-enable -->
<pre><code class="language-txt">$ cargo benchcmp avant.txt apres.txt
 name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup
 universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61
</code></pre>
<!--
Wow! 7.61x speed up!
-->
<p>OuahÂ ! C'est 7.61 fois plus rapideÂ !</p>
<!--
WebAssembly intentionally maps closely to common hardware architectures, but we
do need to make sure that this native code speed up translates into a
WebAssembly speed up as well.
-->
<p>Le WebAssembly aspire Ã  ressembler au plus aux architectures matÃ©rielles les
plus courantes, mais nous devons nous assurer que ces amÃ©liorations des
performances s'appliquent aussi au WebAssembly.</p>
<!--
Let's rebuild the `.wasm` with `wasm-pack build` and refresh
[http://localhost:8080/](http://localhost:8080/). On my machine, the page is
running at 60 frames per second again, and recording another profile with the
browser's profiler reveals that each animation frame is taking about ten
milliseconds.
-->
<p>Recompilons le <code>.wasm</code> avec <code>wasm-pack build</code> et rafraÃ®chissons
<a href="http://localhost:8080/">http://localhost:8080/</a>. Sur certaines machines, cette
page s'exÃ©cute Ã  nouveau Ã  60 images par secondes, et l'enregistrement d'un
nouveau profil avec le profileur du navigateur dans ce cas nous apprendra que
chaque image de l'animation se calcule en environ dix millisecondes.</p>
<!--
Success!
-->
<p>VictoireÂ !</p>
<!-- markdownlint-disable -->
<!--
[![Screenshot of a waterfall view of rendering a frame after replacing modulos with branches](../images/game-of-life/waterfall-after-branches-and-unrolling.png)](../images/game-of-life/waterfall-after-branches-and-unrolling.png)
-->
<!-- markdownlint-enable -->
<p><a href="game-of-life/../images/game-of-life/waterfall-after-branches-and-unrolling.png"><img src="game-of-life/../images/game-of-life/waterfall-after-branches-and-unrolling.png" alt="Capture d'Ã©cran de la vue waterfall du rendu d'une image aprÃ¨s avoir remplacÃ© les modulos par des branches" /></a></p>
<!--
## Exercises
-->
<h2><a class="header" href="#exercices-4" id="exercices-4">Exercices</a></h2>
<!--
* At this point, the next lowest hanging fruit for speeding up `Universe::tick`
  is removing the allocation and free. Implement double buffering of cells,
  where the `Universe` maintains two vectors, never frees either of them, and
  never allocates new buffers in `tick`.
-->
<ul>
<li>A ce stade, l'optimisation la plus accessible pour <code>Univers::tick</code> est
d'enlever l'allocation et la libÃ©ration en mÃ©moire. Pour cela, implÃ©mentez le
<em>double buffering</em> des cellules, avec lequel <code>Univers</code> contient deux vecteurs,
qui ne seront jamais libÃ©rÃ©s, et n'alloue jamais de nouveaux tampons dans la
fonction <code>tick</code>.</li>
</ul>
<!--
* Implement the alternative, delta-based design from the "Implementing Life"
  chapter, where the Rust code returns a list of cells that changed states to
  JavaScript. Does this make rendering to `<canvas>` faster? Can you implement
  this design without allocating a new list of deltas on every tick?
-->
<ul>
<li>Essayez d'implÃ©menter une alternative, un concept du chapitre &quot;ImplÃ©menter le
jeu de la vie de Conway&quot;, basÃ© sur les diffÃ©rences, dans lequel le code Rust
retourne la liste des cellules qui ont changÃ© d'Ã©tat au JavaScript. Est-ce que
cela amÃ©liore la rapiditÃ© du rendu du <code>&lt;canvas&gt;</code>Â ? Pouvez-vous implÃ©menter ce
concept sans allouer une nouvelle liste de diffÃ©rences Ã  chaque <code>tick</code>Â ?</li>
</ul>
<!-- markdownlint-disable -->
<!--
* As our profiling has shown us, 2D `<canvas>` rendering is not particularly
  fast. Replace the 2D canvas renderer with a [WebGL][webgl] renderer. How much faster is
  the WebGL version? How large can you make the universe before WebGL rendering
  is a bottleneck?
-->
<!-- markdownlint-enable -->
<ul>
<li>Comme le profilage nous l'as appris, le rendu 2D du <code>&lt;canvas&gt;</code> n'est pas
particuliÃ¨rement rapide. Essayez de remplacer le rendu 2D du canvas par un
rendu avec <a href="https://developer.mozilla.org/fr/docs/Web/API/WebGL_API">WebGL</a>. Quels sont les gains de performance ? A partir de
quelle taille de l'univers le rendu en WebGL amÃ©liore les performancesÂ ?</li>
</ul>
<!--
[webgl]: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API
-->
<h1><a class="header" href="#shrinking-wasm-size" id="shrinking-wasm-size">Shrinking <code>.wasm</code> Size</a></h1>
<blockquote>
<p>ğŸ’¬ Cette page n'a pas encore Ã©tÃ© traduite.</p>
<p><a href="https://rustwasm.github.io/docs/book/">ğŸ“š Visiter ce livre en Anglais</a></p>
</blockquote>
<h1><a class="header" href="#publishing-to-npm" id="publishing-to-npm">Publishing to npm</a></h1>
<blockquote>
<p>ğŸ’¬ Cette page n'a pas encore Ã©tÃ© traduite.</p>
<p><a href="https://rustwasm.github.io/docs/book/">ğŸ“š Visiter ce livre en Anglais</a></p>
</blockquote>
<h1><a class="header" href="#reference" id="reference">Reference</a></h1>
<blockquote>
<p>ğŸ’¬ Cette page n'a pas encore Ã©tÃ© traduite.</p>
<p><a href="https://rustwasm.github.io/docs/book/">ğŸ“š Visiter ce livre en Anglais</a></p>
</blockquote>
<h1><a class="header" href="#crates-you-should-know" id="crates-you-should-know">Crates You Should Know</a></h1>
<blockquote>
<p>ğŸ’¬ Cette page n'a pas encore Ã©tÃ© traduite.</p>
<p><a href="https://rustwasm.github.io/docs/book/">ğŸ“š Visiter ce livre en Anglais</a></p>
</blockquote>
<h1><a class="header" href="#tools-you-should-know" id="tools-you-should-know">Tools You Should Know</a></h1>
<blockquote>
<p>ğŸ’¬ Cette page n'a pas encore Ã©tÃ© traduite.</p>
<p><a href="https://rustwasm.github.io/docs/book/">ğŸ“š Visiter ce livre en Anglais</a></p>
</blockquote>
<h1><a class="header" href="#project-templates" id="project-templates">Project Templates</a></h1>
<blockquote>
<p>ğŸ’¬ Cette page n'a pas encore Ã©tÃ© traduite.</p>
<p><a href="https://rustwasm.github.io/docs/book/">ğŸ“š Visiter ce livre en Anglais</a></p>
</blockquote>
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--13" id="-attention-peinture-fraÃ®che--13">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Debugging Rust-Generated WebAssembly
-->
<h1><a class="header" href="#dÃ©bogage-du-webassembly-gÃ©nÃ©rÃ©-par-rust" id="dÃ©bogage-du-webassembly-gÃ©nÃ©rÃ©-par-rust">DÃ©bogage du WebAssembly gÃ©nÃ©rÃ© par Rust</a></h1>
<!--
This section contains tips for debugging Rust-generated WebAssembly.
-->
<p>Cette section prÃ©sente des conseils pour le dÃ©bogage du WebAssembly gÃ©nÃ©rÃ© par
Rust.</p>
<!--
## Building with Debug Symbols
-->
<h2><a class="header" href="#compiler-avec-des-symboles-de-dÃ©bogage" id="compiler-avec-des-symboles-de-dÃ©bogage">Compiler avec des symboles de dÃ©bogage</a></h2>
<!--
> âš¡ When debugging, always make sure you are building with debug symbols!
-->
<blockquote>
<p>âš¡ Lorsque dÃ©boguez, assurez-vous que vous compilez avec les symboles de
dÃ©bogageÂ !</p>
</blockquote>
<!--
If you don't have debug symbols enabled, then the `"name"` custom section won't
be present in the compiled `.wasm` binary, and stack traces will have function
names like `wasm-function[42]` rather than the Rust name of the function, like
`wasm_game_of_life::Universe::live_neighbor_count`.
-->
<p>Si n'activez pas les symboles de dÃ©bogage, la section personnalisÃ©e <code>&quot;name&quot;</code> ne
sera pas prÃ©sente dans le binaire compilÃ© en <code>.wasm</code>, et les traces de pile
auront des noms de fonctions comme <code>wasm-function[42]</code> plutÃ´t que le nom de la
fonction en Rust, comme
<code>wasm_jeu_de_la_vie::Univers::compter_voisines_vivantes</code>.</p>
<!--
When using a "debug" build (aka `wasm-pack build --debug` or `cargo build`)
debug symbols are enabled by default.
-->
<p>Les symboles de dÃ©bogage sont activÃ©s par dÃ©faut lorsqu'un utilise une
compilation en mode &quot;debug&quot; (comme <code>wasm-pack build --debug</code> ou <code>cargo build</code>).</p>
<!--
With a "release" build, debug symbols are not enabled by default. To enable
debug symbols, ensure that you `debug = true` in the `[profile.release]` section
of your `Cargo.toml`:
-->
<p>Avec une compilation en mode &quot;release&quot;, les symboles de dÃ©bogage ne sont pas
activÃ©s par dÃ©faut. Pour activer les symboles de dÃ©bogage, assurez-vous que
<code>debug = true</code> soit bien prÃ©sent dans la section <code>[profile.release]</code> de votre
<code>Cargo.toml</code>Â :</p>
<!--
```toml
[profile.release]
debug = true
```
-->
<pre><code class="language-toml">[profile.release]
debug = true
</code></pre>
<!--
## Logging with the `console` APIs
-->
<h2><a class="header" href="#journaliser-avec-les-api-de-console" id="journaliser-avec-les-api-de-console">Journaliser avec les API de <code>console</code></a></h2>
<!--
Logging is one of the most effective tools we have for proving and disproving
hypotheses about why our programs are buggy. On the Web, [the `console.log`
function](https://developer.mozilla.org/en-US/docs/Web/API/Console/log) is the
way to log messages to the browser's developer tools console.
-->
<p>La journalisation est un des outils les plus efficients que nous avons Ã  notre
disposition pour prouver et rÃ©futer des hypothÃ¨ses sur le comportement
dÃ©ficient de nos programmes. Sur le Web, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/log">la fonction
<code>console.log</code></a> est
une maniÃ¨re de journaliser les messages dans la console d'outils de
dÃ©veloppement du navigateur.</p>
<!--
We can use [the `web-sys` crate][web-sys] to get access to the `console` logging
functions:
-->
<p>Nous pouvons utiliser <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html">la crate <code>web-sys</code></a> pour accÃ©der aux fonctions
de journalisation de <code>console</code>Â :</p>
<!--
```rust
extern crate web_sys;

web_sys::console::log_1(&"Hello, world!".into());
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys; // (faculatif en Rust 2018)

web_sys::console::log_1(&amp;&quot;Hello, world!&quot;.into());
<span class="boring">}
</span></code></pre></pre>
<!--
Alternatively, [the `console.error`
function](https://developer.mozilla.org/en-US/docs/Web/API/Console/error) has
the same signature as `console.log`, but developer tools tend to also capture
and display a stack trace alongside the logged message when `console.error` is
used.
-->
<p>Sachez aussi que <a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/error">la fonction
<code>console.error</code></a>
a la mÃªme signature que <code>console.log</code>, mais les outils de dÃ©veloppement ont
tendance Ã  aussi rÃ©cupÃ©rer et afficher les traces de pile Ã  cÃ´tÃ© du message de
journal lorsqu'on utilise <code>console.error</code>.</p>
<!--
### References
-->
<h3><a class="header" href="#documentations-sur-console" id="documentations-sur-console">Documentations sur <code>console</code></a></h3>
<!--
* Using `console.log` with the `web-sys` crate:
  * [`web_sys::console::log` takes an array of values to log](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log.html)
  * [`web_sys::console::log_1` logs a single value](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_1.html)
  * [`web_sys::console::log_2` logs two values](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_2.html)
  * Etc...
* Using `console.error` with the `web-sys` crate:
  * [`web_sys::console::error` takes an array of values to log](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error.html)
  * [`web_sys::console::error_1` logs a single value](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_1.html)
  * [`web_sys::console::error_2` logs two values](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_2.html)
  * Etc...
* [The `console` object on MDN](https://developer.mozilla.org/en-US/docs/Web/API/Console)
* [Firefox Developer Tools â€” Web Console](https://developer.mozilla.org/en-US/docs/Tools/Web_Console)
* [Microsoft Edge Developer Tools â€” Console](https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/console)
* [Get Started with the Chrome DevTools Console](https://developers.google.com/web/tools/chrome-devtools/console/get-started)
-->
<ul>
<li>Utiliser <code>console.log</code> avec la crate <code>web-sys</code>Â :
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log.html"><code>web_sys::console::log</code> prend en argument un tableau de valeurs Ã 
journaliser</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_1.html"><code>web_sys::console::log_1</code> journalise une seule
valeur</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_2.html"><code>web_sys::console::log_2</code> journalise deux
valeurs</a></li>
<li>Etc ...</li>
</ul>
</li>
<li>Utiliser <code>console.error</code> avec la crate <code>web-sys</code>Â :
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error.html"><code>web_sys::console::error</code> prend en argument un tableau de valeurs Ã 
journaliser</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_1.html"><code>web_sys::console::error_1</code> journalise une seule
valeur</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_2.html"><code>web_sys::console::error_2</code> journalise deux
valeurs</a></li>
<li>Etc ...</li>
</ul>
</li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/API/Console">L'objet <code>console</code> sur
MDN</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Outils/Console_Web">Outils de DÃ©veloppement Firefox â€” Console
Web</a></li>
<li><a href="https://docs.microsoft.com/fr-fr/microsoft-edge/devtools-guide/console">Outils de DÃ©veloppement de Microsoft Edge â€”
Console</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/console">DÃ©buter avec la Console de Chrome
DevTools</a></li>
</ul>
<!--
## Logging Panics
-->
<h2><a class="header" href="#journaliser-les-paniques" id="journaliser-les-paniques">Journaliser les paniques</a></h2>
<!--
[The `console_error_panic_hook` crate logs unexpected panics to the developer
console via `console.error`.][panic-hook] Rather than getting cryptic,
difficult-to-debug `RuntimeError: unreachable executed` error messages, this
gives you Rust's formatted panic message.
-->
<p><a href="https://github.com/rustwasm/console_error_panic_hook">La crate <code>console_error_panic_hook</code> journalise les paniques involontaires dans
la console avec <code>console.error</code></a>. PlutÃ´t que d'avoir des messages
d'erreur abstraits, difficiles Ã  dÃ©boguer comme le
<code>RuntimeError: unreachable executed</code>, il vous fournit Ã  la place un message de
panique formatÃ© par Rust.</p>
<!--
All you need to do is install the hook by calling
`console_error_panic_hook::set_once()` in an initialization function or common
code path:
-->
<p>Tout ce que vous avez besoin de faire est d'installer ce systÃ¨me en faisant
appel Ã  <code>console_error_panic_hook::set_once()</code> dans une fonction
d'initialisation ou dans un code standard qui s'exÃ©cuteraÂ :</p>
<!--
```rust
#[wasm_bindgen]
pub fn init_panic_hook() {
    console_error_panic_hook::set_once();
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn installer_systeme_journalisation_panique() {
    console_error_panic_hook::set_once();
}
<span class="boring">}
</span></code></pre></pre>
<!--
[panic-hook]: https://github.com/rustwasm/console_error_panic_hook
-->
<!--
## Using a Debugger
-->
<h2><a class="header" href="#utiliser-un-dÃ©bogueur" id="utiliser-un-dÃ©bogueur">Utiliser un dÃ©bogueur</a></h2>
<!--
Unfortunately, the debugging story for WebAssembly is still immature. On most
Unix systems, [DWARF][dwarf] is used to encode the information that a debugger
needs to provide source-level inspection of a running program. There is an
alternative format that encodes similar information on Windows. Currently, there
is no equivalent for WebAssembly. Therefore, debuggers currently provide limited
utility, and we end up stepping through raw WebAssembly instructions emitted by
the compiler, rather than the Rust source text we authored.
-->
<p>Malheureusement, le dÃ©bogage pour le WebAssembly reste embryonnaire. Dans la
plupart des systÃ¨mes Unix, <a href="http://dwarfstd.org/">DWARF</a> est utilisÃ© pour encoder les
informations qu'un dÃ©bogueur a besoin d'avoir pour procÃ©der Ã  l'inspection de la
source d'un programme en cours d'exÃ©cution. Il existe aussi un format alternatif
qui encode des informations similaires sous Windows. Pour l'instant, il n'y a
pas d'Ã©quivalent pour WebAssembly. C'est pourquoi les dÃ©bogueurs sont des outils
limitÃ©s pour le moment, et nous finissons par passer par des instructions
WebAssembly brutes Ã©mises par le compilateur, plutÃ´t que par le code source Rust
que nous avons rÃ©digÃ©.</p>
<!--
> There is a [sub-charter of the W3C WebAssembly group for
> debugging][debugging-subcharter], so expect this story to improve in the
> future!
-->
<blockquote>
<p>Il existe
<a href="https://github.com/WebAssembly/debugging">une sous-commission du groupe W3C dÃ©diÃ©e au dÃ©bogage</a>,
donc attendez-vous Ã  ce que les choses s'amÃ©liorent Ã  l'avenirÂ !</p>
</blockquote>
<!--
[debugging-subcharter]: https://github.com/WebAssembly/debugging
[dwarf]: http://dwarfstd.org/
-->
<!--
Nonetheless, debuggers are still useful for inspecting the JavaScript that
interacts with our WebAssembly, and inspecting raw wasm state.
-->
<p>Toutefois, les dÃ©bogueurs restent utiles pour inspecter le JavaScript qui
interagit avec notre WebAssembly, et inspecter l'Ã©tat brut du wasm.</p>
<!--
### References
-->
<h3><a class="header" href="#documentations-sur-le-dÃ©bogueur" id="documentations-sur-le-dÃ©bogueur">Documentations sur le dÃ©bogueur</a></h3>
<!--
* [Firefox Developer Tools â€” Debugger](https://developer.mozilla.org/en-US/docs/Tools/Debugger)
* [Microsoft Edge Developer Tools â€” Debugger](https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/debugger)
* [Get Started with Debugging JavaScript in Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools/javascript/)
-->
<ul>
<li><a href="https://developer.mozilla.org/fr/docs/Outils/D%C3%A9bogueur">Outils de DÃ©veloppement de Firefox â€”
DÃ©bogueur</a></li>
<li><a href="https://docs.microsoft.com/fr-fr/microsoft-edge/devtools-guide/debugger">Outils de DÃ©veloppement de Microsoft Edge â€”
DÃ©bogueur</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/javascript/">DÃ©buter dans le DÃ©bogage du JavaScript dans Chrome
DevTools</a></li>
</ul>
<!--
## Avoid the Need to Debug WebAssembly in the First Place
-->
<h2><a class="header" href="#eviter-davoir-besoin-de-dÃ©boguer-le-webassembly-dans-un-premier-temps" id="eviter-davoir-besoin-de-dÃ©boguer-le-webassembly-dans-un-premier-temps">Eviter d'avoir besoin de dÃ©boguer le WebAssembly dans un premier temps</a></h2>
<!--
If the bug is specific to interactions with JavaScript or Web APIs, then [write
tests with `wasm-bindgen-test`.][wbg-test]
-->
<p>Si le bogue concerne des interactions avec le JavaScript ou des API Web, alors
<a href="https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html">Ã©crivez des tests avec <code>wasm-bindgen-test</code></a>.</p>
<!--
If a bug does *not* involve interaction with JavaScript or Web APIs, then try to
reproduce it as a normal Rust `#[test]` function, where you can leverage your
OS's mature native tooling when debugging. Use testing crates like
[`quickcheck`][quickcheck] and its test case shrinkers to mechanically reduce
test cases. Ultimately, you will have an easier time finding and fixing bugs if
you can isolate them in a smaller test cases that don't require interacting with
JavaScript.
-->
<p>Si le bogue <em>n'implique pas</em> d'interactions avec JavaScript ou des API Web,
alors essayez de le reproduire dans une fonction <code>#[test]</code> Rust traditionnelle,
dans laquelle vous pouvez profiter des outils natifs de votre systÃ¨me
d'exploitation lorsque vous dÃ©boguez. Utilisez des crates pour les tests comme
<a href="https://crates.io/crates/quickcheck"><code>quickcheck</code></a> et ses cas de test qui rÃ©duisent automatiquement les
cas Ã  tester. Finalement, il vous sera plus facile de trouver et de corriger des
bogues si vous pouvez les isoler dans des cas de test plus petits et qui ne
nÃ©cessitent pas d'interaction avec le JavaScript.</p>
<!--
Note that in order to run native `#[test]`s without compiler and linker errors,
you will need to ensure that `"rlib"` is included in the `[lib.crate-type]`
array in your `Cargo.toml` file.
-->
<p>Notez toutefois que pour pouvoir exÃ©cuter des <code>#[test]</code> natifs sans erreurs de
compilateur et de liaison, vous aurez besoin de vous assurer que <code>&quot;rlib&quot;</code> soit
bien prÃ©sent dans le tableau <code>[lib.crate-type]</code> dans votre fichier <code>Cargo.toml</code>.</p>
<!--
```toml
[lib]
crate-type ["cdylib", "rlib"]
```
-->
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]
</code></pre>
<!--
[quickcheck]: https://crates.io/crates/quickcheck
[web-sys]: https://rustwasm.github.io/wasm-bindgen/web-sys/index.html
[wbg-test]: https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html
-->
<blockquote>
<h1><a class="header" href="#-attention-peinture-fraÃ®che--14" id="-attention-peinture-fraÃ®che--14">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
</blockquote>
<!--
# Time Profiling
-->
<h1><a class="header" href="#le-profilage-temporel-1" id="le-profilage-temporel-1">Le profilage temporel</a></h1>
<!--
This section describes how to profile Web pages using Rust and WebAssembly where
the goal is improving throughput or latency.
-->
<p>Cette section dÃ©crit comment profiler des pages web qui utilise Rust et
WebAssembly dans le but d'amÃ©liorer le dÃ©bit ou de rÃ©duire la latence.</p>
<!--
> âš¡ Always make sure you are using an optimized build when profiling! `wasm-pack
> build` will build with optimizations by default.
-->
<blockquote>
<p>âš¡ Assurez-vous que vous utilisez toujours une compilation optimisÃ©e lorsque
vous faites un profilageÂ ! <code>wasm-pack build</code> devrait compiler avec les
optimisations par dÃ©faut.</p>
</blockquote>
<!--
## Available Tools
-->
<h2><a class="header" href="#les-outils-disponibles" id="les-outils-disponibles">Les outils disponibles</a></h2>
<!--
### The `window.performance.now()` Timer
-->
<h3><a class="header" href="#le-chronomÃ¨tre-windowperformancenow" id="le-chronomÃ¨tre-windowperformancenow">Le chronomÃ¨tre <code>window.performance.now()</code></a></h3>
<!--
[The `performance.now()` function][perf-now] returns a monotonic timestamp
measured in milliseconds since the Web page was loaded.
-->
<p><a href="https://developer.mozilla.org/fr/docs/Web/API/Performance/now">La fonction <code>performance.now()</code></a> retourne un chronomÃ¨tre en
millisecondes qui commence depuis que la page web a Ã©tÃ© chargÃ©e.</p>
<!--
Calling `performance.now` has little overhead, so we can create simple, granular
measurements from it without distorting the performance of the rest of the
system and inflicting bias upon our measurements.
-->
<p>L'appel Ã  <code>performance.now</code> n'a que trÃ¨s peu d'impact sur les performances, donc
nous pouvons crÃ©er des mesures simples et granulaires grÃ¢ce Ã  elle sans impacter
le reste du systÃ¨me et sans introduire de biais Ã  ces mesures.</p>
<!--
We can use it to time various operations, and we can access
`window.performance.now()` via [the `web-sys` crate][web-sys]:
-->
<p>Nous pouvons l'utiliser pour chronomÃ©trer diffÃ©rentes opÃ©rations, et nous
pouvons accÃ©der Ã  <code>window.performance.now()</code> via <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html">la crate <code>web-sys</code></a>Â :</p>
<!--
```rust
extern crate web_sys;

fn now() -> f64 {
    web_sys::window()
        .expect("should have a Window")
        .performance()
        .expect("should have a Performance")
        .now()
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

fn now() -&gt; f64 {
    web_sys::window()
        .expect(&quot;nous n'avons pas accÃ¨s Ã  l'objet `window`&quot;)
        .performance()
        .expect(&quot;nous n'avons pas accÃ¨s Ã  l'objet `window.performance`&quot;)
        .now()
}
<span class="boring">}
</span></code></pre></pre>
<!-- markdownlint-disable -->
<!--
* [The `web_sys::window` function](https://rustwasm.github.io/wasm-bindgen/api/web_sys/fn.window.html)
* [The `web_sys::Window::performance` method](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.performance)
* [The `web_sys::Performance::now` method](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Performance.html#method.now)
-->
<!-- markdownlint-restore -->
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/fn.window.html">Documentation de la fonction <code>web_sys::window</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.performance">Documentation de la mÃ©thode
<code>web_sys::Window::performance</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Performance.html#method.now">Documentation de la mÃ©thode
<code>web_sys::Performance::now</code></a></li>
</ul>
<!--
[perf-now]: https://developer.mozilla.org/en-US/docs/Web/API/Performance/now
-->
<!--
### Developer Tools Profilers
-->
<h3><a class="header" href="#les-profileurs-des-outils-de-dÃ©veloppement" id="les-profileurs-des-outils-de-dÃ©veloppement">Les profileurs des outils de dÃ©veloppement</a></h3>
<!--
All Web browsers' built-in developer tools include a profiler. These profilers
display which functions are taking the most time with the usual kinds of
visualizations like call trees and flame graphs.
-->
<p>Tous les outils de dÃ©veloppement intÃ©grÃ©s dans les navigateurs web embarquent un
profileur. Ces profileurs mettent en Ã©vidence les fonctions qui prennent le plus
de temps Ã  s'exÃ©cuter avec les outils de visualisation habituels comme les
arbres d'appels et les <em>flame graphs</em>.</p>
<!--
If you [build with debug symbols][symbols] so that the "name" custom section is
included in the wasm binary, then these profilers should display the Rust
function names instead of something opaque like `wasm-function[123]`.
-->
<p>Si vous <a href="reference/./debugging.html">compilez avec les symboles de dÃ©boguage</a> afin que la section
personnalisÃ©e &quot;name&quot; soit ajoutÃ©e dans le binaire wasm, alors ces profileurs
devraient afficher les noms des fonctions Rust plutÃ´t qu'un nom obscur comme
<code>wasm-function[123]</code>.</p>
<!--
Note that these profilers *won't* show inlined functions, and since Rust and
LLVM rely on inlining so heavily, the results might still end up a bit
perplexing.
-->
<p>Sachez toutefois que ces profileurs <em>ne vont pas</em> montrer les fonctions
intÃ©grÃ©es, et comme Rust et LLVM utilisent beaucoup de fonction intÃ©grÃ©es, les
rÃ©sultats deviendraient compliquÃ©s.</p>
<!--
[symbols]: ./debugging.html#building-with-debug-symbols
-->
<!-- markdownlint-disable -->
<!--
[![Screenshot of profiler with Rust symbols](../images/game-of-life/profiler-with-rust-names.png)](../images/game-of-life/profiler-with-rust-names.png)
-->
<!-- markdownlint-enable -->
<p><a href="reference/../images/game-of-life/profiler-with-rust-names.png"><img src="reference/../images/game-of-life/profiler-with-rust-names.png" alt="Capture d'Ã©cran d'un profileur avec les symboles Rust" /></a></p>
<!--
#### Resources
-->
<h4><a class="header" href="#ressources-sur-les-profileurs-web" id="ressources-sur-les-profileurs-web">Ressources sur les profileurs web</a></h4>
<!-- markdownlint-disable -->
<!--
* [Firefox Developer Tools â€” Performance](https://developer.mozilla.org/en-US/docs/Tools/Performance)
* [Microsoft Edge Developer Tools â€” Performance](https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/performance)
* [Chrome DevTools JavaScript Profiler](https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution)
-->
<!-- markdownlint-enable -->
<ul>
<li><a href="https://developer.mozilla.org/fr/docs/Outils/Performance">Outils de dÃ©veloppement de Firefox â€” Performance</a></li>
<li><a href="https://docs.microsoft.com/fr-fr/microsoft-edge/devtools-guide/performance">Outils de dÃ©veloppement de Microsoft Edge â€” Performance</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution">Profileur JavaScript de Chrome DevTools</a></li>
</ul>
<!--
### The `console.time` and `console.timeEnd` Functions
-->
<h3><a class="header" href="#les-fonctions-consoletime-et-consoletimeend" id="les-fonctions-consoletime-et-consoletimeend">Les fonctions <code>console.time</code> et <code>console.timeEnd</code></a></h3>
<!--
[The `console.time` and `console.timeEnd` functions][console-time] allow you to
log the timing of named operations to the browser's developer tools console. You
call `console.time("some operation")` when the operation begins, and call
`console.timeEnd("some operation")` when it finishes. The string label naming
the operation is optional.
-->
<p><a href="https://developer.mozilla.org/fr/docs/Web/API/Console/time">Les fonctions <code>console.time</code> et <code>console.timeEnd</code></a> vous
permettent de journaliser la chronologie des opÃ©rations demandÃ©es dans la
console d'outils de dÃ©veloppements du navigateur. Vous pouvez appeler
<code>console.time(&quot;le nom de l'opÃ©ration&quot;)</code> lorsque l'opÃ©ration commence, et appeler
<code>console.timeEnd(&quot;le nom de l'opÃ©ration&quot;)</code> lorsqu'elle se termine. Le nom de
l'opÃ©ration est optionnel.</p>
<!--
You can use these functions directly via [the `web-sys` crate][web-sys]:
-->
<p>Vous pouvez utiliser directement ces fonctions <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html">avec la crate
<code>web-sys</code></a>Â :</p>
<!-- markdownlint-disable -->
<!--
* [`web_sys::console::time_with_label("some
  operation")`](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.time_with_label.html)
* [`web_sys::console::time_end_with_label("some
  operation")`](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.time_end_with_label.html)
-->
<!-- markdownlint-enable -->
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.time_with_label.html"><code>web_sys::console::time_with_label(&quot;une opÃ©ration&quot;)</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.time_end_with_label.html"><code>web_sys::console::time_end_with_label(&quot;une opÃ©ration&quot;)</code></a></li>
</ul>
<!--
Here is a screenshot of `console.time` logs in the browser's console:
-->
<p>Voici une capture d'Ã©cran des journaux de <code>console.time</code> dans la console du
navigateurÂ :</p>
<!-- markdownlint-disable -->
<!--
[![Screenshot of console.time logs](../images/game-of-life/console-time.png)](../images/game-of-life/console-time.png)
-->
<!-- markdownlint-enable -->
<p><a href="reference/../images/game-of-life/console-time.png"><img src="reference/../images/game-of-life/console-time.png" alt="Capture d'Ã©cran des journaux de console.time" /></a></p>
<!--
Additionally, `console.time` and `console.timeEnd` logs will show up in your
browser's profiler's "timeline" or "waterfall" view:
-->
<p>De plus, les journaux de <code>console.time</code> et de <code>console.timeEnd</code> vont s'afficher
dans les vues &quot;timeline&quot; ou &quot;chronologie&quot; du profileur de votre navigateurÂ :</p>
<!-- markdownlint-disable -->
<!--
[![Screenshot of console.time logs](../images/game-of-life/console-time-in-profiler.png)](../images/game-of-life/console-time-in-profiler.png)
-->
<!-- markdownlint-enable -->
<p><a href="reference/../images/game-of-life/console-time-in-profiler.png"><img src="reference/../images/game-of-life/console-time-in-profiler.png" alt="Capture d'Ã©cran des journaux de console.time" /></a></p>
<!--
[console-time]: https://developer.mozilla.org/en-US/docs/Web/API/Console/time
-->
<!--
### Using `#[bench]` with Native Code
-->
<h3><a class="header" href="#utiliser-bench-sur-du-code-natif" id="utiliser-bench-sur-du-code-natif">Utiliser <code>#[bench]</code> sur du code natif</a></h3>
<!--
The same way we can often leverage our operating system's native code debugging
tools by writing `#[test]`s rather than debugging on the Web, we can leverage
our operating system's native code profiling tools by writing `#[bench]`
functions.
-->
<p>De la mÃªme maniÃ¨re que nous pouvons tirer avantage des outils de dÃ©boguage de
code de notre systÃ¨me d'exploitation en crÃ©ant des fonctions <code>#[test]</code> plutÃ´t
que de dÃ©boguer sur le web, nous pouvons tirer avantage des outils de profilage
de code de notre systÃ¨me d'exploitation en crÃ©ant des fonctions <code>#[bench]</code>.</p>
<!--
Write your benchmarks in the `benches` subdirectory of your crate. Make sure
that your `crate-type` includes `"rlib"` or else the bench binaries won't be
able to link your main lib.
-->
<p>Ecrivez vos tests de performance dans le sous-dossier <code>benches</code> de votre crate.
Assurez-vous que votre <code>crate-type</code> inclut bien <code>&quot;rlib&quot;</code> ou sinon les binaires
ne seront pas capables de se relier Ã  votre bibliothÃ¨que principale.</p>
<!--
However! Make sure that you know the bottleneck is in the WebAssembly before
investing much energy in native code profiling! Use your browser's profiler to
confirm this, or else you risk wasting your time optimizing code that isn't hot.
-->
<p>Cependant, attentionÂ ! Assurez-vous d'abord que le problÃ¨me de performance se
trouve bien dans le WebAssembly avant d'investir votre temps dans le profilage
du code natifÂ ! Utilisez le profileur de votre navigateur pour vÃ©rifier cela,
ou sinon vous risques de perdre votre temps Ã  optimiser du code qui est
potentiellement nÃ©gligeable en termes de performance.</p>
<!--
#### Resources
-->
<h4><a class="header" href="#ressources-sur-les-profileurs-natifs" id="ressources-sur-les-profileurs-natifs">Ressources sur les profileurs natifs</a></h4>
<!-- markdownlint-disable -->
<!--
* [Using the `perf` profiler on Linux](http://www.brendangregg.com/perf.html)
* [Using the Instruments.app profiler on macOS](https://help.apple.com/instruments/mac/current/)
* [The VTune profiler supports Windows and Linux](https://software.intel.com/en-us/vtune)
-->
<!-- markdownlint-enable -->
<ul>
<li><a href="http://www.brendangregg.com/perf.html">Utiliser le profileur <code>perf</code> sur Linux</a></li>
<li><a href="https://help.apple.com/instruments/mac/current/">Utiliser le profileur Instruments.app sur macOS</a></li>
<li><a href="https://software.intel.com/en-us/vtune">Utiliser le profileur VTune sur Windows and Linux</a></li>
</ul>
<!--
[web-sys]: https://rustwasm.github.io/wasm-bindgen/web-sys/index.html
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="github-button.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
